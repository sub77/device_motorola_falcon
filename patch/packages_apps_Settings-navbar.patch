From 6107f5f6fe7fec34485eff2885528e5ec4c027fd Mon Sep 17 00:00:00 2001
From: Lars Greiss <kufikugel@googlemail.com>
Date: Fri, 15 Nov 2013 06:04:05 +0100
Subject: [PATCH] Settings: Slims navbar customizations

patchset 14: fix reset button in button style screen

patchset 15: CheckBoxPreference to SwitchPreference

patchset 16-24: refer to correct reset icon

patchset 21: fix navigation dashboard icon

add back our navbar tweeks. This is a completly overworked
version compared to the one we carry about a year now. Small glitches
we had are now all fixed. As well it does not need to register extra observers
code was much slimmed down and improved.
Beside that we adapt the 4.4 navbar changes to our system so that it it
consistent with the new 4.4 UI
This patch adds:
- Navbar up to 5 buttons
- dynamic menu behaviour
- landscape navbar options as well now on tablets
- button glow color
- button icon color
- navrign and navbar user can set system or custom icons
- navbar height and width
- enable/disable navbar
- actions are vor navbar and available for the whole system over SlimActions.java
	back
	custom app or activtiy
	home
	kill app
	last app
	notification drawer
	ime switcher
	power menu
	qs pannel
	recents screen
	screen off
	screenshot
	search
	torch if it is available on the device
- added Color class based on blk_jacks idea which first grey an icon out
  and then color it. This gives way better results. As well it fits now
  perfectly with the new 4.4 UI. Put it on a central place so that it is
  from everywhere available. notification shortcuts adapted to the new class
  place
- complete new icons thanks to kroz who has redone all for xxhdpi
- our slim special swipe drag drop press longpress options support
  like on 4.3 this two features
- a lot lot fixes as well on current google code

Signed-off-by: sub77 <sub77@ymail.com>

Conflicts:
	res/values-h480dp/dimens.xml
	res/values/slim_arrays.xml
	res/values/slim_strings.xml
	res/xml/settings_headers.xml
	src/com/android/settings/slim/dslv/ButtonsListViewSettings.java
	src/com/android/settings/slim/fragments/NotificationsShortcutFragment.java

Change-Id: Ic000e81c9e3a191ba676632f4fab99d3007bde77

add dslv controller

a lot of our settings have drag swipe features
this is the central controller for it to have
easy access...

Change-Id: I9eb9849f2585510649f49c75915b0c7f3c508fdd
Signed-off-by: sub77 <sub77@ymail.com>
---
 res/drawable-hdpi/ic_action_set.png                |  Bin 0 -> 765 bytes
 res/drawable-hdpi/ic_grabber.png                   |  Bin 0 -> 496 bytes
 res/drawable-hdpi/ic_settings_reset_button.png     |  Bin 0 -> 601 bytes
 res/drawable-mdpi/ic_action_set.png                |  Bin 0 -> 435 bytes
 res/drawable-mdpi/ic_grabber.png                   |  Bin 0 -> 286 bytes
 res/drawable-mdpi/ic_settings_reset_button.png     |  Bin 0 -> 333 bytes
 res/drawable-xhdpi/ic_action_set.png               |  Bin 0 -> 785 bytes
 res/drawable-xhdpi/ic_grabber.png                  |  Bin 0 -> 431 bytes
 res/drawable-xhdpi/ic_settings_reset_button.png    |  Bin 0 -> 680 bytes
 res/drawable-xxhdpi/ic_action_set.png              |  Bin 0 -> 1390 bytes
 res/drawable-xxhdpi/ic_grabber.png                 |  Bin 0 -> 895 bytes
 res/drawable-xxhdpi/ic_settings_reset_button.png   |  Bin 0 -> 1245 bytes
 res/drawable-xxxhdpi/ic_action_set.png             |  Bin 0 -> 1342 bytes
 res/drawable-xxxhdpi/ic_grabber.png                |  Bin 0 -> 690 bytes
 res/drawable-xxxhdpi/ic_settings_reset_button.png  |  Bin 0 -> 1512 bytes
 res/drawable/ic_settings_navigation.xml            |   53 +
 res/layout/action_list_view_item.xml               |   68 +
 res/layout/action_list_view_main.xml               |   67 +
 res/layout/dialog_color_picker.xml                 |  154 +
 res/values/attrs.xml                               |   30 +
 res/values/slim_arrays.xml                         |  298 ++
 res/values/slim_colors.xml                         |   21 +
 res/values/slim_dimens.xml                         |   27 +
 res/values/slim_ids.xml                            |   19 +
 res/values/slim_strings.xml                        |  235 ++
 res/xml/dashboard_categories.xml                   |    8 +
 res/xml/device_info_storage_volume.xml             |    5 +
 res/xml/navbar_button_fragment.xml                 |   25 +
 res/xml/navbar_button_style.xml                    |   46 +
 res/xml/navbar_settings.xml                        |   71 +
 res/xml/navbar_style_dimen_settings.xml            |   40 +
 res/xml/slim_navigation_settings.xml               |   47 +
 src/com/android/settings/SettingsActivity.java     |    2 +
 .../android/settings/slim/NavBarButtonStyle.java   |  207 ++
 src/com/android/settings/slim/NavbarSettings.java  |  144 +
 .../settings/slim/NavbarStyleDimenSettings.java    |  197 ++
 .../android/settings/slim/NavigationSettings.java  |   46 +
 .../settings/slim/dslv/ActionListViewSettings.java |  989 +++++++
 .../settings/slim/dslv/DragSortController.java     |  488 ++++
 .../settings/slim/dslv/DragSortItemView.java       |  118 +
 .../settings/slim/dslv/DragSortListView.java       | 3067 ++++++++++++++++++++
 .../settings/slim/dslv/SimpleFloatViewManager.java |  106 +
 .../slim/fragments/NavbarButtonFragment.java       |   63 +
 .../settings/slim/util/ShortcutPickerHelper.java   |  177 ++
 .../colorpicker/AlphaPatternDrawable.java          |  128 +
 .../preference/colorpicker/ColorPickerDialog.java  |  214 ++
 .../colorpicker/ColorPickerPanelView.java          |  172 ++
 .../colorpicker/ColorPickerPreference.java         |  317 ++
 .../preference/colorpicker/ColorPickerView.java    |  962 ++++++
 49 files changed, 8611 insertions(+)
 create mode 100644 res/drawable-hdpi/ic_action_set.png
 create mode 100644 res/drawable-hdpi/ic_grabber.png
 create mode 100644 res/drawable-hdpi/ic_settings_reset_button.png
 create mode 100644 res/drawable-mdpi/ic_action_set.png
 create mode 100644 res/drawable-mdpi/ic_grabber.png
 create mode 100644 res/drawable-mdpi/ic_settings_reset_button.png
 create mode 100644 res/drawable-xhdpi/ic_action_set.png
 create mode 100644 res/drawable-xhdpi/ic_grabber.png
 create mode 100644 res/drawable-xhdpi/ic_settings_reset_button.png
 create mode 100644 res/drawable-xxhdpi/ic_action_set.png
 create mode 100644 res/drawable-xxhdpi/ic_grabber.png
 create mode 100644 res/drawable-xxhdpi/ic_settings_reset_button.png
 create mode 100644 res/drawable-xxxhdpi/ic_action_set.png
 create mode 100644 res/drawable-xxxhdpi/ic_grabber.png
 create mode 100644 res/drawable-xxxhdpi/ic_settings_reset_button.png
 create mode 100644 res/drawable/ic_settings_navigation.xml
 create mode 100644 res/layout/action_list_view_item.xml
 create mode 100644 res/layout/action_list_view_main.xml
 create mode 100644 res/layout/dialog_color_picker.xml
 create mode 100644 res/values/slim_arrays.xml
 create mode 100644 res/values/slim_colors.xml
 create mode 100755 res/values/slim_dimens.xml
 create mode 100644 res/values/slim_ids.xml
 create mode 100644 res/values/slim_strings.xml
 create mode 100644 res/xml/navbar_button_fragment.xml
 create mode 100644 res/xml/navbar_button_style.xml
 create mode 100644 res/xml/navbar_settings.xml
 create mode 100644 res/xml/navbar_style_dimen_settings.xml
 create mode 100644 res/xml/slim_navigation_settings.xml
 create mode 100644 src/com/android/settings/slim/NavBarButtonStyle.java
 create mode 100644 src/com/android/settings/slim/NavbarSettings.java
 create mode 100644 src/com/android/settings/slim/NavbarStyleDimenSettings.java
 create mode 100644 src/com/android/settings/slim/NavigationSettings.java
 create mode 100644 src/com/android/settings/slim/dslv/ActionListViewSettings.java
 create mode 100644 src/com/android/settings/slim/dslv/DragSortController.java
 create mode 100644 src/com/android/settings/slim/dslv/DragSortItemView.java
 create mode 100644 src/com/android/settings/slim/dslv/DragSortListView.java
 create mode 100644 src/com/android/settings/slim/dslv/SimpleFloatViewManager.java
 create mode 100644 src/com/android/settings/slim/fragments/NavbarButtonFragment.java
 create mode 100644 src/com/android/settings/slim/util/ShortcutPickerHelper.java
 create mode 100644 src/net/margaritov/preference/colorpicker/AlphaPatternDrawable.java
 create mode 100644 src/net/margaritov/preference/colorpicker/ColorPickerDialog.java
 create mode 100644 src/net/margaritov/preference/colorpicker/ColorPickerPanelView.java
 create mode 100644 src/net/margaritov/preference/colorpicker/ColorPickerPreference.java
 create mode 100644 src/net/margaritov/preference/colorpicker/ColorPickerView.java

diff --git a/res/drawable-hdpi/ic_action_set.png b/res/drawable-hdpi/ic_action_set.png
new file mode 100644
index 0000000000000000000000000000000000000000..020fd56b42039e7822aa874f2079928809a6446f
GIT binary patch
literal 765
zcmV<Z0s{SsP)<h;3K|Lk000e1NJLTq001xm001xu1^@s6R|5Hm0008SNkl<Zc-rll
z+iTQ76vj`zRc*acRO$tMQAAWkP(-0B=wBe{U!iZl3Q@W<liejtlSy`iYbz*%`{0ug
z;)8<VgFYx$ML`j%RiC}}W_A50*=FM^_13fr%m;^%EXn-NnQu;JL!_mprKP2%rS)qS
z3LRt^^Rfx=8r>w>b#mEJs@L1H174>#a``6m_&pr!h#_+Lq3k43$!{i4pz{1{kboy9
z5v6Rvm#y{Wiu)0~I(ocDer|2bZ3B;c<`%#|Xn=?ClHDN3T$h0bYi<Sn%~<6p5tqr$
zcc&k|THFZO!5?hn@=H`MtVzFZ`f}R=`?zTvELc}uOFz7lBX$7#cC+$g0t@y6^|RI4
zXq7I1+T!^E@{6m|4X(BY6|obr&tlz1!C$4S)s@76i^(=O%v_)6y8wF!@hyOtd>q!P
zCIf%VSb#xJARYx(`(H`14bOTW!Mpqm_Bj=@jILy+yDW}lkPnT)UQvbZ`=_0uy2t6=
zjRaoAY@^_>P{~-CoL?o&VR}az`w>+&yyC_Fzkf;bJ-Gia?hPyN@lhOI^2Lf|7o2S`
zM-n9rHW5o=h<vv9&!3?@&t69Gs#Qv6Cl4S0Lm@?fltd707}pL=YbW)agyod=nzm8T
zxJahCY<63pZ!E>YMa1VA%;2<pbY(SVIZsS=n~`ufjm|mRY`LBAu0V{(l6XUQzUSwJ
zVKHU3DfqDRMLIv*m2Z`0EkPyyuy;pEyd{}COtoY41KZfF2iIOlzpI2LKSzaA9qD+J
zhDk8MeT+dqK^!43e-P&nW66CAW=-9bx-SJmi{)c6*msEG=v)Ss7jx(N-?!Lya+uTT
z>GhTvga0KBU>lNZ*(cjE6K4SYJ_fI>)f?=gG9lGs%jRi7j|P=@_}Rc>nUe1>MBgu9
vHu|V$EXw9rGy~w7v5l6NmX?;5*39WUYW%j)-?3)r00000NkvXXu0mjf>W^~y

literal 0
HcmV?d00001

diff --git a/res/drawable-hdpi/ic_grabber.png b/res/drawable-hdpi/ic_grabber.png
new file mode 100644
index 0000000000000000000000000000000000000000..ce5dab7ba7a5cd7592f884948ebdfc5f216d1b34
GIT binary patch
literal 496
zcmV<M0T2F(P)<h;3K|Lk000e1NJLTq0021v0021%1^@s6j2MH30005ENkl<Zc-rln
z&q~8U5XMJOA}WXnLGbARCnz2SpDY)5Q$dh+H;o7JXh9IX=uLeB6)U2m9`sTlqOCL2
zC|Fv%LPL{ve(({RPB!y(rcJsV06`E0K@bFCkhEGO5Cmhq^_G%a1*4C_7FYZ;7X+hh
z(CQad3ygY(J+<slMaf7-t%FrHHuxo@Z+X8LM!AA)u=&Fzy(Xi%Zr#on?J4yNF~(7R
zCa}Q-M0(mu6}^cjYQG!&R*mCb$EG~eF}O32?R9|(Jvr*5ON;hWGl_Q_JEA-=pMeu|
z>%BQ9ownY=gll3_O!mU48HmCXZjXj8tIM2^APAmQF3#Z(&nbTC?=qk>&POgGV)8$m
z+})amNFCw{E;FDi=OYM$=g?ih)fF)MWazSCoX)=xxlW479GRrqF&m!a2_79pvugD}
z&eqkF<NA-E+H75W!gw6^i<5m-3a0SxXahf#YbTRN-*7w~=Q2L!k(o7+sJMhiANrVl
z;J93`i5Rt*RJ74yu7PcL#qZ}Hs!*&7U0Rn67W`Vi<BIB}b;Emzw-@|eac&!}vO#a5
m${qOr%zz*Wf*=UOF!%(0#!an^c!J3Q0000<MNUMnLSTa3Ki(k#

literal 0
HcmV?d00001

diff --git a/res/drawable-hdpi/ic_settings_reset_button.png b/res/drawable-hdpi/ic_settings_reset_button.png
new file mode 100644
index 0000000000000000000000000000000000000000..f74aabc3a5ec38fa2c1c77dfd5b7cc0cf1418cd8
GIT binary patch
literal 601
zcmV-f0;c_mP)<h;3K|Lk000e1NJLTq001Na001Ni1^@s6;Q*MJ0006YNkl<Zc-rlk
zyGjE=6oySyG)d)Ro?tZ=f+_5cFJUm?D|l&Lq9z32AgR<>uuC1==qp$z7O_x4!9~pa
z5Bv+muuk?etIZzxV40jbb28^LGjns9WbzN<d0qijK^+_dhluYzuqAZ<!jU}K2Lmty
zZ@>jp;&N<6odYnRh9iq$2i$wn<pJyp8z#eZ3dYJpVi)?L2QEpEW2){GZ4^v6a}7Qv
z<1fsY4Pb#KhBD7@i@!P4_2rYc3Q5A`NY1#-3p;`h8{BcO@01fOe9W0A$(b8aj$x<F
zopGh`)#6l>oWO%P&PeuFxl_Ij#TrozG?bjN4HSp1<WwU{A`hgAj=}cfD7(HKW>S?U
z?U(k3L5C_*OAxlV!c3~O+j{INmPU64w7>*BgSHsc=v%buagBNyhmNF*5RGn0qbr>G
zlENUqTN-`Qr@B(*9*2$dl#@jF&1rNe0Y}ATM)h{6_YImsO6TAs#F_M={`-UuO@DK!
z#I1jy;f%<Sk}|g)5VCgSkV#JcCN0&OfTW%nPiltmT^A<9WnY~&p$IPMRA89?qcIk_
zQ!T^Jti?JyQo8z<6CJK8ICGWg`k^tt3DzTq$;<^UprLJpNAL>Hlq+nG_*d8p7k)K%
zg$?L8x6+Z~v3&b%bRE*wT=E@bZ#5WN;FWe5;~6C8)QmlYG!Mmbh=*e1PpU~YH0ddQ
n!klV~vx#HXP)#qBOj3{^ph~L8M=VH&00000NkvXXu0mjfDP9l~

literal 0
HcmV?d00001

diff --git a/res/drawable-mdpi/ic_action_set.png b/res/drawable-mdpi/ic_action_set.png
new file mode 100644
index 0000000000000000000000000000000000000000..da05c258abbf78b8f058ef1686c4e4804ba52326
GIT binary patch
literal 435
zcmV;k0ZjghP)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F80004cNkl<Zc-rlj
z+e*Vg5QYb@JYcEyfNvsb5f31Opdbi>_zFHlE;PF_nnJtVT2KU^z+0h$h$x6ur08>~
zwN-0D|0YAd5L9Zrg64;TKqm9e{<GPHC{(CW|3aSELCRhs%W5+Z-?iFFivz?fV#h2z
zYju*AIUk;uRm#}Q=HRZ|MQL%!E3YD!%)$2n*W!rbFQnw6Ik@9=19}|5Wd$xQn1d&+
z2!JQN@(O8Z-XJ^~0rWK3aN?P^<Xq#gjgp%v((~<S5>^zu{ETgXqLe+`_)4_cXAASR
z?Zv)^C!)wbufx-F=4V!FF@-2|!Ar_+^nG%|#gKQw4L>5Ln=?=4Orltc3tv&v?*Eu$
z_hL+W&MEtiH&q!ifuaw*sS1>F2i{LOxKeW`fS3G+TcVU0BgIW9aZP%C(08NeN&v^b
zwei-zUP_JvRAk@{qQKWhzd<9?t8oDD7+f34Jw^~W`(@K|7~oqp@C)$zINTu|G9%$1
dR;W;aN^jiq!-}+{oxT77002ovPDHLkV1iZ!$mRe5

literal 0
HcmV?d00001

diff --git a/res/drawable-mdpi/ic_grabber.png b/res/drawable-mdpi/ic_grabber.png
new file mode 100644
index 0000000000000000000000000000000000000000..d5f2c16cbbab9c7300145c972d17cc5ee22fa686
GIT binary patch
literal 286
zcmV+(0pb3MP)<h;3K|Lk000e1NJLTq001Tc001Tk1^@s6s6FYf0002xNkl<Zc-rli
zO%8%E5Jr0}jX!bc&aHX@H!i(^t4`GzBhr>LcshXt=u9`L0XC$i(Rs<Yf%5S(p+yLW
zVVJ-qaw4o8#U*7>N<%3O6hf<UJd+|R4Nn)6>wR+O_$gJTbW`+(hBf9|8>5m2sW&;d
zrv7=WRvjh+_m&rT3w8gVSgNL2u<;V=X2Kl@hXsBQdoQ7G-j%_`teRuV&P%A93C0a(
zco1&Agt~cG1{2e;#Ic_na>4sW%gb}Ors;X=_C|IZI)OSVy4NeI{F0NoyA}nN+ynoC
kgSd_sl8a7?VVFPQ1tg1HW}FBJ)c^nh07*qoM6N<$f~^L3)c^nh

literal 0
HcmV?d00001

diff --git a/res/drawable-mdpi/ic_settings_reset_button.png b/res/drawable-mdpi/ic_settings_reset_button.png
new file mode 100644
index 0000000000000000000000000000000000000000..b36f30efd7a6744f37bc7788ae034bf84b4dd12f
GIT binary patch
literal 333
zcmV-T0kZyyP)<h;3K|Lk000e1NJLTq000;O000;W1^@s6;CDUv0003LNkl<Zc-rli
zF%E)25Jj<qhUg(IAkjNWg*JK}w2`wwqBjA(1C&Z{CDr;#KFNmQx(l&ml9!Oo-@h<B
z%v#nIV?qcq10hI332IV+1ne5kP;(FD;&<GDZ)zTZ7Y!aD0xRH<=K08+pf=Do_a*ZS
za1~mYnsyUkr{=k2KGQs>c9UGW2Fa~d7T2Jpu2im2B}^%b1~kQyYZH~Iq-fQXJAjJp
zd-7|pEmRxS6xltwN@~rjC+{%#?k3KP9*;+Fz+|j4r)EE@M4c~*|8>acf#yw{K7Y39
zh=JJtXqnOQgLt7aDz4I~@J!6-;Lbxm@eplx%bGQRO6D8WPhV<|>&)oQzg##8FPZLz
f6Ar#`rfA~>+G2&Hy#gji00000NkvXXu0mjfgf)^{

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_action_set.png b/res/drawable-xhdpi/ic_action_set.png
new file mode 100644
index 0000000000000000000000000000000000000000..0e7ffdbc6ee1f62e82fb6e0223edf0c78be0bb22
GIT binary patch
literal 785
zcmV+s1Md8ZP)<h;3K|Lk000e1NJLTq002M$002M;1^@s6s%dfF0008mNkl<Zc-rlm
z*=rO*5XSpWeDI2>MDW%q9*D+UhzJ2u5ETRkLI0INoSB|APIR1}-4*eF@KN6s9}K8S
z6oL@(h<D<BM@7HsO^oc+;KAz5^wbAUV0XjLuj;Gn>RusOEEbE!VzF2(7K_Eozq+kv
z;rru?2_HK1g>r6VofV!pzF6>n=K=)aF5tiE707eN3Brlad4Rt61AcUc&KdLJPabUn
z>_7}&Id6rswi;gZ?qYyGB;mu-7PH~2_7Yf}f`5(rZ!;S{kjnu2h=6}3l-y)CeA!wK
z$R{LxU~e?s_HqS4pT^<k3;bPc_&)Ef0^|^p`RAhIt}(pkt<|viGXj1Hjj+}9@wQcj
zG7cZgK~a$_4R3hvx{>;>&-|e9O^2`A>jC<bfPbvFLBl7!4X}P3J^*~BYiUZ2sB6xD
znXt<C=7h{YNH6ncXYR;3`#mz#{tqX-Hhjk$0{%XBftIx4M<3<`I`H;}e@}FBqu~cc
zrL-u$dQ{GN;-Nl@vfS3Vn#ajaIq%5KpYj%_+mMdS*~oZ583ZMFHejD`Pk_IpFFG<I
zb$AwPu%Ebb`GjF)*Wcgdz(rACiNoL0rI)R1CwC^cp_|0R4&(Jbf1Y{tkr4faf{$F6
z&Edpq#sl_|K~V1A-|zON9kmjw-{&Kj!EM=|&=Q028EfCK%L#phgonE#m*rzdKQbNm
zy-o%pko%KuZ|~N9BmRGVI<WaVs2~W648j+z1997<Pv}yKeg202H7B2!6!tWL^%6%_
z1VJ7gvpxC)1s}O63S_=7E9|L&xk_aAD=dFV_k~)2sDHm#oJIi6xUK>S6@;1-hKYuE
zO&qgkn018pI+_4?naFhg1?Cluw@qfA<GVX11M*TLe24&froxZS_EYE}AoEebD1@qV
z5(07Yr=O~Ov^xqV*PVbMTtL=)bU+Fz-=C<PBa6jiu~;k?i^XEGSeepyG83vqW9qw#
P00000NkvXXu0mjfA2Wg<

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_grabber.png b/res/drawable-xhdpi/ic_grabber.png
new file mode 100644
index 0000000000000000000000000000000000000000..418fcdc19de713a7800c3978c416a20d733fa9cc
GIT binary patch
literal 431
zcmeAS@N?(olHy`uVBq!ia0vp^J|N7&1|*M957cI0U@Y@=aSW-r^>&uM-(dp@_gcn(
zos66ZnS{A}a%3N}++pX8vQApymF&$?C@m1OK#8p{K<^@Bj&P|{?_7^1dG{vQMaR@v
z7R^~du@z`07&K_*>6_OoG$d`%{qi6-<EL8B9Vd?&Yu+1qbWdpA(po)j+GP8bse$X?
zWM0+oo_ft8OtN~d^ySz{EvIW*9+$8G{$^;|(RZ%z)yY}ukLnknyYu~Kob@KRS9=cf
zZlAmPzj)dc*G-3F-f}og9J10|Q?Jt_^}Eez>5f^kZ-KUNu!)xrIlpgNI_I}U<9O>{
z?YVY`1ll&N@ISM>?9<A#;Yl-p-C|^5NXR^KwX@c>zQd_bO*DM-&di6xroGxAl~Y;^
zC6=-s{?{jwy8GhE^?YyT9~3rA*L`%K{_4!zEWb(CTNSrd^-WJbzGLHDmAI(()U(nL
zYVLNgxVJ+7?^cDn{<*VTwcmCoKVPW5c7yh7#c1b%4wDpD59hEa^N!79g@%y80shTz
VS`Hf6=>GwUc)I$ztaD0e0s!N>xWoVe

literal 0
HcmV?d00001

diff --git a/res/drawable-xhdpi/ic_settings_reset_button.png b/res/drawable-xhdpi/ic_settings_reset_button.png
new file mode 100644
index 0000000000000000000000000000000000000000..399b819d2df86d8f3a235ac5ac1903f0465739f7
GIT binary patch
literal 680
zcmV;Z0$2TsP)<h;3K|Lk000e1NJLTq001xm001xu1^@s6R|5Hm0007SNkl<Zc-rk*
zJx?1!5JhqzvE-BvP8Yy7J&+Da6C(ZrxS)4jTP`jCg47U$Xn+bzpd^V%qy*V?z<)48
zvXdf?z?V1D6lk<(-Q9lp65U8oI_=%OomtP$?2gCA5=kVHME(o$JZ}c500%%D=m332
zhsXAT_w;RCj7|Y-z&9_P41lk|2JmE5#;*W3p1u&rs!PM40b8DVA<ndI<6i(5J_bAh
zXFwHL1aiOxBgbR(?h}WQN`3%Yo5rg`<{tPMW@F;pJkVraRY+w`8=v-B`72;fgLfXd
z_W32!CLL%hCOHN&2Dmf8iE2-n%r;VJ!f}HOG|memWyM6Ezfpuu#=;)UDCVN@O6ic6
z6dQKVVwRg%Z0wQ_p{%e?2X#j7w{xAd%|PV&83zvJ6?I}d3Q<LnoH?xapT*qeC?p4h
zq#8oE2pj=D20a%;=-0&D`%xTd3zEeU#@{JYB8?RSax4kmRul(r1<7PUy`v!qw!?rN
zIic5y;y_=JOa#>H4RN3wkmIS)`#tRAy2cT>q2TK}b$}HbCX63x2!(W_5z9>+(1}I>
zo&v2lhf|lI3mR#3FU;nx>lh!4LgwRyE8`2|C_&FtQHbiUjpuo{jU474IpNay1*6Al
z$9<;fK9{G|zhJzbE2YDgKUEmN>0<I_;I(GVt9nh}sRL-+_&2~WzNzg3vmtL?JFM#|
zF7jF1##5>PspvR=;VMe+CposMwfK_9YFwn;w-$v1A1pL?H?4<_aN-@OIb9)+x1-7+
z)c9JbY8l}Vj&s&c#U&lS;!egMaLHHFKac)mYVo^rq_a&Ti6oLpEafjXXMfzsCr#P_
O0000<MNUMnLSTY;ellbL

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_action_set.png b/res/drawable-xxhdpi/ic_action_set.png
new file mode 100644
index 0000000000000000000000000000000000000000..d7cd23b8c872a0f626541539360d75cd41d66621
GIT binary patch
literal 1390
zcmV-!1(EuRP)<h;3K|Lk000e1NJLTq003YB003YJ1^@s6;+S_h000FwNkl<Zc-rlo
z%Zpq^6vj^yqcM(ABhkcH@P&ekF5C!i{1e28C@6^HLU9rC1qsrc>8k4P&@<k9>vlTx
zB8du4;>M^8@v%?@H6V&8ZbTOff>EQ+WSpL!_Eg;-jl-lWW2&F?{h*kJf$qNFIrY^!
z=iVj)000000000000000000000002!Dkkq<L)Gefezgi>bb^Y!leDbxx&~sj8?7Fo
zL>y)D>-_pt(#6dXr5)sQXRzq^^7@5W<Aim@?u14IcGOa0bswej`$gh6nmgfb+Oz9g
zh}0@l7C#ZcE+PKEK}h6b2o;+5*>)0fKWDg0{CO7tYl_s(5G;7+7anARe{hIz)>owS
zckmgp8iIvm72D2Zq{T6}_~JW08*YO5A*oi^vak=az{i}nqve-W$=?XULT7#=ALeT3
zM^EN|PI~Zml%8Sh{M9V%lb*~s>l=#2^$<U-_-C@PkMjD%S!!za86V8oL9o!7pO^zz
z{^ZI0BV3Z+hRhFcJL*|a=9~2eMa8Qjen_I|EEaY<uRq<kBR}Co`6>t&lF7+6Y$s2!
zxIa5HKM@~OT)34QnEQto|9KX8$|-)znV;<5O1S9~+IDQIIprCweaLnG<q#}rhx^D{
z&gy3<RYyGs?gymvw;=OFi?2n2#hvzu{}GK8E`#_XDVNV?VRvx3Iqj}?#Cud7+5*8s
zcettA$pZi8&V2O_H)A(Iu<+xB-Mo%_25UW<`L>)J+}eCTrpr7(w?4BSr{~XE@#DfJ
zy_sRLyvxqSO_uF1ozpenYa+Lf>-=3@@%-*NaNp|P!J3x$G@p$z7c$Fhf^=@6^Wsme
z<L{z*&A2;U`6g9L7xkv?XtC`C@fR+r#(!g~s`EOR6r2F5%6r6T+mUb3c(kcUGrzEn
zD~4}R(z+kFK~NnCg7N%R7CAY5<AuYtr`W^K?`W~tv$bn{k^5<^aBf>|Csiqb?q6Qp
z85f(Vrx_YLpY7*mzMz`pVrxx7E@=7pF@e^q)I5hyZab+wM5E=6{ZU_=A(fUddA2%d
zquSfjAQ;cj>ij8BlXZ~d(v|(y<d~hH)u^Y;<IGd9QMm<~XER?O@MOMO`}!yI7ZXJr
z*p9}V6_BIq;6Nqf!f*#JAM%NaJfCa+_exuAu(Qn=cae!4<4m7-h%p;12qx&J((;WL
z%sKU<x?*L_T%z0t?uuhi5aw(Ncsk9G$$XR5?#wr9%v$7%!UQ3aBOXt#bC3@FuTs!h
zN!H=koF%a7$UE5#cD6byZf^c=s_yn?4#IH$;!}R#a&DvTKN3fspY6V}-W{w33xXbC
zp^Ba$)a@W_WY`~sQ6oNAQrQT>C4OvoA^4|0k3F4f-TL{6V<(tHTZ>Vr_{Q>#^+Ei_
zX9D|tR;|<>nQKbaSE(|1>C)ocKEr*cBqCjwovpZ?kVxURqeQ+-k-ZVVP->dsz3$2U
zdNzF10}$FbrOd_!GoIgA9inP}i`_Y9nCIL%Y;CDXy5jyrPhds?S`PaUW_6I)KF^?U
zp2bgXpulqNNImDZ6|Lr+&766pu+YX)cmLUuDl~80G?uw$td*Jf0H=ZNXociJ%q~Ox
znw|Og?Nqbfm?zZ|`P3<lk{537>_q0bCJ4&&+>WuGGL^dMk(a(g+3DsBOLxr1qLj3A
zAkae0LsY4H{J-;kEB@1Vmw<MRE$nZ#c4WWRQqx@L=c&9M;<vp|NV!i)`CM4B^ZahG
wBUC#800000000000000000000000QV-}zGe<Npc+(*OVf07*qoM6N<$f>%Appa1{>

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_grabber.png b/res/drawable-xxhdpi/ic_grabber.png
new file mode 100644
index 0000000000000000000000000000000000000000..64f2f0c0ac263376ed7f5444e842063aebf56c87
GIT binary patch
literal 895
zcmeAS@N?(olHy`uVBq!ia0vp^MIg+<1|<9Mw$?H*FuQrWIEGZ*dVBZ0pKzea@sHB~
zS*~;h3jbfQui;qv2SyXUFOmhVokym22K_rbw=3lGy_r#qGfS2pQ9rO&JNAWB{NWc&
zD?}DQzq821!MBm|nc02+A~Tk@*`JgB-ffwCPy%QX61b*0mG7t1fqB#YW~gjBcJsuN
zZx+0qfoltHsC=6k;_MVN#i9FOHiyoUtilkdm}$TE2Ki1t_FZDLV{dT1+P3x^V#|6Z
zH!JpD{;IgG%W!t_*Q)(2rnesY+<9;&<;=74@>w^Q>N)+1_I{J*EWP}{>}JDcGj&C=
zT{6q(X5Ex;Hu&Dr?dNqi$N0!qgRc=)K5rJie5riwsByH^^10sqp`VVs&31a&kbi1*
z&uTIG?B2^2mWKtRpT1dtZN}956Tj}-Dt>G7f*0HDI`ce(Uj^wK>!#oLGBxHeG(EHI
zzij0C=<12L7H-h1)H>>DnQZqqVzaYuy8Y}|Pj(hG>4={{eQ3YHy<H0XXQg~%auia5
zpofAgj?bJ*e@%&TKX>xc{=m1Q=Vz)1FL$mAO`l&W6>FlmORIaon`fqeOwGyfpcrFl
zm=_}VZgThi*J>NThufL>Wa@8GzcoAI%Cd8(4%vVB_3Boa-K<kD5**T1^k;p3#}2p2
zQ7Gk|D*yQti|(I(B))Q+*HZQVr<Zi*ygsq8d0Eo>AN?nON3(0(?_TxArJ5OJkAwfE
z{-fcKPA^N!pRuH3@}x^~8U9VXQV-leBK+Fd=Dx4c-vwK?h<}TXF#q^rk>&e30jQ5a
z7Cw{jH+VhKea6e?&tGH<)3b|szv?`$dOY8AUor3X<o)Mr?%v{ldom~EeBk`Kck^Gh
z{;U6gNn^E^IGc~^uH7e}PcQ#Jr`Yye_oItvuCLvDVcvpXGu4fcgSaKzb|l1@JnZki
zdnaHjd(DiMe|NqWh(0dyo&U~Jxw$hlZ8ohn_?jMTa%kp^c7s@xZAT5Q_3Js3TV~8Q
z)RtagGH=4IBWx$?-|x78Lm_>-jg``F>CL=9@7@06y>!FzH+u>{GT+qsdU3;_{+k>5
z($fyNpRnM4W%c>oECXqw4+iN;H<G6nO8uGP`$lE=<+z(?H(9fSf(Z_Cp76i6I(oY&
R(Z(Jm=IQF^vd$@?2>^pbsYw6;

literal 0
HcmV?d00001

diff --git a/res/drawable-xxhdpi/ic_settings_reset_button.png b/res/drawable-xxhdpi/ic_settings_reset_button.png
new file mode 100644
index 0000000000000000000000000000000000000000..7260911ce677037619cd01f6acb1b33ea48e53cc
GIT binary patch
literal 1245
zcmV<31S0#1P)<h;3K|Lk000e1NJLTq002k;002k`1^@s6RqeA!000D}Nkl<Zc-rk-
zOHUL*5C#Ja@>B$rt8&1LJiH2$fd4=ukG&Y=sE8Mppkj>i!b1^F{0VBj;lc$H!5{~?
zfEOP~V&VZ}A}F{>*d42qk7To%p4nx3W_n0h@+F(ePE}2HS9eu)bw-9JO`0@m(xgd~
zCQW{mVHi1t6ND;4m@r6~AbcUL5w?LfJe$CO!gz<@%{gdB$s|+|S_n@GbA&%e`t+Od
zfiMDI%ri6S#>pjIB`gv)40*)7J`#Efc|kNxF`<pHVz^H$kaZ*ohB-uNAiN}O8s5<s
z;SHglbx_qfS%k}k?}mTGvbzY`su`yM>%qSiK7x0tAB1_r5Zt4hP(}y=Wq8(x|1990
z?G*U44!2k*RgA;C$uq*PjpBa^V}x!(Z91b2qt)WwG4QgYUFcMy!pvbsb}W>Q5#ABb
z6H1({5m@7xM<aN~Eab9I&wZOoJOkiXqL~v%z}M%7k{FyjkP)|-Nw+;;lQ5E97HbZV
z>@=at16`URD`v4KUGa2x!&Yv!Td~5YyohuWsk5vZo87I!%OLQT&CDtC!R3o!B+*P_
zor}Ftq*ahh#i3xOkDJCx43OEH#DQz87rE6p!3eEkJ;?OYK<sYK(8Y{c_gpuH->`74
zK7|6;yB4l?-IYN^K)5In$}vg4Vv+r{K-VQ#0!Y+g%t{tf4%`&X4I2d!H-E!LH!6W6
zf)U}+|EPinDuHfhG%B?+iBjjBAo0AWVu=C4Y_}l6o#k(mDXa=5&t&2ZyGG&qR4sHg
zbF(U$g2IBSI`1^kq4!G(9fT<;zJcHTtW?6%uprPqEYm=P0wF^ZMtEEh*zvOn|Hq+>
zVS(-gG7U5#5Ypyw=8W5vEMoXisRKFf0^Z{?4fI(c<ctHJ9TsJZWFxgZkW(Yz`$?vO
zM4@|`1D;c9)S4$9$SD`_T$O1cQ7t&f0nc>K$<`g_k7g82l|e6#P24z&>9>%(o(8X9
zei|sBKSc6578~cjRelyI7fUdbEb6yQUIV#E<HNSxax0T<K9a&VA8~1$kL-t;6L+(9
zD~mueW?>wsf#PGSfuaL<>o@jM6G})mCKFPPNsPRksYZv>tv%J5l(Jj-kgV3ZmaKB$
z4G!iu?Tn*RHPO>@2i&b!wp)2vFncS|n~Q%TnZlBTNoCzCspJ|JxL1p8Vfi>I*i_lA
zl8W{-UKj22U>K#116}WVe(Vzj!r9#gUk(lfVjzEyo)tGvu@cP-in>)L;k`}!OTCK9
zXL}%{*=FW&pxCM0*&Qi#nDBz|fKccH|3d7jb}e`}Rcs69xakqv-{QDq!L2dJBsOu*
z*wmAD&|q4insK<q`OqYXi{kjGhj2EXdN#81x`a01Xdv2v1s^hM)9}65NX})5C+JwK
zM%g0^JjzikYDYaMoksF)r5eeT48(5q)#s}Soyx5_No&M8!fTH&v;0AvqwZxElc4Pq
zVc7%YEJIfCf<P?TJ;<PCU#MF`;u-whiaz3a!j;U~eY)SqfxD7vVyF<h)lOsg8phVo
z%@IElyYMcw%I8)%)fhlgfA3OnC_|GbO`0@m(xgd~Cco)F_SYe^mDZiH00000NkvXX
Hu0mjfw75#p

literal 0
HcmV?d00001

diff --git a/res/drawable-xxxhdpi/ic_action_set.png b/res/drawable-xxxhdpi/ic_action_set.png
new file mode 100644
index 0000000000000000000000000000000000000000..93a7b00ec0fa9836a241b12aca79d47e4835b7b6
GIT binary patch
literal 1342
zcmZ`(|2xwO9Orz5xgFtQmxLOlRZ~y;?#q}oX(Ve_7|D?*lGTlT8DrNR%a^s1VqF)p
zn94al!dflI*3{KGvD}#XGGDft!m=-yKcM&Xyk74g-mmBNdj0e+4#xz8K^s6uMn+)t
z5mdz2oxcY2bzk|VZ@kdR$kY^#LPll|&)>n9+66)Kg{%Gx-Smp_zCx5~5WQzL2c^o4
z-u)%SE@xr-5e6sX;Cn+!WxwA$p1}7$4Cb3ibB&9WIs>J=!jMiJ9*A#dZ!@;Lp&=zD
zJ$T4P$mhi8-xzdQg8>(I%JXaJw<mdXu_BzQUI6aV&Q9)N&KTbYB<zqu=ywrK%nO~`
z=0Oq^d2xaPyc$}%JcyB9I7W#Ka}Rf|tX9PIN-~;VEhvnZsl6U#)vgxnKdd2;4<gX~
z`o6GF4^rag9u$XPwAJS)X2Z&zf7PM}scOHIZHg@xvHum{8%YIo3EQ|f&PY{2IZJL<
zr1lHQ^MVr)HUdJT?W8rufuiLfg3d0DGgFY4ym&&c)(30v=NhenubD+6>;+`pfCvd7
z%ry&)0FAOCWOwc8M9r041iTdo^?TpKRwyp6T_-&khJ4i~cO!=W;>g@ywCZkReTG@1
zR2RR2qf~G5es$pJSTX^=m~~5=d22>KR5nU=HJHY~Z09Q><;0JmeyIc1+pvGYasJp^
z)tQ?`-Uhtvs{aP3xWsPvjh}0gdHd7^2LXAQW#!+GkMw;D$_-qJR9+kqKQrT52I_CW
zs5U^<h5Ka1J>tLTw~sX}d#D2|STpTZxS>KSu#)E|M1fhcbIzs?mHdzKCMqiXMwv)Q
z%6c>vF7D#O#7pC^4YFrd;}zY++i^LKDa#vgN>JCVS|ww-V}h^}I9VwC{!ebVU_!io
zW_eQ@PH*<&IKopc;AYcCbDG&Twi#}I@0~#txN^TwpXuNk{*qxwOt3gx7y5J_vF(ZW
zhze-xk`PZIoD!6aMEuJndplfrSbmh{LD>L14Rd$$Dic^NI{j02my}O`n0B7&mI0Ht
zhf%~uXjNAS!uQ;3rI_BB7R?-4%_&kob$*J4^g8$Kw)mJi(-S%56HME5z+#fdaM=lK
z&zqRF)n#tYendP-aXeuCuKh!Psy(nAjD^>{>!_CO=atnxAt?I;o04H(drKI1Q!uH>
z49utThB>o4#PtU{dsOa@&yP{!TCn(Yg6RP*2Yp7vX(?D=KJ7?Ft4f@N_16L}?8-{l
zUhicUKA)TeS`*Q6d2Qqe-gy0nf)!DBSwX!5aFRkBm~S>N7%nH&A0(Fdl601(0$OHQ
z*B;PWZGGiR(-^GA2{BSNv|<p;R_!68n&;6l45jH%jPI2Aal}^1XZYJnXq8(iMKX^`
z|9PC)?F1W%@?=N~s{Y+%FS2vzvDj=xa=88!Z%RLY)V8$mQaT;1Uw7Q*ew`($HnPq$
zK;xK;rtG}WPBLeVBCzirbOxf}gziTQDv#X~<bV3Q39*g&IQBY#mP=FXOU@N0nbCzL
zH}m1fouw^L&U^_%m&=c8@dcs!b%ZM}w2Zjy?{tiYG2v@4(9va8!m(BW^w`<l#)4=l
zFLCMAAWEY<sb>Ova6U-QJ9jrESAumZL&x>EtG^s}A=j|0g%)Qy!Tgm&aCKRHAE^!i
zMg3r-+Y2V7Z#k30A$$DOD<D~zxMIvE@5DfnETyB1tk$3PTjffU%%KD3QKM%;rx!(=
u?P%4$sVWFW^J=@<guL|1xBrfjQ8+|zT5K#Y$!c@*TGOF}Fepwy9OZvi<c%``

literal 0
HcmV?d00001

diff --git a/res/drawable-xxxhdpi/ic_grabber.png b/res/drawable-xxxhdpi/ic_grabber.png
new file mode 100644
index 0000000000000000000000000000000000000000..ba7706f26da537decda19dd2a13740dcd1a6103b
GIT binary patch
literal 690
zcmeAS@N?(olHy`uVBq!ia0vp^GeDSw4M<8HQcz@IV5;<VaSW-r_4dxjED=YU0}m_t
zw{E|vwqV5slPFg~>9;kl6UsYw7x%W_+`Aw{T;P+6W{ud_NiiK$&*^c7-{>eePM`C>
zxqkNPbAN6;{?^9L2s9W4G}PbOa+53e&K7}`4(+`5eS1BM<(9oo=634aQ5V;D;)K}r
z6DQ<Q@ek+2#_RUk{_ftf?%9=Mqp;fNMe2(qV!BW4Iw{QUT@{@(Z=J=u)jK5)yT(X9
z5}LVV)A6kxITgBEmyV||%&r&d@J@N8WpX&XYt0k&?dIjj`#-BL?_Ym8?R@v~tuuc9
zu%EK;-QSAkn|6Eb-hIq>UCARq-$vP+A08E}7$_Swa{45=C78t|FbU5%&~t!A4Jh*F
zKi8Ydy!!uC{wLcu%D%blA^z8_<ZX3uLfclkYcdeeHmH`o?Y^-6{@enMvPqAkUp)F;
z#WdS&es0x6$!mM0_++dKG=L_Z;qU<)%#sE+*e9Wsr7Yuc_xVKEcu~{ums#bP|4iyS
zQ)n^c&SzOwh`|Spe(jB3*e|cw|8~Zk$=80}eUj$d_*1gjK6#$G0Xv_pg~*HpaO0Sa
zLCyx5E!n6md1D>O(e=yMy;uG|`*z~3JdwHkYNtM{>6NzSkFAOPv#WjUvWOe~m)z#B
zQCv6q<5t1QX*+)XxNzut%8d_36VDzAEl)8nER<EA-MX$ap^-D0V|A}jOiK5g*FQ2C
z>iTu^mN}f8*73UJkMx9xe$URiZaZ-VD^|OlcDh&(B~1W14cQOGuWDU-_a}KiD@e}M
L)z4*}Q$iB}hHx`i

literal 0
HcmV?d00001

diff --git a/res/drawable-xxxhdpi/ic_settings_reset_button.png b/res/drawable-xxxhdpi/ic_settings_reset_button.png
new file mode 100644
index 0000000000000000000000000000000000000000..658ee47a1cb2af6ece4daa06eb678b29292e3907
GIT binary patch
literal 1512
zcmV<E1sD2>P)<h;3K|Lk000e1NJLTq003YB003YJ1^@s6;+S_h000HANkl<Zc-rk<
zTW?iG6g~+Q3M~qyD6v4PKq3&q6nGM?A^ZSPO9;XPX(2&Oid;NF0_;Q{3Mp-Y_yc^G
zg7m>ie*jIDTg&YQ4L41wR%qoWmvODINKP8tS^F}xXU|z*@+D1AyXTv=X3u5KnmM_g
zKp+qZ1OkCTAP@)y0)ar_0F+W=fXjdlz(c^3z+T{W-~jLmae#i;OMi2a{%0vZLo6B2
z=re%ZfSthmDn9N3PXU{NRbt`)H~IwN24ENPxiW`mz|+9>z)~^1QsvY#?<o7Y3k-m-
z7o*`zfV+Tysq}#wcA%zWG5!a@KII;+0ayBL_)_4vz!%D0pthsH@xB><Hn3Y|2WNqE
zeKG#ZnA6Fpz%#%WU?X*5HNYt}mXy%XHS}2{{cSh>Z=C7timV%d4K0+y;xX_za5ZpJ
zjPhRtehlo0p`$*l#@`%aPLET=uYnZ?^h^crp)$e%>#!+{EkBI$hiF<l(So)zV4lhh
z<AnMw_4#35_wO<Mkb=&c)HQ|aj#jvC{COb;+=n<|I?`1>3^6dzae1D9j#-hLz(o#e
zUktp()c%W;>jYY4ac~)5e+Tu?0$yd-;izlk>zFHCG=8PSU1%lK30T+Vu81BByvPuJ
z8(5u@{fHZk`t&&wz@zCSXTV*Q%LqX0d%#DGdVT3aJpWII(8gTG0GhWj>V<VLPgCSq
zoOynRLn$X2_1lr=wDWh3xWO#%!_s0+w_^SSw^Y**w}H_*c6kuZ-OZ@yXK4uQV)Tz?
z9yp+k5y1P=wx}w~Fc=NHbDjX|vX>F8tFkF*8zXR4;gJI>83D#GYzpf1b><UeM$}<*
z<$F&fW|fBy_*7Hp0V`>cl&h)R!<}TX{Dr_a;3eQcMEtoGxWHh!lNsaQ5*rR^(1<u=
zsN8YDV;UpiXGcuMXyCa$n!0ba;ebOL5iN#{-=+9CZNdrkmW_sH8xHtEBcj1Tna3hz
zG_)Jgu}M?r2^$X3g`Sri=<}aNZ~%@)^Apzcp{C69HXQJqMnrYO<+a5~t~#8smKsfY
zzuItsF8n+-;qorWa6q4d1=(omx8VTYif~-Q<qgGfz+l2!#_J*gQ68F4F$s1*L*HPG
z=ihhU0rcP?1>*-yZI_Co3$pBlAcU^g80EBNY7n;Mgdn7*1u>?f?<DMiI^)w&!%hey
zYC003tX2aPkj+*iqK2Fh#L!bh;RP;!G8Br?tx1}bEG%%r_`{sgt~vGcl*SBG!MLBT
z2ICTPLXfZ~91{*xX4(+3kB%kH&lv(U99?Uo;J_8*r@SFkpW22@#KqeFoJU|pfjdkK
z2#T@g7c9X3)zo>b4I%krYxz{~eVRJs*f8Cen0%2L9}~0sT}#XgeD8J&>bi&V)~`!L
zSl;KBPj#F{Sr_gl=N7yPUbcLy-zi4x-<}f~G5%KP4`_I7{94Ly)uBnOmAvt1&^hL8
z9Mbd5_|w$Oo3l8_RNohiC2RcIOye6#`jS4Me{*9`(wQG=R=nH+4WBayT*TkFFYJr)
z-vnO4Wjro;QYgQgInRFuJh=UlFUEgkSh~pr;5R1E6%@X86kd1`!uS|$`@|RHV`#T`
zgo@%Nss~I&7OC95%#;1Yjo;{t@$ufa3(S-f>>k#}IqXN<i1oCY67|wPZ(4qZ;$P@A
zyajgC8G((IB98qxUR61U4sYPI-^M<gQb*co13gMUQQ?5=N1sm)_)cX9J>JZA3LH>M
zDI>05UEJ=?Jbwg7)G0SF@4iqp;RQNt+{D=Gvw?onGPW2)0Jz_}lXjJC1FzcIt~|I<
zBne00OlA$`f13UZ6I^+(Q}PuiBRb<Pno4%YJf2jTv37!XxTcGR!#M-z`R}Tir}Nv$
zkmqT`WPlcIPiO^woj$|sh?{B6P^;u?tONpqKp+qZ1OkCTAP@)yj^IBB2TX#RcWCDT
O0000<MNUMnLSTZfW7zuu

literal 0
HcmV?d00001

diff --git a/res/drawable/ic_settings_navigation.xml b/res/drawable/ic_settings_navigation.xml
new file mode 100644
index 0000000..14e9294
--- /dev/null
+++ b/res/drawable/ic_settings_navigation.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+    Copyright (c) 2015 SlimRoms
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+
+    <path
+        android:fillColor="?android:attr/colorAccent"
+        android:pathData="M5.9988 0.49493c-2.7857-0.06811-5.3371 2.294-5.484 5.0764-0.28157 2.775 1.8799
+5.5017 4.6455 5.8607 2.7005 0.478 5.5397-1.391 6.1657-4.0612
+0.743-2.6427-0.836-5.6553-3.4346-6.5426-0.6047-0.22147-1.2487-0.3337-1.8926-0.33327zm12
+0c-2.786-0.06811-5.337 2.294-5.484 5.0764-0.282 2.775 1.88 5.5017 4.645 5.8607
+2.701 0.478 5.54-1.391 6.166-4.0612
+0.743-2.6427-0.836-5.6553-3.435-6.5426-0.604-0.22147-1.248-0.3337-1.892-0.33327zm-12
+1.1001c2.5155-0.0739 4.7082 2.3534 4.3772 4.8491-0.185 2.506-2.8145
+4.4409-5.2627 3.8609-2.472-0.4366-4.1352-3.2391-3.3162-5.6168 0.5398-1.8027
+2.3167-3.1197 4.2017-3.0932zm12 0c2.515-0.0739 4.708 2.3534 4.377 4.8491-0.185
+2.506-2.814 4.4409-5.263 3.8609-2.472-0.4366-4.135-3.2391-3.316-5.6168
+0.54-1.8027 2.317-3.1197 4.202-3.0932zm-0.688 1.1343v3.7813h-2.062c0.916 0.9166
+1.833 1.8333 2.75 2.75 0.916-0.9167 1.833-1.8334
+2.75-2.75h-2.063v-3.7813h-1.375zm-10.797
+0.5156v2.0625h-3.7813v1.375h3.7813v2.0625c0.9167-0.9166 1.8333-1.8333
+2.75-2.75-0.9167-0.9166-1.8333-1.8333-2.75-2.75zm-0.5156
+9.2501c-2.7857-0.068-5.3371 2.294-5.484 5.076-0.28157 2.775 1.8799 5.502 4.6455
+5.861 2.7005 0.478 5.5397-1.391 6.1657-4.061
+0.743-2.643-0.836-5.655-3.4346-6.543-0.6047-0.221-1.2487-0.333-1.8926-0.333zm12
+0c-2.786-0.068-5.337 2.294-5.484 5.076-0.282 2.775 1.88 5.502 4.645 5.861 2.701
+0.478 5.54-1.391 6.166-4.061
+0.743-2.643-0.836-5.655-3.435-6.543-0.604-0.221-1.248-0.333-1.892-0.333zm-12
+1.1c2.5155-0.074 4.7082 2.353 4.3772 4.849-0.185 2.506-2.8145 4.441-5.2627
+3.861-2.472-0.437-4.1352-3.239-3.3162-5.617 0.5398-1.802 2.3167-3.12
+4.2017-3.093zm12 0c2.515-0.074 4.708 2.353 4.377 4.849-0.185 2.506-2.814
+4.441-5.263 3.861-2.472-0.437-4.135-3.239-3.316-5.617 0.54-1.802 2.317-3.12
+4.202-3.093zm-12 1.134c-0.9167 0.917-1.8334 1.834-2.75
+2.75h2.0625v3.782h1.375v-3.782h2.0625c-0.9167-0.916-1.8334-1.833-2.75-2.75zm11.484
+0.516l-2.75 2.75 2.75 2.75v-2.063h3.781v-1.375h-3.781v-2.062z" />
+</vector>
\ No newline at end of file
diff --git a/res/layout/action_list_view_item.xml b/res/layout/action_list_view_item.xml
new file mode 100644
index 0000000..40732e1
--- /dev/null
+++ b/res/layout/action_list_view_item.xml
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 Slimroms
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<GridLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:minHeight="?android:attr/listPreferredItemHeight"
+    android:paddingStart="?android:attr/listPreferredItemPaddingStart"
+    android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
+    android:paddingTop="8dip"
+    android:paddingBottom="8dip" >
+    <ImageView
+        android:id="@id/drag_handle"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:background="@drawable/ic_grabber"
+        android:layout_marginEnd="8dip"
+        android:layout_gravity="center_vertical"
+        android:scaleType="centerInside"
+        android:contentDescription="@null" />
+    <LinearLayout
+        android:layout_width="0dip"
+        android:layout_height="wrap_content"
+        android:layout_gravity="fill_horizontal|center_vertical"
+        android:orientation="vertical"
+        android:paddingRight="5dp">
+        <TextView
+            android:id="@+id/click_action_description"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="fill_horizontal"
+            android:singleLine="true"
+            android:ellipsize="marquee"
+            android:textAppearance="?android:attr/textAppearanceMedium"
+            android:textAlignment="viewStart" />
+        <TextView
+            android:id="@+id/longpress_action_description"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="fill_horizontal"
+            android:layout_marginTop="2dip"
+            android:singleLine="true"
+            android:ellipsize="marquee"
+            android:textAppearance="?android:attr/textAppearanceSmall"
+            android:textAlignment="viewStart" />
+    </LinearLayout>
+    <ImageView
+        android:id="@+id/icon"
+        android:layout_width="30dip"
+        android:layout_height="30dip"
+        android:layout_marginEnd="8dip"
+        android:layout_gravity="center_vertical"
+        android:scaleType="centerInside"
+        android:contentDescription="@null" />
+</GridLayout>
diff --git a/res/layout/action_list_view_main.xml b/res/layout/action_list_view_main.xml
new file mode 100644
index 0000000..cbc6779
--- /dev/null
+++ b/res/layout/action_list_view_main.xml
@@ -0,0 +1,67 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2014 Slimroms
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:settings="http://schemas.android.com/apk/res/com.android.settings"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+    <LinearLayout
+        android:id="@+id/fragment_container"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content" >
+    </LinearLayout>
+    <View
+        android:id="@+id/divider"
+        android:layout_width="match_parent"
+        android:layout_height="1dp"
+        android:visibility="gone"
+        android:background="@android:color/darker_gray"/>
+    <TextView
+        android:id="@+id/disable_message"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="20dip"
+        android:layout_gravity="center"
+        android:gravity="center_horizontal"
+        android:text="@string/shortcut_action_disable_message"
+        android:textAppearance="?android:attr/textAppearanceMedium"
+        android:visibility="gone" />
+    <com.android.settings.slim.dslv.DragSortListView
+        android:id="@android:id/list"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:paddingTop="0dp"
+        android:paddingBottom="0dp"
+        android:paddingLeft="0dp"
+        android:layout_margin="0dp"
+        android:dividerHeight="1dp"
+        settings:dragEnabled="true"
+        settings:collapsedHeight="2dp"
+        settings:dragScrollStart="0.33"
+        settings:maxDragScrollSpeed="0.5"
+        settings:floatAlpha="0.6"
+        settings:slideShuffleSpeed="0.3"
+        settings:trackDragSort="false"
+        settings:useDefaultController="true"
+        settings:dragHandleId="@id/drag_handle"
+        settings:sortEnabled="true"
+        settings:removeEnabled="true"
+        settings:dragStartMode="onMove"
+        settings:removeMode="flingRemove"
+        settings:floatBackgroundColor="@color/dslv_float_cackground_color" />
+</LinearLayout>
diff --git a/res/layout/dialog_color_picker.xml b/res/layout/dialog_color_picker.xml
new file mode 100644
index 0000000..207c755
--- /dev/null
+++ b/res/layout/dialog_color_picker.xml
@@ -0,0 +1,154 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2010 Daniel Nilsson
+     Copyright (C) 2013 Slimroms
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:paddingLeft="5dp"
+    android:paddingRight="5dp"
+    android:orientation="vertical">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="6dp"
+        android:layout_marginBottom="6dp"
+        android:gravity="center"
+        android:orientation="horizontal">
+
+        <TextView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:text="@string/hex"
+            android:textSize="20sp"
+            android:layout_marginRight="10dp" />
+
+        <EditText
+            android:id="@+id/hex"
+            android:hint="@string/hex_hint"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content" />
+
+        <ImageButton
+            android:id="@+id/enter"
+            android:src="@drawable/ic_action_set"
+            android:background="@android:color/transparent"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="10dp"
+            android:gravity="center" />
+
+    </LinearLayout>
+
+    <net.margaritov.preference.colorpicker.ColorPickerView
+        android:id="@+id/color_picker_view"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_centerHorizontal="true"
+        android:tag="portrait" />
+
+    <LinearLayout
+        android:layout_width="wrap_content"
+        android:layout_height="30dp"
+        android:orientation="horizontal"
+        android:layout_marginLeft="7dp"
+        android:layout_marginRight="7dp"
+        android:layout_marginTop="2dp">
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/white_panel"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="6dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/black_panel"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="6dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/cyan_panel"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="6dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/red_panel"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="6dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/green_panel"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginRight="6dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/yellow_panel"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.5" />
+
+    </LinearLayout>
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:text="@string/press_color_to_apply"
+        android:gravity="center"
+        android:layout_marginTop="20dp"
+        android:layout_marginBottom="5dp"
+        android:textAppearance="?android:attr/textAppearanceSmall" />
+
+    <LinearLayout
+        android:layout_width="wrap_content"
+        android:layout_height="40dp"
+        android:orientation="horizontal"
+        android:layout_marginBottom="10dp">
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/old_color_panel"
+            android:layout_width="0px"
+            android:layout_height="fill_parent"
+            android:layout_weight="0.5" />
+
+        <TextView
+            android:layout_width="wrap_content"
+            android:layout_height="fill_parent"
+            android:text="@string/arrow_right"
+            android:textSize="20sp"
+            android:gravity="center"
+            android:layout_marginLeft="10dp"
+            android:layout_marginRight="10dp" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/new_color_panel"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_weight="0.5" />
+
+    </LinearLayout>
+
+</LinearLayout>
diff --git a/res/values/attrs.xml b/res/values/attrs.xml
index 4b607be..5ff8134 100644
--- a/res/values/attrs.xml
+++ b/res/values/attrs.xml
@@ -118,4 +118,34 @@
         <attr name="android:entries" />
         <attr name="android:entryValues" />
     </declare-styleable>
+
+    <!-- For DSLV -->
+    <declare-styleable name="DragSortListView">
+        <attr name="collapsedHeight" format="dimension" />
+        <attr name="dragScrollStart" format="float" />
+        <attr name="maxDragScrollSpeed" format="float" />
+        <attr name="floatBackgroundColor" format="color" />
+        <attr name="removeMode">
+            <enum name="clickRemove" value="0" />
+            <enum name="flingRemove" value="1" />
+        </attr>
+        <attr name="trackDragSort" format="boolean"/>
+        <attr name="floatAlpha" format="float"/>
+        <attr name="slideShuffleSpeed" format="float"/>
+        <attr name="removeAnimationDuration" format="integer"/>
+        <attr name="dropAnimationDuration" format="integer"/>
+        <attr name="dragEnabled" format="boolean" />
+        <attr name="sortEnabled" format="boolean" />
+        <attr name="removeEnabled" format="boolean" />
+        <attr name="dragStartMode">
+            <enum name="onDown" value="0" />
+            <enum name="onMove" value="1" />
+            <enum name="onLongPress" value="2"/>
+        </attr>
+        <attr name="dragHandleId" format="integer" />
+        <attr name="flingHandleId" format="integer" />
+        <attr name="clickRemoveId" format="integer" />
+        <attr name="useDefaultController" format="boolean" />
+    </declare-styleable>
+
 </resources>
diff --git a/res/values/slim_arrays.xml b/res/values/slim_arrays.xml
new file mode 100644
index 0000000..8ed5bd1
--- /dev/null
+++ b/res/values/slim_arrays.xml
@@ -0,0 +1,298 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2012-2014 SlimRoms Project
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+          http://www.apache.org/licenses/LICENSE-2.0
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!-- Icon type for shorcuts. -->
+    <string-array name="icon_types">
+        <item>@string/shortcuts_icon_default</item>
+        <item>@string/shortcuts_icon_presets</item>
+        <item>@string/shortcuts_icon_custom</item>
+    </string-array>
+
+    <string-array name="shortcut_icon_picker_labels">
+        <item>@string/shortcuts_icon_picker_alarm</item>
+        <item>@string/shortcuts_icon_picker_andy</item>
+        <item>@string/shortcuts_icon_picker_battery</item>
+        <item>@string/shortcuts_icon_picker_browser</item>
+        <item>@string/shortcuts_icon_picker_calendar</item>
+        <item>@string/shortcuts_icon_picker_camera</item>
+        <item>@string/shortcuts_icon_picker_cloud</item>
+        <item>@string/shortcuts_icon_picker_contact</item>
+        <item>@string/shortcuts_icon_picker_directdial</item>
+        <item>@string/shortcuts_icon_picker_directmessage</item>
+        <item>@string/shortcuts_icon_picker_drive</item>
+        <item>@string/shortcuts_icon_picker_dropbox</item>
+        <item>@string/shortcuts_icon_picker_email</item>
+        <item>@string/shortcuts_icon_picker_email2</item>
+        <item>@string/shortcuts_icon_picker_evernote</item>
+        <item>@string/shortcuts_icon_picker_facebook</item>
+        <item>@string/shortcuts_icon_picker_favorite</item>
+        <item>@string/shortcuts_icon_picker_file_browser</item>
+        <item>@string/shortcuts_icon_picker_file_browser2</item>
+        <item>@string/shortcuts_icon_picker_fitness</item>
+        <item>@string/shortcuts_icon_picker_gallery</item>
+        <item>@string/shortcuts_icon_picker_gears</item>
+        <item>@string/shortcuts_icon_picker_google_small</item>
+        <item>@string/shortcuts_icon_picker_gplus</item>
+        <item>@string/shortcuts_icon_picker_gtalk</item>
+        <item>@string/shortcuts_icon_picker_help</item>
+        <item>@string/shortcuts_icon_picker_joystick</item>
+        <item>@string/shortcuts_icon_picker_key</item>
+        <item>@string/shortcuts_icon_picker_laptop</item>
+        <item>@string/shortcuts_icon_picker_luggage</item>
+        <item>@string/shortcuts_icon_picker_maps</item>
+        <item>@string/shortcuts_icon_picker_market</item>
+        <item>@string/shortcuts_icon_picker_movie</item>
+        <item>@string/shortcuts_icon_picker_music</item>
+        <item>@string/shortcuts_icon_picker_nav</item>
+        <item>@string/shortcuts_icon_picker_notes</item>
+        <item>@string/shortcuts_icon_picker_package</item>
+        <item>@string/shortcuts_icon_picker_phone</item>
+        <item>@string/shortcuts_icon_picker_pinterest</item>
+        <item>@string/shortcuts_icon_picker_play</item>
+        <item>@string/shortcuts_icon_picker_pocket</item>
+        <item>@string/shortcuts_icon_picker_quicksettings</item>
+        <item>@string/shortcuts_icon_picker_rss</item>
+        <item>@string/shortcuts_icon_picker_sdcard</item>
+        <item>@string/shortcuts_icon_picker_search</item>
+        <item>@string/shortcuts_icon_picker_sms</item>
+        <item>@string/shortcuts_icon_picker_tasks</item>
+        <item>@string/shortcuts_icon_picker_terminal</item>
+        <item>@string/shortcuts_icon_picker_transit</item>
+        <item>@string/shortcuts_icon_picker_tv</item>
+        <item>@string/shortcuts_icon_picker_twitter</item>
+        <item>@string/shortcuts_icon_picker_unlock</item>
+    </string-array>
+
+    <string-array name="shortcut_icon_picker_icons" translatable="false">
+        <item>@*android:drawable/ic_shortcut_alarm</item>
+        <item>@*android:drawable/ic_shortcut_andy</item>
+        <item>@*android:drawable/ic_shortcut_battery</item>
+        <item>@*android:drawable/ic_shortcut_browser</item>
+        <item>@*android:drawable/ic_shortcut_calendar</item>
+        <item>@*android:drawable/ic_shortcut_camera</item>
+        <item>@*android:drawable/ic_shortcut_cloud</item>
+        <item>@*android:drawable/ic_shortcut_contact</item>
+        <item>@*android:drawable/ic_shortcut_directdial</item>
+        <item>@*android:drawable/ic_shortcut_directmessage</item>
+        <item>@*android:drawable/ic_shortcut_drive</item>
+        <item>@*android:drawable/ic_shortcut_dropbox</item>
+        <item>@*android:drawable/ic_shortcut_email</item>
+        <item>@*android:drawable/ic_shortcut_email2</item>
+        <item>@*android:drawable/ic_shortcut_evernote</item>
+        <item>@*android:drawable/ic_shortcut_facebook</item>
+        <item>@*android:drawable/ic_shortcut_favorite</item>
+        <item>@*android:drawable/ic_shortcut_file_browser</item>
+        <item>@*android:drawable/ic_shortcut_file_browser2</item>
+        <item>@*android:drawable/ic_shortcut_fitness</item>
+        <item>@*android:drawable/ic_shortcut_gallery</item>
+        <item>@*android:drawable/ic_shortcut_gear</item>
+        <item>@*android:drawable/ic_shortcut_google_small</item>
+        <item>@*android:drawable/ic_shortcut_gplus</item>
+        <item>@*android:drawable/ic_shortcut_gtalk</item>
+        <item>@*android:drawable/ic_shortcut_help</item>
+        <item>@*android:drawable/ic_shortcut_joystick</item>
+        <item>@*android:drawable/ic_shortcut_key</item>
+        <item>@*android:drawable/ic_shortcut_laptop</item>
+        <item>@*android:drawable/ic_shortcut_luggage</item>
+        <item>@*android:drawable/ic_shortcut_maps</item>
+        <item>@*android:drawable/ic_shortcut_market</item>
+        <item>@*android:drawable/ic_shortcut_movie</item>
+        <item>@*android:drawable/ic_shortcut_music</item>
+        <item>@*android:drawable/ic_shortcut_nav</item>
+        <item>@*android:drawable/ic_shortcut_notes</item>
+        <item>@*android:drawable/ic_shortcut_package</item>
+        <item>@*android:drawable/ic_shortcut_phone</item>
+        <item>@*android:drawable/ic_shortcut_pinterest</item>
+        <item>@*android:drawable/ic_shortcut_play</item>
+        <item>@*android:drawable/ic_shortcut_pocket</item>
+        <item>@*android:drawable/ic_shortcut_quicksettings</item>
+        <item>@*android:drawable/ic_shortcut_rss</item>
+        <item>@*android:drawable/ic_shortcut_sdcard</item>
+        <item>@*android:drawable/ic_shortcut_search</item>
+        <item>@*android:drawable/ic_shortcut_sms</item>
+        <item>@*android:drawable/ic_shortcut_tasks</item>
+        <item>@*android:drawable/ic_shortcut_terminal</item>
+        <item>@*android:drawable/ic_shortcut_transit</item>
+        <item>@*android:drawable/ic_shortcut_tv</item>
+        <item>@*android:drawable/ic_shortcut_twitter</item>
+        <item>@*android:drawable/ic_shortcut_unlock</item>
+    </string-array>
+
+    <string-array name="icon_color_mode_entries">
+        <item>@string/icon_color_mode_all_icons</item>
+        <item>@string/icon_color_mode_system_icons</item>
+        <item>@string/icon_color_mode_system_custom_icons</item>
+        <item>@string/disabled</item>
+    </string-array>
+
+    <string-array name="icon_color_mode_values" translatable="false">
+        <item>0</item>
+        <item>1</item>
+        <item>2</item>
+        <item>3</item>
+    </string-array>
+
+    <string-array name="shortcut_action_entries">
+        <item>@string/shortcut_action_back</item>
+        <item>@string/shortcut_action_app</item>
+        <item>@string/shortcut_action_home</item>
+        <item>@string/shortcut_action_kill</item>
+        <item>@string/shortcut_action_lastapp</item>
+        <item>@string/shortcut_action_notifications</item>
+        <item>@string/shortcut_action_ime</item>
+        <item>@string/shortcut_action_power_menu</item>
+        <item>@string/shortcut_action_qs</item>
+        <item>@string/shortcut_action_recent</item>
+        <item>@string/shortcut_action_power</item>
+        <item>@string/shortcut_action_screenshot</item>
+        <item>@string/shortcut_action_search</item>
+        <item>@string/shortcut_action_now_on_tap</item>
+        <item>@string/shortcut_action_torch</item>
+        <item>@string/shortcut_action_none</item>
+    </string-array>
+
+    <string-array name="shortcut_action_values" translatable="false">
+        <item>**back**</item>
+        <item>**app**</item>
+        <item>**home**</item>
+        <item>**kill**</item>
+        <item>**lastapp**</item>
+        <item>**notifications**</item>
+        <item>**ime**</item>
+        <item>**power_menu**</item>
+        <item>**settings_panel**</item>
+        <item>**recents**</item>
+        <item>**power**</item>
+        <item>**screenshot**</item>
+        <item>**search**</item>
+        <item>**now_on_tap**</item>
+        <item>**torch**</item>
+        <item>**null**</item>
+    </string-array>
+
+    <!-- NavBar -->
+    <string-array name="pref_navigation_menu_entries">
+        <item>@string/navigation_menu_right</item>
+        <item>@string/navigation_menu_left</item>
+        <item>@string/navigation_menu_both</item>
+    </string-array>
+
+    <!-- right is the default, easier to keep 0 as first index -->
+    <string-array name="pref_navigation_menu_values" translatable="false">
+        <item>0</item>
+        <item>1</item>
+        <item>2</item>
+    </string-array>
+
+    <string-array name="pref_menu_display_entries">
+        <item>@string/navigation_menu_always_show</item>
+        <item>@string/navigation_menu_never_show</item>
+        <item>@string/navigation_menu_default_jb_behavior</item>
+    </string-array>
+
+    <string-array name="pref_menu_display_values" translatable="false">
+        <item>0</item>
+        <item>1</item>
+        <item>2</item>
+    </string-array>
+
+    <string-array name="navigation_bar_width_entries" translatable="false">
+        <item>@string/navigation_bar_size_42_dp_default</item>
+        <item>@string/navigation_bar_size_40_dp</item>
+        <item>@string/navigation_bar_size_36_dp</item>
+        <item>@string/navigation_bar_size_30_dp</item>
+        <item>@string/navigation_bar_size_24_dp</item>
+        <item>@string/navigation_bar_size_0_dp</item>
+    </string-array>
+
+    <string-array name="navigation_bar_width" translatable="false">
+        <item>42</item>
+        <item>40</item>
+        <item>36</item>
+        <item>30</item>
+        <item>24</item>
+        <item>0</item>
+    </string-array>
+
+    <string-array name="navigation_bar_height_entries" translatable="false">
+        <item>@string/navigation_bar_size_48_dp_default</item>
+        <item>@string/navigation_bar_size_44_dp</item>
+        <item>@string/navigation_bar_size_42_dp</item>
+        <item>@string/navigation_bar_size_40_dp</item>
+        <item>@string/navigation_bar_size_36_dp</item>
+        <item>@string/navigation_bar_size_30_dp</item>
+        <item>@string/navigation_bar_size_24_dp</item>
+        <item>@string/navigation_bar_size_0_dp</item>
+    </string-array>
+
+    <string-array name="navigation_bar_height" translatable="false">
+        <item>48</item>
+        <item>44</item>
+        <item>42</item>
+        <item>40</item>
+        <item>36</item>
+        <item>30</item>
+        <item>24</item>
+        <item>0</item>
+    </string-array>
+
+    <string-array name="navigation_bar_height_landscape_entries" translatable="false">
+        <item>@string/navigation_bar_size_48_dp_default</item>
+        <item>@string/navigation_bar_size_44_dp</item>
+        <item>@string/navigation_bar_size_42_dp</item>
+        <item>@string/navigation_bar_size_40_dp</item>
+        <item>@string/navigation_bar_size_36_dp</item>
+        <item>@string/navigation_bar_size_30_dp</item>
+        <item>@string/navigation_bar_size_24_dp</item>
+        <item>@string/navigation_bar_size_0_dp</item>
+    </string-array>
+
+    <string-array name="navigation_bar_height_landscape" translatable="false">
+        <item>48</item>
+        <item>44</item>
+        <item>42</item>
+        <item>40</item>
+        <item>36</item>
+        <item>30</item>
+        <item>24</item>
+        <item>0</item>
+    </string-array>
+
+     <string-array name="shortcut_action_screen_off_entries">
+        <item>@string/shortcut_action_app</item>
+        <item>@string/shortcut_action_camera</item>
+        <item>@string/shortcut_action_media_next</item>
+        <item>@string/shortcut_action_media_play_pause</item>
+        <item>@string/shortcut_action_media_previous</item>
+        <item>@string/shortcut_action_ring_silent</item>
+        <item>@string/shortcut_action_ring_vib</item>
+        <item>@string/shortcut_action_ring_vib_silent</item>
+        <item>@string/shortcut_action_wake_device</item>
+        <item>@string/shortcut_action_none</item>
+    </string-array>
+
+    <string-array name="shortcut_action_screen_off_values" translatable="false">
+        <item>**app**</item>
+        <item>**camera**</item>
+        <item>**media_next**</item>
+        <item>**media_play_pause**</item>
+        <item>**media_previous**</item>
+        <item>**ring_silent**</item>
+        <item>**ring_vib**</item>
+        <item>**ring_vib_silent**</item>
+        <item>**wake_device**</item>
+        <item>**null**</item>
+    </string-array>
+
+</resources>
diff --git a/res/values/slim_colors.xml b/res/values/slim_colors.xml
new file mode 100644
index 0000000..498e7a6
--- /dev/null
+++ b/res/values/slim_colors.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2016 SlimRoms Project
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+
+    <!-- DSLV colors -->
+    <color name="dslv_icon_dark">#ff009688</color>
+    <color name="dslv_float_cackground_color">#ffe1e1e0</color>
+
+</resources>
diff --git a/res/values/slim_dimens.xml b/res/values/slim_dimens.xml
new file mode 100755
index 0000000..3c63473
--- /dev/null
+++ b/res/values/slim_dimens.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2009 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources>
+    <!-- Navbar -->
+    <dimen name="navigation_bar_48">48dp</dimen>
+    <dimen name="navigation_bar_44">44dp</dimen>
+    <dimen name="navigation_bar_42">42dp</dimen>
+    <dimen name="navigation_bar_40">40dp</dimen>
+    <dimen name="navigation_bar_36">36dp</dimen>
+    <dimen name="navigation_bar_30">30dp</dimen>
+    <dimen name="navigation_bar_24">24dp</dimen>
+    <dimen name="navigation_bar_0">0dp</dimen>
+</resources>
diff --git a/res/values/slim_ids.xml b/res/values/slim_ids.xml
new file mode 100644
index 0000000..14d9fdf
--- /dev/null
+++ b/res/values/slim_ids.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2013 Slimroms
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources>
+    <item type="id" name="drag_handle" />
+</resources>
diff --git a/res/values/slim_strings.xml b/res/values/slim_strings.xml
new file mode 100644
index 0000000..8bb7e61
--- /dev/null
+++ b/res/values/slim_strings.xml
@@ -0,0 +1,235 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2012-2014 SlimRoms Project
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+          http://www.apache.org/licenses/LICENSE-2.0
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!-- General strings -->
+    <string name="ok">OK</string>
+    <string name="reset">Reset</string>
+    <string name="help">Help</string>
+    <string name="add">Add</string>
+    <string name="help">Help</string>
+    <string name="attention">Attention</string>
+    <string name="enabled">Enabled</string>
+    <string name="default_string">Default</string>
+    <string name="choose_app">Choose application</string>
+    <string name="reset_message">Reset all entries to default?</string>
+
+    <!-- Slim settings screens -->
+    <string name="header_category_personalization">Personalization</string>
+    <string name="navigation_settings_title">Navigation</string>
+
+    <!-- Color Picker -->
+    <string name="dialog_color_picker">Color Picker</string>
+    <string name="press_color_to_apply">Press on color below to apply</string>
+    <string name="arrow_right" translatable="false">→</string>
+    <string name="arrow_down" translatable="false">↓</string>
+    <string name="hex">Hex:</string>
+    <string name="hex_hint">#ff000000</string>
+    <string name="set">Set</string>
+    <string name="color_default">Default</string>
+
+    <string name="shortcut_action_none">None</string>
+    <string name="shortcut_action_app">Custom app</string>
+    <string name="shortcut_action_home">Home</string>
+    <string name="shortcut_action_back">Back</string>
+    <string name="shortcut_action_menu">Menu</string>
+    <string name="shortcut_action_ime">Open IME Switcher</string>
+    <string name="shortcut_action_power_menu">Power menu</string>
+    <string name="shortcut_action_recent">Recents</string>
+    <string name="shortcut_action_power">Screen Off</string>
+    <string name="shortcut_action_search">Search in app</string>
+    <string name="shortcut_action_now_on_tap">Now on Tap</string>
+    <string name="shortcut_action_ring_vib">Ring/Vib</string>
+    <string name="shortcut_action_ring_silent">Ring/Silent</string>
+    <string name="shortcut_action_ring_vib_silent">Ring/Vib/Silent</string>
+    <string name="shortcut_action_camera">Camera</string>
+    <string name="shortcut_action_media_next">Music - next track</string>
+    <string name="shortcut_action_media_play_pause">Music - play/pause</string>
+    <string name="shortcut_action_media_previous">Music - previous track</string>
+    <string name="shortcut_action_wake_device">Wake up device</string>
+    <string name="shortcut_action_kill">Kill app</string>
+    <string name="shortcut_action_screenshot">Screenshot</string>
+    <string name="shortcut_action_lastapp">Last app</string>
+    <string name="shortcut_action_notifications">Notifications</string>
+    <string name="shortcut_action_qs">Quicksettings panel</string>
+    <string name="shortcut_action_torch">Flashlight</string>
+    <string name="shortcut_action_ring_vib">Ring/Vib</string>
+    <string name="shortcut_action_ring_silent">Ring/Silent</string>
+    <string name="shortcut_action_ring_vib_silent">Ring/Vib/Silent</string>
+    <string name="shortcut_action_longpress">Longpress:</string>
+    <string name="shortcut_action_select_action_longpress">Choose longpress action:</string>
+    <string name="shortcut_action_select_action">Choose action:</string>
+    <string name="shortcut_action_select_action_newaction">Choose new action:</string>
+    <string name="shortcut_action_reset">Reset</string>
+    <string name="shortcut_action_add">Add</string>
+    <string name="shortcut_action_reset_message">Reset all entries to default?</string>
+    <string name="shortcut_action_max">Maximum entries size has been reached</string>
+    <string name="shortcut_action_warning">Warning</string>
+    <string name="shortcut_action_warning_message">It is not possible to delete last entry</string>
+    <string name="shortcut_action_required_warning_message">It is not possible to delete required buttons</string>
+    <string name="shortcut_action_disable_message">Disabled\nAdd an entry to enable this feature</string>
+    <string name="shortcut_image_not_valid">The chosen app did not return a valid icon or does not support image cropping. Use another app.</string>
+    <string name="shortcut_duplicate_entry">The chosen action cannot be added twice</string>
+    <string name="shortcut_action_help_shortcut">shortcut</string>
+    <string name="shortcut_action_help_button">button</string>
+    <string name="shortcut_action_help_app">app</string>
+    <string name="shortcut_action_help_icon">, while selecting the icon will bring up customization options</string>
+    <string name="shortcut_action_help_main">To add a %1$s, select the Add icon. Once a %1$s is added, selecting the row will change the target%2$s\n\nTo remove a %1$s, swipe the row horizontally left or right. Re-order a %1$s in the list by vertically dragging the anchor on the left.\n\nTo clear or reset to defaults, select the reset option.</string>
+    <string name="shortcut_action_help_delete_last_entry">Removing every %1$s in the list will disable the feature entirely.</string>
+    <string name="shortcut_action_help_pie_second_layer_delete_last_entry">Removing every %1$s in the list will disable the second pie layer entirely.</string>
+
+    <string name="icon_color_mode_all_icons">All icons</string>
+    <string name="icon_color_mode_system_icons">System icons</string>
+    <string name="icon_color_mode_system_custom_icons">System and custom icons</string>
+    <string name="shortcuts_applications">Applications</string>
+    <string name="shortcuts_select_custom_app_title">Select custom application</string>
+    <string name="shortcuts_icon_picker_type">Select icon type:</string>
+    <string name="shortcuts_icon_default">Default</string>
+    <string name="shortcuts_icon_presets">System icons</string>
+    <string name="shortcuts_icon_custom">Gallery</string>
+    <string name="shortcuts_icon_picker_choose_icon_title">Choose icon</string>
+
+    <string name="shortcuts_icon_picker_alarm">Alarm</string>
+    <string name="shortcuts_icon_picker_andy">Andy</string>
+    <string name="shortcuts_icon_picker_battery">Battery</string>
+    <string name="shortcuts_icon_picker_browser">Browser</string>
+    <string name="shortcuts_icon_picker_calendar">Calendar</string>
+    <string name="shortcuts_icon_picker_camera">Camera</string>
+    <string name="shortcuts_icon_picker_cloud">Cloud</string>
+    <string name="shortcuts_icon_picker_contact">Contact</string>
+    <string name="shortcuts_icon_picker_directdial">Direct Dial</string>
+    <string name="shortcuts_icon_picker_directmessage">Direct Message</string>
+    <string name="shortcuts_icon_picker_drive">Drive</string>
+    <string name="shortcuts_icon_picker_dropbox">Dropbox</string>
+    <string name="shortcuts_icon_picker_email">Email</string>
+    <string name="shortcuts_icon_picker_email2">Email Alternate</string>
+    <string name="shortcuts_icon_picker_evernote">Evernote</string>
+    <string name="shortcuts_icon_picker_facebook">Facebook</string>
+    <string name="shortcuts_icon_picker_favorite">Favorite</string>
+    <string name="shortcuts_icon_picker_file_browser">File Browser</string>
+    <string name="shortcuts_icon_picker_file_browser2">File Browser Alternate</string>
+    <string name="shortcuts_icon_picker_fitness">Fitness</string>
+    <string name="shortcuts_icon_picker_gallery">Gallery</string>
+    <string name="shortcuts_icon_picker_gears">Gears</string>
+    <string name="shortcuts_icon_picker_google_small">Google</string>
+    <string name="shortcuts_icon_picker_gplus">Google Plus</string>
+    <string name="shortcuts_icon_picker_gtalk">Hangouts</string>
+    <string name="shortcuts_icon_picker_help">Help</string>
+    <string name="shortcuts_icon_picker_joystick">Joystick</string>
+    <string name="shortcuts_icon_picker_key">Keys/Accounts</string>
+    <string name="shortcuts_icon_picker_laptop">Laptop</string>
+    <string name="shortcuts_icon_picker_notes">Notes</string>
+    <string name="shortcuts_icon_picker_luggage">Travel</string>
+    <string name="shortcuts_icon_picker_maps">Maps</string>
+    <string name="shortcuts_icon_picker_market">Market</string>
+    <string name="shortcuts_icon_picker_movie">Movies</string>
+    <string name="shortcuts_icon_picker_music">Music</string>
+    <string name="shortcuts_icon_picker_nav">Navigation</string>
+    <string name="shortcuts_icon_picker_phone">Phone</string>
+    <string name="shortcuts_icon_picker_package">Package</string>
+    <string name="shortcuts_icon_picker_pinterest">Pinterest</string>
+    <string name="shortcuts_icon_picker_play">Play</string>
+    <string name="shortcuts_icon_picker_pocket">Pocket</string>
+    <string name="shortcuts_icon_picker_quicksettings">Quick Settings</string>
+    <string name="shortcuts_icon_picker_rss">RSS Feed</string>
+    <string name="shortcuts_icon_picker_sdcard">SDCard</string>
+    <string name="shortcuts_icon_picker_search">Search</string>
+    <string name="shortcuts_icon_picker_sms">Messaging</string>
+    <string name="shortcuts_icon_picker_tasks">Tasks</string>
+    <string name="shortcuts_icon_picker_terminal">Terminal</string>
+    <string name="shortcuts_icon_picker_transit">Transit</string>
+    <string name="shortcuts_icon_picker_tv">TV</string>
+    <string name="shortcuts_icon_picker_twitter">Twitter</string>
+    <string name="shortcuts_icon_picker_unlock">Unlock</string>
+
+    <!-- Navigation settings -->
+    <string name="navigation_settings_options_title">Navigation options</string>
+
+    <!-- Button shorcut actions -->
+    <string name="shortcut_action_back">Back</string>
+    <string name="shortcut_action_app">Custom app</string>
+    <string name="shortcut_action_expanded_desktop">Expanded desktop</string>
+    <string name="shortcut_action_home">Home</string>
+    <string name="shortcut_action_kill">Kill app</string>
+    <string name="shortcut_action_lastapp">Last app</string>
+    <string name="shortcut_action_navbar">Navigation bar</string>
+    <string name="shortcut_action_notifications">Notifications</string>
+    <string name="shortcut_action_menu_big">Menu</string>
+    <string name="shortcut_action_ime">Open IME Switcher</string>
+    <string name="shortcut_action_power_menu">Power menu</string>
+    <string name="shortcut_action_qs">Quicksettings panel</string>
+    <string name="shortcut_action_smart">Smart pulldown</string>
+    <string name="shortcut_action_recent">Recents</string>
+    <string name="shortcut_action_ring_vib">Ring/Vib</string>
+    <string name="shortcut_action_ring_silent">Ring/Silent</string>
+    <string name="shortcut_action_ring_vib_silent">Ring/Vib/Silent</string>
+    <string name="shortcut_action_power">Screen Off</string>
+    <string name="shortcut_action_screenshot">Screenshot</string>
+    <string name="shortcut_action_assist">Search</string>
+    <string name="shortcut_action_search">Search in app</string>
+    <string name="shortcut_action_theme_switch">Theme switcher</string>
+    <string name="shortcut_action_torch">Torch</string>
+    <string name="shortcut_action_voice_search">Voice search</string>
+    <string name="shortcut_action_none">None</string>
+
+    <string name="navigation_settings_title">Navigation</string>
+
+    <!-- Navigation bar -->
+    <string name="navigation_bar_size_42_dp_default">42 dp (default)</string>
+    <string name="navigation_bar_size_36_dp">36 dp</string>
+    <string name="navigation_bar_size_30_dp">30 dp</string>
+    <string name="navigation_bar_size_24_dp">24 dp</string>
+    <string name="navigation_bar_size_48_dp_default">48 dp (default)</string>
+    <string name="navigation_bar_size_44_dp">44 dp</string>
+    <string name="navigation_bar_size_40_dp">40 dp</string>
+    <string name="navigation_bar_size_42_dp">42 dp</string>
+    <string name="navigation_bar_size_0_dp">0 dp (off)</string>
+    <string name="navigation_menu_right">Right</string>
+    <string name="navigation_menu_left">Left</string>
+    <string name="navigation_menu_both">Both</string>
+    <string name="navigation_menu_default_jb_behavior">Show on request (default)</string>
+    <string name="navigation_menu_never_show">Never show</string>
+    <string name="navigation_menu_always_show">Always show</string>
+    <string name="navigation_bar">Navigation bar</string>
+    <string name="navbar_button_cat">Navigation bar buttons</string>
+    <string name="title_pref_menu_location">Menu location</string>
+    <string name="summary_pref_menu_location">Where do you want the menu buttons to appear?</string>
+    <string name="title_pref_menu_display">Menu visibility</string>
+    <string name="summary_pref_menu_display">How and when do you want the menu buttons to appear?</string>
+    <string name="navbar_enable_bar">Enable navigation bar</string>
+    <string name="navbar_enable_bar_summary">Enable the navigation bar</string>
+    <string name="navigation_bar_height_title">Navigation bar height</string>
+    <string name="navigation_bar_height_summary">Navigation bar height while in portrait.</string>
+    <string name="navigation_bar_height_landscape_title">Navigation bar height landscape</string>
+    <string name="navigation_bar_height_landscape_summary">Navigation bar height while in landscape.</string>
+    <string name="navigation_bar_width_title">Navigation bar width</string>
+    <string name="navigation_bar_width_summary">Navigation bar height if the bar is along a side.</string>
+    <string name="navbar_can_move">Show landscape</string>
+    <string name="navbar_can_move_summary">Shows navigation bar in landscape on the bottom</string>
+    <string name="navbar_style_dimen_title">Dimensions</string>
+    <string name="navbar_button_title">Buttons</string>
+    <string name="navbar_cat">Navigation bar</string>
+    <string name="navbar_dimensions_reset_message">Reset all dimensions entries to default?</string>
+    <string name="navbar_button_style_reset_message">Reset all style entries to default?</string>
+
+    <!-- Navigation bar button style -->
+    <string name="nav_bar_button_style">Button style</string>
+    <string name="nav_bar_button_style_summary">Change navigation bar button style</string>
+    <string name="button_transparency_title">Button transparency</string>
+    <string name="navigation_bar_icon_tint_title">Button color</string>
+    <string name="nav_button_color_mode_title">Color mode</string>
+    <string name="nav_button_color_mode_dialog_title">Colorize</string>
+    <string name="nav_button_color_mode_summary">Change the navigation bar button color mode</string>
+    <string name="navigation_bar_glow_tint_title">Button glow color</string>
+
+</resources>
diff --git a/res/xml/dashboard_categories.xml b/res/xml/dashboard_categories.xml
index d437dcf..713c0e5 100644
--- a/res/xml/dashboard_categories.xml
+++ b/res/xml/dashboard_categories.xml
@@ -142,6 +142,14 @@
                 android:icon="@drawable/ic_settings_multiuser"
                 />
 
+        <!-- Navigation -->
+        <dashboard-tile
+                android:id="@+id/navigation_settings"
+                android:title="@string/navigation_settings_title"
+                android:fragment="com.android.settings.slim.NavigationSettings"
+                android:icon="@drawable/ic_settings_navigation"
+                />
+
         <!-- Manage NFC payment apps -->
         <dashboard-tile
                 android:id="@+id/nfc_payment_settings"
diff --git a/res/xml/device_info_storage_volume.xml b/res/xml/device_info_storage_volume.xml
index 35435d7..796dc8d 100644
--- a/res/xml/device_info_storage_volume.xml
+++ b/res/xml/device_info_storage_volume.xml
@@ -20,4 +20,9 @@
     android:title="@string/storage_settings"
     settings:keywords="@string/keywords_storage">
 
+    <PreferenceScreen
+        android:key="navbar_settings"
+        android:fragment="com.android.settings.slim.NavbarSettings"
+        android:title="@string/navigation_bar" />
+
 </PreferenceScreen>
diff --git a/res/xml/navbar_button_fragment.xml b/res/xml/navbar_button_fragment.xml
new file mode 100644
index 0000000..e482c6c
--- /dev/null
+++ b/res/xml/navbar_button_fragment.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2013-2015 Slimroms Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <PreferenceScreen
+        android:fragment="com.android.settings.slim.NavBarButtonStyle"
+        android:key="nav_bar_button_style"
+        android:title="@string/nav_bar_button_style"
+        android:summary="@string/nav_bar_button_style_summary" />
+
+</PreferenceScreen>
diff --git a/res/xml/navbar_button_style.xml b/res/xml/navbar_button_style.xml
new file mode 100644
index 0000000..f6d744d
--- /dev/null
+++ b/res/xml/navbar_button_style.xml
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Copyright (C) 2013-2015 SlimRoms Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<PreferenceScreen
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:settings="http://schemas.android.com/apk/res/com.android.settings"
+    android:title="@string/nav_bar_button_style">
+
+    <!-- Status bar tweaks -->
+    <PreferenceCategory
+        android:title="@string/nav_bar_button_style">
+
+        <net.margaritov.preference.colorpicker.ColorPickerPreference
+             android:key="nav_button_color"
+             android:title="@string/navigation_bar_icon_tint_title"
+             android:defaultValue="0xffffffff" />
+
+        <ListPreference
+             android:entries="@array/icon_color_mode_entries"
+             android:entryValues="@array/icon_color_mode_values"
+             android:key="nav_button_color_mode"
+             android:title="@string/nav_button_color_mode_title"
+             android:dialogTitle="@string/nav_button_color_mode_dialog_title"
+             android:summary="@string/nav_button_color_mode_summary" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPreference
+             android:key="nav_button_glow_color"
+             android:title="@string/navigation_bar_glow_tint_title"
+             android:defaultValue="0xffffffff" />
+
+    </PreferenceCategory>
+
+</PreferenceScreen>
diff --git a/res/xml/navbar_settings.xml b/res/xml/navbar_settings.xml
new file mode 100644
index 0000000..2f1cd85
--- /dev/null
+++ b/res/xml/navbar_settings.xml
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2012-2015 Slimroms Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<PreferenceScreen
+    xmlns:android="http://schemas.android.com/apk/res/android">
+
+        <SwitchPreference
+                android:key="enable_nav_bar"
+                android:title="@string/navbar_enable_bar"
+                android:summary="@string/navbar_enable_bar_summary" />
+
+        <PreferenceCategory
+                android:key="navbar_cat"
+                android:title="@string/navbar_cat" >
+
+            <PreferenceScreen
+                    android:key="navbar_button_settings"
+                    android:fragment="com.android.settings.slim.dslv.ActionListViewSettings"
+                    android:title="@string/navbar_button_title">
+                <extra android:name="actionMode" android:value="0" />
+                <extra android:name="maxAllowedButtons" android:value="5" />
+                <extra android:name="disableDeleteLastEntry" android:value="true" />
+                <extra android:name="fragment" android:value="com.android.settings.slim.fragments.NavbarButtonFragment" />
+            </PreferenceScreen>
+
+            <PreferenceScreen
+                android:key="navbar_style_dimen_settings"
+                android:fragment="com.android.settings.slim.NavbarStyleDimenSettings"
+                android:title="@string/navbar_style_dimen_title" />
+
+        </PreferenceCategory>
+
+        <PreferenceCategory
+                android:key="advanced_cat"
+                android:title="@string/advanced_settings">
+
+            <ListPreference
+                    android:key="pref_navbar_menu_display"
+                    android:entries="@array/pref_menu_display_entries"
+                    android:entryValues="@array/pref_menu_display_values"
+                    android:title="@string/title_pref_menu_display"
+                    android:summary="@string/summary_pref_menu_display" />
+
+            <ListPreference
+                    android:key="pref_navbar_menu_location"
+                    android:entries="@array/pref_navigation_menu_entries"
+                    android:entryValues="@array/pref_navigation_menu_values"
+                    android:title="@string/title_pref_menu_location"
+                    android:summary="@string/summary_pref_menu_location" />
+
+            <SwitchPreference
+                    android:key="navbar_can_move"
+                    android:title="@string/navbar_can_move"
+                    android:summary="@string/navbar_can_move_summary" />
+
+        </PreferenceCategory>
+
+</PreferenceScreen>
diff --git a/res/xml/navbar_style_dimen_settings.xml b/res/xml/navbar_style_dimen_settings.xml
new file mode 100644
index 0000000..78ed446
--- /dev/null
+++ b/res/xml/navbar_style_dimen_settings.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2012-2015 Slimroms Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
+
+    <ListPreference
+        android:entries="@array/navigation_bar_height_entries"
+        android:entryValues="@array/navigation_bar_height"
+        android:key="navigation_bar_height"
+        android:title="@string/navigation_bar_height_title"
+        android:summary="@string/navigation_bar_height_summary" />
+
+    <ListPreference
+        android:entries="@array/navigation_bar_height_landscape_entries"
+        android:entryValues="@array/navigation_bar_height_landscape"
+        android:key="navigation_bar_height_landscape"
+        android:title="@string/navigation_bar_height_landscape_title"
+        android:summary="@string/navigation_bar_height_landscape_summary" />
+
+    <ListPreference
+        android:entries="@array/navigation_bar_width_entries"
+        android:entryValues="@array/navigation_bar_width"
+        android:key="navigation_bar_width"
+        android:title="@string/navigation_bar_width_title"
+        android:summary="@string/navigation_bar_width_summary" />
+
+</PreferenceScreen>
diff --git a/res/xml/slim_navigation_settings.xml b/res/xml/slim_navigation_settings.xml
new file mode 100644
index 0000000..aab8ece
--- /dev/null
+++ b/res/xml/slim_navigation_settings.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2013-2015 Slimroms
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<PreferenceScreen
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:title="@string/navigation_settings_options_title"
+    xmlns:settings="http://schemas.android.com/apk/res/com.android.settings">
+
+    <!--<PreferenceScreen
+        android:key="hardwarekeys_settings"
+        android:fragment="com.android.settings.slim.HardwareKeysSettings"
+        android:title="@string/button_keys_title" />-->
+
+    <PreferenceScreen
+        android:key="navbar_settings"
+        android:fragment="com.android.settings.slim.NavbarSettings"
+        android:title="@string/navigation_bar" />
+
+    <!--<PreferenceScreen
+        android:key="pie_settings"
+        android:fragment="com.android.settings.slim.PieControl"
+        android:title="@string/pie_control_title" />-->
+
+    <!-- DeviceHandler device specific screen off gesture settings -->
+    <!--<Preference
+        android:key="screen_off_gesture_settings"
+        android:title="@string/screen_off_gesture_settings_title">
+            <intent
+                android:action="com.slim.action.LAUNCH_SCREEN_OFF_GESTURE_SETTINGS"
+                android:targetPackage="com.slim.device"
+                android:targetClass="com.slim.device.settings.ScreenOffGestureSettings" />
+    </Preference>-->
+
+</PreferenceScreen>
diff --git a/src/com/android/settings/SettingsActivity.java b/src/com/android/settings/SettingsActivity.java
index 8edec09..c697b58 100644
--- a/src/com/android/settings/SettingsActivity.java
+++ b/src/com/android/settings/SettingsActivity.java
@@ -115,6 +115,7 @@ import com.android.settings.print.PrintSettingsFragment;
 import com.android.settings.search.DynamicIndexableContentMonitor;
 import com.android.settings.search.Index;
 import com.android.settings.sim.SimSettings;
+import com.android.settings.slim.NavigationSettings;
 import com.android.settings.tts.TextToSpeechSettings;
 import com.android.settings.users.UserSettings;
 import com.android.settings.vpn2.VpnSettings;
@@ -354,6 +355,7 @@ public class SettingsActivity extends Activity
             ProcessStatsSummary.class.getName(),
             DrawOverlayDetails.class.getName(),
             WriteSettingsDetails.class.getName(),
+            NavigationSettings.class.getName(),
     };
 
 
diff --git a/src/com/android/settings/slim/NavBarButtonStyle.java b/src/com/android/settings/slim/NavBarButtonStyle.java
new file mode 100644
index 0000000..9f35966
--- /dev/null
+++ b/src/com/android/settings/slim/NavBarButtonStyle.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2012-2015 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import android.os.PowerManager;
+import android.preference.CheckBoxPreference;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.Preference.OnPreferenceChangeListener;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceScreen;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+
+import com.android.settings.SettingsPreferenceFragment;
+import com.android.settings.R;
+
+import net.margaritov.preference.colorpicker.ColorPickerPreference;
+
+public class NavBarButtonStyle extends SettingsPreferenceFragment implements
+        OnPreferenceChangeListener {
+
+    private static final String TAG = "NavBarButtonStyle";
+    private static final String PREF_NAV_BUTTON_COLOR = "nav_button_color";
+    private static final String PREF_NAV_BUTTON_COLOR_MODE = "nav_button_color_mode";
+    private static final String PREF_NAV_GLOW_COLOR = "nav_button_glow_color";
+
+    private static final int MENU_RESET = Menu.FIRST;
+
+    private boolean mCheckPreferences;
+
+    ColorPickerPreference mNavigationBarButtonColor;
+    ListPreference mNavigationBarButtonColorMode;
+    ColorPickerPreference mNavigationBarGlowColor;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        refreshSettings();
+    }
+
+    private PreferenceScreen refreshSettings() {
+        mCheckPreferences = false;
+        PreferenceScreen prefs = getPreferenceScreen();
+        if (prefs != null) {
+            prefs.removeAll();
+        }
+
+        // Load the preferences from an XML resource
+        addPreferencesFromResource(R.xml.navbar_button_style);
+
+        prefs = getPreferenceScreen();
+
+        mNavigationBarButtonColor = (ColorPickerPreference) findPreference(PREF_NAV_BUTTON_COLOR);
+        mNavigationBarButtonColor.setOnPreferenceChangeListener(this);
+        int intColor = Settings.System.getInt(getContentResolver(),
+                    Settings.System.NAVIGATION_BAR_BUTTON_TINT, -2);
+        if (intColor == -2) {
+            intColor = getResources().getColor(
+                    com.android.internal.R.color.white);
+            mNavigationBarButtonColor.setSummary(getResources().getString(R.string.default_string));
+        } else {
+            String hexColor = String.format("#%08x", (0xffffffff & intColor));
+            mNavigationBarButtonColor.setSummary(hexColor);
+        }
+        mNavigationBarButtonColor.setNewPreviewColor(intColor);
+
+        mNavigationBarGlowColor = (ColorPickerPreference) findPreference(PREF_NAV_GLOW_COLOR);
+        mNavigationBarGlowColor.setOnPreferenceChangeListener(this);
+        intColor = Settings.System.getInt(getContentResolver(),
+                    Settings.System.NAVIGATION_BAR_GLOW_TINT, -2);
+        if (intColor == -2) {
+            intColor = getResources().getColor(
+                    com.android.internal.R.color.white);
+            mNavigationBarGlowColor.setSummary(getResources().getString(R.string.default_string));
+        } else {
+            String hexColor = String.format("#%08x", (0xffffffff & intColor));
+            mNavigationBarGlowColor.setSummary(hexColor);
+        }
+        mNavigationBarGlowColor.setNewPreviewColor(intColor);
+
+        mNavigationBarButtonColorMode =
+            (ListPreference) prefs.findPreference(PREF_NAV_BUTTON_COLOR_MODE);
+        int navigationBarButtonColorMode = Settings.System.getInt(getContentResolver(),
+                Settings.System.NAVIGATION_BAR_BUTTON_TINT_MODE, 0);
+        mNavigationBarButtonColorMode.setValue(String.valueOf(navigationBarButtonColorMode));
+        mNavigationBarButtonColorMode.setSummary(mNavigationBarButtonColorMode.getEntry());
+        mNavigationBarButtonColorMode.setOnPreferenceChangeListener(this);
+
+        updateColorPreference();
+
+        setHasOptionsMenu(true);
+        mCheckPreferences = true;
+        return prefs;
+    }
+
+    @Override
+    protected int getMetricsCategory() {
+        return -1;
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        menu.add(0, MENU_RESET, 0, R.string.reset)
+                .setIcon(R.drawable.ic_settings_reset_button) // use the reset settings icon
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case MENU_RESET:
+                resetToDefault();
+                return true;
+             default:
+                return super.onContextItemSelected(item);
+        }
+    }
+
+    private void resetToDefault() {
+        AlertDialog.Builder alertDialog = new AlertDialog.Builder(getActivity());
+        alertDialog.setTitle(R.string.reset);
+        alertDialog.setMessage(R.string.navbar_button_style_reset_message);
+        alertDialog.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int id) {
+                Settings.System.putInt(getActivity().getContentResolver(),
+                        Settings.System.NAVIGATION_BAR_BUTTON_TINT, -2);
+                Settings.System.putInt(getActivity().getContentResolver(),
+                       Settings.System.NAVIGATION_BAR_BUTTON_TINT_MODE, 0);
+                Settings.System.putInt(getActivity().getContentResolver(),
+                        Settings.System.NAVIGATION_BAR_GLOW_TINT, -2);
+                refreshSettings();
+            }
+        });
+        alertDialog.setNegativeButton(R.string.cancel, null);
+        alertDialog.create().show();
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (!mCheckPreferences) {
+            return false;
+        }
+        if (preference == mNavigationBarButtonColor) {
+            String hex = ColorPickerPreference.convertToARGB(
+                    Integer.valueOf(String.valueOf(newValue)));
+            preference.setSummary(hex);
+            int intHex = ColorPickerPreference.convertToColorInt(hex);
+            Settings.System.putInt(getActivity().getContentResolver(),
+                    Settings.System.NAVIGATION_BAR_BUTTON_TINT, intHex);
+            return true;
+        } else if (preference == mNavigationBarButtonColorMode) {
+            int index = mNavigationBarButtonColorMode.findIndexOfValue((String) newValue);
+            int value = Integer.valueOf((String) newValue);
+            Settings.System.putInt(getContentResolver(),
+                    Settings.System.NAVIGATION_BAR_BUTTON_TINT_MODE,
+                    value);
+            mNavigationBarButtonColorMode.setSummary(
+                mNavigationBarButtonColorMode.getEntries()[index]);
+            updateColorPreference();
+            return true;
+        } if (preference == mNavigationBarGlowColor) {
+            String hex = ColorPickerPreference.convertToARGB(
+                    Integer.valueOf(String.valueOf(newValue)));
+            preference.setSummary(hex);
+            int intHex = ColorPickerPreference.convertToColorInt(hex);
+            Settings.System.putInt(getActivity().getContentResolver(),
+                    Settings.System.NAVIGATION_BAR_GLOW_TINT, intHex);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+    }
+
+    private void updateColorPreference() {
+        int navigationBarButtonColorMode = Settings.System.getInt(getContentResolver(),
+                Settings.System.NAVIGATION_BAR_BUTTON_TINT_MODE, 0);
+        mNavigationBarButtonColor.setEnabled(navigationBarButtonColorMode != 3);
+    }
+}
diff --git a/src/com/android/settings/slim/NavbarSettings.java b/src/com/android/settings/slim/NavbarSettings.java
new file mode 100644
index 0000000..8e8d187
--- /dev/null
+++ b/src/com/android/settings/slim/NavbarSettings.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2012-2015 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim;
+
+import android.os.Bundle;
+import android.preference.SwitchPreference;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.Preference.OnPreferenceChangeListener;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceScreen;
+import android.provider.Settings;
+
+import com.android.internal.util.slim.DeviceUtils;
+
+import com.android.settings.SettingsPreferenceFragment;
+import com.android.settings.R;
+
+public class NavbarSettings extends SettingsPreferenceFragment implements
+        OnPreferenceChangeListener {
+
+    private static final String TAG = "NavBar";
+    private static final String PREF_MENU_LOCATION = "pref_navbar_menu_location";
+    private static final String PREF_NAVBAR_MENU_DISPLAY = "pref_navbar_menu_display";
+    private static final String ENABLE_NAVIGATION_BAR = "enable_nav_bar";
+    private static final String PREF_BUTTON = "navbar_button_settings";
+    private static final String PREF_STYLE_DIMEN = "navbar_style_dimen_settings";
+    private static final String PREF_NAVIGATION_BAR_CAN_MOVE = "navbar_can_move";
+
+    private int mNavBarMenuDisplayValue;
+
+    ListPreference mMenuDisplayLocation;
+    ListPreference mNavBarMenuDisplay;
+    SwitchPreference mEnableNavigationBar;
+    SwitchPreference mNavigationBarCanMove;
+    PreferenceScreen mButtonPreference;
+    PreferenceScreen mStyleDimenPreference;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // Load the preferences from an XML resource
+        addPreferencesFromResource(R.xml.navbar_settings);
+
+        PreferenceScreen prefs = getPreferenceScreen();
+
+        mMenuDisplayLocation = (ListPreference) findPreference(PREF_MENU_LOCATION);
+        mMenuDisplayLocation.setValue(Settings.System.getInt(getActivity()
+                .getContentResolver(), Settings.System.MENU_LOCATION,
+                0) + "");
+        mMenuDisplayLocation.setOnPreferenceChangeListener(this);
+
+        mNavBarMenuDisplay = (ListPreference) findPreference(PREF_NAVBAR_MENU_DISPLAY);
+        mNavBarMenuDisplayValue = Settings.System.getInt(getActivity()
+                .getContentResolver(), Settings.System.MENU_VISIBILITY,
+                2);
+        mNavBarMenuDisplay.setValue(mNavBarMenuDisplayValue + "");
+        mNavBarMenuDisplay.setOnPreferenceChangeListener(this);
+
+        mButtonPreference = (PreferenceScreen) findPreference(PREF_BUTTON);
+        mStyleDimenPreference = (PreferenceScreen) findPreference(PREF_STYLE_DIMEN);
+
+        boolean hasNavBarByDefault = getResources().getBoolean(
+                com.android.internal.R.bool.config_showNavigationBar);
+        boolean enableNavigationBar = Settings.System.getInt(getContentResolver(),
+                Settings.System.NAVIGATION_BAR_SHOW, hasNavBarByDefault ? 1 : 0) == 1;
+        mEnableNavigationBar = (SwitchPreference) findPreference(ENABLE_NAVIGATION_BAR);
+        if (hasNavBarByDefault) {
+            getPreferenceScreen().removePreference(mEnableNavigationBar);
+        } else {
+            mEnableNavigationBar.setChecked(enableNavigationBar);
+            mEnableNavigationBar.setOnPreferenceChangeListener(this);
+        }
+        mNavigationBarCanMove = (SwitchPreference) findPreference(PREF_NAVIGATION_BAR_CAN_MOVE);
+        mNavigationBarCanMove.setChecked(Settings.System.getInt(getContentResolver(),
+                Settings.System.NAVIGATION_BAR_CAN_MOVE,
+                DeviceUtils.isPhone(getActivity()) ? 1 : 0) == 0);
+        mNavigationBarCanMove.setOnPreferenceChangeListener(this);
+
+        updateNavbarPreferences(enableNavigationBar);
+    }
+
+    @Override
+    protected int getMetricsCategory() {
+        return -1;
+    }
+
+    private void updateNavbarPreferences(boolean show) {
+        mNavBarMenuDisplay.setEnabled(show);
+        mButtonPreference.setEnabled(show);
+        mStyleDimenPreference.setEnabled(show);
+        mNavigationBarCanMove.setEnabled(show);
+        mMenuDisplayLocation.setEnabled(show
+            && mNavBarMenuDisplayValue != 1);
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (preference == mMenuDisplayLocation) {
+            Settings.System.putInt(getActivity().getContentResolver(),
+                    Settings.System.MENU_LOCATION, Integer.parseInt((String) newValue));
+            return true;
+        } else if (preference == mNavBarMenuDisplay) {
+            mNavBarMenuDisplayValue = Integer.parseInt((String) newValue);
+            Settings.System.putInt(getActivity().getContentResolver(),
+                    Settings.System.MENU_VISIBILITY, mNavBarMenuDisplayValue);
+            mMenuDisplayLocation.setEnabled(mNavBarMenuDisplayValue != 1);
+            return true;
+        } else if (preference == mEnableNavigationBar) {
+            Settings.System.putInt(getActivity().getContentResolver(),
+                    Settings.System.NAVIGATION_BAR_SHOW,
+                    ((Boolean) newValue) ? 1 : 0);
+            updateNavbarPreferences((Boolean) newValue);
+            return true;
+        } else if (preference == mNavigationBarCanMove) {
+            Settings.System.putInt(getActivity().getContentResolver(),
+                    Settings.System.NAVIGATION_BAR_CAN_MOVE,
+                    ((Boolean) newValue) ? 0 : 1);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+    }
+
+}
diff --git a/src/com/android/settings/slim/NavbarStyleDimenSettings.java b/src/com/android/settings/slim/NavbarStyleDimenSettings.java
new file mode 100644
index 0000000..5abb23c
--- /dev/null
+++ b/src/com/android/settings/slim/NavbarStyleDimenSettings.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2012-2015 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import android.os.PowerManager;
+import android.preference.CheckBoxPreference;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.Preference.OnPreferenceChangeListener;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceScreen;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+
+import com.android.internal.util.slim.DeviceUtils;
+
+import com.android.settings.SettingsPreferenceFragment;
+import com.android.settings.R;
+
+public class NavbarStyleDimenSettings extends SettingsPreferenceFragment implements
+        OnPreferenceChangeListener {
+
+    private static final String TAG =
+        "NavBarStyleDimen";
+    private static final String PREF_NAVIGATION_BAR_HEIGHT =
+        "navigation_bar_height";
+    private static final String PREF_NAVIGATION_BAR_HEIGHT_LANDSCAPE =
+        "navigation_bar_height_landscape";
+    private static final String PREF_NAVIGATION_BAR_WIDTH =
+        "navigation_bar_width";
+    private static final String KEY_DIMEN_OPTIONS =
+        "navbar_dimen";
+
+    private static final int MENU_RESET = Menu.FIRST;
+
+    ListPreference mNavigationBarHeight;
+    ListPreference mNavigationBarHeightLandscape;
+    ListPreference mNavigationBarWidth;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        // Load the preferences from an XML resource
+        addPreferencesFromResource(R.xml.navbar_style_dimen_settings);
+
+        mNavigationBarHeight =
+            (ListPreference) findPreference(PREF_NAVIGATION_BAR_HEIGHT);
+        mNavigationBarHeight.setOnPreferenceChangeListener(this);
+
+        mNavigationBarHeightLandscape =
+            (ListPreference) findPreference(PREF_NAVIGATION_BAR_HEIGHT_LANDSCAPE);
+        mNavigationBarHeightLandscape.setOnPreferenceChangeListener(this);
+
+        mNavigationBarWidth =
+            (ListPreference) findPreference(PREF_NAVIGATION_BAR_WIDTH);
+        mNavigationBarWidth.setOnPreferenceChangeListener(this);
+
+        boolean navbarCanMove = Settings.System.getInt(getContentResolver(),
+                Settings.System.NAVIGATION_BAR_CAN_MOVE,
+                DeviceUtils.isPhone(getActivity()) ? 1 : 0) == 1;
+
+        mNavigationBarHeightLandscape.setEnabled(!navbarCanMove);
+        mNavigationBarWidth.setEnabled(navbarCanMove);
+
+        setHasOptionsMenu(true);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        menu.add(0, MENU_RESET, 0, R.string.reset)
+                .setIcon(R.drawable.ic_settings_reset_button) // use the reset settings icon
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case MENU_RESET:
+                resetToDefault();
+                return true;
+             default:
+                return super.onContextItemSelected(item);
+        }
+    }
+
+    private void resetToDefault() {
+        AlertDialog.Builder alertDialog = new AlertDialog.Builder(getActivity());
+        alertDialog.setTitle(R.string.reset);
+        alertDialog.setMessage(R.string.navbar_dimensions_reset_message);
+        alertDialog.setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int id) {
+                int height = mapChosenDpToPixels(48);
+                Settings.System.putInt(getContentResolver(),
+                        Settings.System.NAVIGATION_BAR_HEIGHT_LANDSCAPE,
+                        48);
+                height = mapChosenDpToPixels(48);
+                Settings.System.putInt(getContentResolver(),
+                        Settings.System.NAVIGATION_BAR_HEIGHT,
+                        height);
+                height = mapChosenDpToPixels(42);
+                Settings.System.putInt(getContentResolver(),
+                        Settings.System.NAVIGATION_BAR_WIDTH,
+                        height);
+                mNavigationBarHeight.setValue("48");
+                mNavigationBarHeightLandscape.setValue("48");
+                mNavigationBarWidth.setValue("42");
+            }
+        });
+        alertDialog.setNegativeButton(R.string.cancel, null);
+        alertDialog.create().show();
+    }
+
+    @Override
+    protected int getMetricsCategory() {
+        return -1;
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (preference == mNavigationBarWidth) {
+            String newVal = (String) newValue;
+            int dp = Integer.parseInt(newVal);
+            int width = mapChosenDpToPixels(dp);
+            Settings.System.putInt(getContentResolver(), Settings.System.NAVIGATION_BAR_WIDTH,
+                    width);
+            return true;
+        } else if (preference == mNavigationBarHeight) {
+            String newVal = (String) newValue;
+            int dp = Integer.parseInt(newVal);
+            int height = mapChosenDpToPixels(dp);
+            Settings.System.putInt(getContentResolver(), Settings.System.NAVIGATION_BAR_HEIGHT,
+                    height);
+            return true;
+        } else if (preference == mNavigationBarHeightLandscape) {
+            String newVal = (String) newValue;
+            int dp = Integer.parseInt(newVal);
+            int height = mapChosenDpToPixels(dp);
+            Settings.System.putInt(getContentResolver(),
+                    Settings.System.NAVIGATION_BAR_HEIGHT_LANDSCAPE,
+                    height);
+            return true;
+        }
+        return false;
+    }
+
+    public int mapChosenDpToPixels(int dp) {
+        switch (dp) {
+            case 48:
+                return getResources().getDimensionPixelSize(R.dimen.navigation_bar_48);
+            case 44:
+                return getResources().getDimensionPixelSize(R.dimen.navigation_bar_44);
+            case 42:
+                return getResources().getDimensionPixelSize(R.dimen.navigation_bar_42);
+            case 40:
+                return getResources().getDimensionPixelSize(R.dimen.navigation_bar_40);
+            case 36:
+                return getResources().getDimensionPixelSize(R.dimen.navigation_bar_36);
+            case 30:
+                return getResources().getDimensionPixelSize(R.dimen.navigation_bar_30);
+            case 24:
+                return getResources().getDimensionPixelSize(R.dimen.navigation_bar_24);
+            case 0:
+                return 0;
+        }
+        return -1;
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+    }
+
+}
diff --git a/src/com/android/settings/slim/NavigationSettings.java b/src/com/android/settings/slim/NavigationSettings.java
new file mode 100644
index 0000000..42769ef
--- /dev/null
+++ b/src/com/android/settings/slim/NavigationSettings.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2013-2015 SlimRoms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.os.ServiceManager;
+import android.provider.Settings;
+import android.preference.Preference;
+import android.preference.PreferenceScreen;
+import android.view.IWindowManager;
+
+import com.android.settings.R;
+import com.android.settings.SettingsPreferenceFragment;
+
+public class NavigationSettings extends SettingsPreferenceFragment {
+
+    private static final String KEY_HARDWARE_KEYS = "hardwarekeys_settings";
+    private static final String KEY_PIE_SETTINGS = "pie_settings";
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        addPreferencesFromResource(R.xml.slim_navigation_settings);
+    }
+
+    @Override
+    protected int getMetricsCategory() {
+        return -Integer.MAX_VALUE + 1;
+    }
+}
diff --git a/src/com/android/settings/slim/dslv/ActionListViewSettings.java b/src/com/android/settings/slim/dslv/ActionListViewSettings.java
new file mode 100644
index 0000000..cff870b
--- /dev/null
+++ b/src/com/android/settings/slim/dslv/ActionListViewSettings.java
@@ -0,0 +1,989 @@
+/*
+ * Copyright (C) 2014 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim.dslv;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.app.DialogFragment;
+import android.content.DialogInterface;
+import android.app.Fragment;
+import android.app.FragmentManager;
+import android.app.ListFragment;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.content.SharedPreferences;
+import android.graphics.Bitmap;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Environment;
+import android.provider.MediaStore;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ArrayAdapter;
+import android.widget.BaseAdapter;
+import android.widget.ImageView;
+import android.widget.TextView;
+import android.widget.ListView;
+import android.widget.Toast;
+
+import com.android.internal.util.slim.ActionChecker;
+import com.android.internal.util.slim.ActionConfig;
+import com.android.internal.util.slim.ActionConstants;
+import com.android.internal.util.slim.ActionHelper;
+import com.android.internal.util.slim.ImageHelper;
+import com.android.internal.util.slim.DeviceUtils;
+import com.android.internal.util.slim.DeviceUtils.FilteredDeviceFeaturesArray;
+
+import com.android.settings.SettingsPreferenceFragment;
+import com.android.settings.R;
+import com.android.settings.slim.dslv.DragSortListView;
+import com.android.settings.slim.dslv.DragSortController;
+import com.android.settings.slim.util.ShortcutPickerHelper;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.List;
+import java.util.ArrayList;
+
+public class ActionListViewSettings extends ListFragment implements
+            ShortcutPickerHelper.OnPickListener {
+
+    private static final int DLG_SHOW_ACTION_DIALOG   = 0;
+    private static final int DLG_SHOW_ICON_PICKER     = 1;
+    private static final int DLG_DELETION_NOT_ALLOWED = 2;
+    private static final int DLG_SHOW_HELP_SCREEN     = 3;
+    private static final int DLG_RESET_TO_DEFAULT     = 4;
+
+    private static final int MENU_HELP = Menu.FIRST;
+    private static final int MENU_ADD = MENU_HELP + 1;
+    private static final int MENU_RESET = MENU_ADD + 1;
+
+    private static final int NAV_BAR               = 0;
+    private static final int PIE                   = 1;
+    private static final int PIE_SECOND            = 2;
+    private static final int NAV_RING              = 3;
+    private static final int LOCKSCREEN_SHORTCUT   = 4;
+    private static final int POWER_MENU_SHORTCUT   = 5;
+    private static final int SHAKE_EVENTS_DISABLED = 6;
+
+    private static final int DEFAULT_MAX_ACTION_NUMBER = 5;
+
+    public static final int REQUEST_PICK_CUSTOM_ICON = 1000;
+
+    private int mActionMode;
+    private int mMaxAllowedActions;
+    private boolean mUseAppPickerOnly;
+    private boolean mUseFullAppsOnly;
+    private boolean mDisableLongpress;
+    private boolean mDisableIconPicker;
+    private boolean mDisableDeleteLastEntry;
+
+    private TextView mDisableMessage;
+
+    private ActionConfigsAdapter mActionConfigsAdapter;
+
+    private ArrayList<ActionConfig> mActionConfigs;
+    private ActionConfig mActionConfig;
+
+    private boolean mAdditionalFragmentAttached;
+    private String mAdditionalFragment;
+    private View mDivider;
+
+    private int mPendingIndex = -1;
+    private boolean mPendingLongpress;
+    private boolean mPendingNewAction;
+
+    private String[] mActionDialogValues;
+    private String[] mActionDialogEntries;
+    private String mActionValuesKey;
+    private String mActionEntriesKey;
+
+    private Activity mActivity;
+    private ShortcutPickerHelper mPicker;
+
+    private File mImageTmp;
+
+    private DragSortListView.DropListener onDrop =
+        new DragSortListView.DropListener() {
+            @Override
+            public void drop(int from, int to) {
+                ActionConfig item = mActionConfigsAdapter.getItem(from);
+
+                mActionConfigsAdapter.remove(item);
+                mActionConfigsAdapter.insert(item, to);
+
+                setConfig(mActionConfigs, false);
+            }
+        };
+
+    private DragSortListView.RemoveListener onRemove =
+        new DragSortListView.RemoveListener() {
+            @Override
+            public void remove(int which) {
+                ActionConfig item = mActionConfigsAdapter.getItem(which);
+                mActionConfigsAdapter.remove(item);
+                if (!ActionChecker.containsAction(mActivity, item, ActionConstants.ACTION_BACK)
+                        || !ActionChecker.containsAction(
+                        mActivity, item, ActionConstants.ACTION_HOME)) {
+                    mActionConfigsAdapter.insert(item, which);
+                    showDialogInner(DLG_DELETION_NOT_ALLOWED, 0, false, false);
+                } else if (mDisableDeleteLastEntry && mActionConfigs.size() == 0) {
+                    mActionConfigsAdapter.add(item);
+                    showDialogInner(DLG_DELETION_NOT_ALLOWED, 0, false, false);
+                } else {
+                    setConfig(mActionConfigs, false);
+                    deleteIconFileIfPresent(item, true);
+                    if (mActionConfigs.size() == 0) {
+                        showDisableMessage(true);
+                    }
+                }
+            }
+        };
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+            Bundle savedInstanceState) {
+
+        return inflater.inflate(R.layout.action_list_view_main, container, false);
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        mActivity = activity;
+    }
+
+    @Override
+    public void onViewCreated(View view, Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        Resources res = getResources();
+
+        mActionMode = getArguments().getInt("actionMode", NAV_BAR);
+        mMaxAllowedActions = getArguments().getInt("maxAllowedActions", DEFAULT_MAX_ACTION_NUMBER);
+        mAdditionalFragment = getArguments().getString("fragment", null);
+        mActionValuesKey = getArguments().getString("actionValues", "shortcut_action_values");
+        mActionEntriesKey = getArguments().getString("actionEntries", "shortcut_action_entries");
+        mDisableLongpress = getArguments().getBoolean("disableLongpress", false);
+        mUseAppPickerOnly = getArguments().getBoolean("useAppPickerOnly", false);
+        mUseFullAppsOnly = getArguments().getBoolean("useOnlyFullAppPicker", false);
+        mDisableIconPicker = getArguments().getBoolean("disableIconPicker", false);
+        mDisableDeleteLastEntry = getArguments().getBoolean("disableDeleteLastEntry", false);
+
+        mDisableMessage = (TextView) view.findViewById(R.id.disable_message);
+
+        FilteredDeviceFeaturesArray finalActionDialogArray = new FilteredDeviceFeaturesArray();
+        finalActionDialogArray = DeviceUtils.filterUnsupportedDeviceFeatures(mActivity,
+            res.getStringArray(res.getIdentifier(
+                    mActionValuesKey, "array", "com.android.settings")),
+            res.getStringArray(res.getIdentifier(
+                    mActionEntriesKey, "array", "com.android.settings")));
+        mActionDialogValues = finalActionDialogArray.values;
+        mActionDialogEntries = finalActionDialogArray.entries;
+
+        mPicker = new ShortcutPickerHelper(mActivity, this);
+
+        File folder = new File(Environment.getExternalStorageDirectory() + File.separator +
+                ".slim" + File.separator + "icons");
+
+        mImageTmp = new File(folder.toString()
+                + File.separator + "shortcut.tmp");
+
+        DragSortListView listView = (DragSortListView) getListView();
+
+        listView.setDropListener(onDrop);
+        listView.setRemoveListener(onRemove);
+
+        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> arg0, View arg1, int arg2,
+                    long arg3) {
+                if (mUseFullAppsOnly) {
+                    if (mPicker != null) {
+                        mPendingIndex = arg2;
+                        mPendingLongpress = false;
+                        mPendingNewAction = false;
+                        mPicker.pickShortcut(getId(), true);
+                    }
+                } else if (!mUseAppPickerOnly) {
+                    showDialogInner(DLG_SHOW_ACTION_DIALOG, arg2, false, false);
+                } else {
+                    if (mPicker != null) {
+                        mPendingIndex = arg2;
+                        mPendingLongpress = false;
+                        mPendingNewAction = false;
+                        mPicker.pickShortcut(getId());
+                    }
+                }
+            }
+        });
+
+        if (!mDisableLongpress) {
+            listView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
+                @Override
+                public boolean onItemLongClick(AdapterView<?> arg0, View arg1, int arg2,
+                        long arg3) {
+                    if (mUseFullAppsOnly) {
+                        if (mPicker != null) {
+                            mPendingIndex = arg2;
+                            mPendingLongpress = true;
+                            mPendingNewAction = false;
+                            mPicker.pickShortcut(getId(), true);
+                        }
+                    } else if (!mUseAppPickerOnly) {
+                        showDialogInner(DLG_SHOW_ACTION_DIALOG, arg2, true, false);
+                    } else {
+                        if (mPicker != null) {
+                            mPendingIndex = arg2;
+                            mPendingLongpress = true;
+                            mPendingNewAction = false;
+                            mPicker.pickShortcut(getId());
+                        }
+                    }
+                    return true;
+                }
+            });
+        }
+
+        mActionConfigs = getConfig();
+
+        if (mActionConfigs != null) {
+            mActionConfigsAdapter = new ActionConfigsAdapter(mActivity, mActionConfigs);
+            setListAdapter(mActionConfigsAdapter);
+            showDisableMessage(mActionConfigs.size() == 0);
+        }
+
+        mDivider = (View) view.findViewById(R.id.divider);
+        loadAdditionalFragment();
+
+        // get shared preference
+        SharedPreferences preferences =
+                mActivity.getSharedPreferences("dslv_settings", Activity.MODE_PRIVATE);
+        if (!preferences.getBoolean("first_help_shown_mode_" + mActionMode, false)) {
+            preferences.edit()
+                    .putBoolean("first_help_shown_mode_" + mActionMode, true).commit();
+            showDialogInner(DLG_SHOW_HELP_SCREEN, 0, false, false);
+        }
+
+        setHasOptionsMenu(true);
+    }
+
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        if (mAdditionalFragmentAttached) {
+            FragmentManager fragmentManager = getFragmentManager();
+            Fragment fragment = fragmentManager.findFragmentById(R.id.fragment_container);
+            if (fragment != null && !fragmentManager.isDestroyed()) {
+                fragmentManager.beginTransaction().remove(fragment).commit();
+            }
+        }
+    }
+
+    private void loadAdditionalFragment() {
+        if (mAdditionalFragment != null && !mAdditionalFragment.isEmpty()) {
+            try {
+                Class<?> classAdditionalFragment = Class.forName(mAdditionalFragment);
+                Fragment fragment = (Fragment) classAdditionalFragment.newInstance();
+                getFragmentManager().beginTransaction()
+                    .replace(R.id.fragment_container, fragment).commit();
+                if (mDivider != null) {
+                    mDivider.setVisibility(View.VISIBLE);
+                }
+                mAdditionalFragmentAttached = true;
+            } catch (Exception e) {
+                mAdditionalFragmentAttached = false;
+                e.printStackTrace();
+            }
+        }
+    }
+
+    @Override
+    public void shortcutPicked(String action,
+                String description, Bitmap bmp, boolean isApplication) {
+        if (mPendingIndex == -1) {
+            return;
+        }
+        if (bmp != null && !mPendingLongpress) {
+            // Icon is present, save it for future use and add the file path to the action.
+            if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
+                File folder = new File(Environment.getExternalStorageDirectory() + File.separator +
+                        ".slim" + File.separator + "icons");
+                folder.mkdirs();
+                String fileName = folder.toString()
+                        + File.separator + "shortcut_" + System.currentTimeMillis() + ".png";
+                try {
+                    FileOutputStream out = new FileOutputStream(fileName);
+                    bmp.compress(Bitmap.CompressFormat.PNG, 100, out);
+                    out.close();
+                } catch (Exception e) {
+                    e.printStackTrace();
+                } finally {
+                    action = action + "?hasExtraIcon=" + fileName;
+                    File image = new File(fileName);
+                    image.setReadable(true, false);
+                }
+            }
+        }
+        if (mPendingNewAction) {
+            addNewAction(action, description);
+        } else {
+            updateAction(action, description, null, mPendingIndex, mPendingLongpress);
+        }
+        mPendingLongpress = false;
+        mPendingNewAction = false;
+        mPendingIndex = -1;
+    }
+
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (resultCode == Activity.RESULT_OK) {
+            if (requestCode == ShortcutPickerHelper.REQUEST_PICK_SHORTCUT
+                    || requestCode == ShortcutPickerHelper.REQUEST_PICK_APPLICATION
+                    || requestCode == ShortcutPickerHelper.REQUEST_CREATE_SHORTCUT) {
+                mPicker.onActivityResult(requestCode, resultCode, data);
+
+            } else if (requestCode == REQUEST_PICK_CUSTOM_ICON && mPendingIndex != -1) {
+                if (mImageTmp.length() == 0 || !mImageTmp.exists()) {
+                    mPendingIndex = -1;
+                    Toast.makeText(mActivity,
+                            getResources().getString(R.string.shortcut_image_not_valid),
+                            Toast.LENGTH_LONG).show();
+                    return;
+                }
+                if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
+                    File folder = new File(Environment.getExternalStorageDirectory() +
+                            File.separator + ".slim" + File.separator + "icons");
+                    folder.mkdirs();
+                    File image = new File(folder.toString() + File.separator
+                            + "shortcut_" + System.currentTimeMillis() + ".png");
+                    String path = image.getAbsolutePath();
+                    mImageTmp.renameTo(image);
+                    image.setReadable(true, false);
+                    updateAction(null, null, path, mPendingIndex, false);
+                    mPendingIndex = -1;
+                }
+            }
+        } else {
+            if (mImageTmp.exists()) {
+                mImageTmp.delete();
+            }
+            mPendingLongpress = false;
+            mPendingNewAction = false;
+            mPendingIndex = -1;
+        }
+        super.onActivityResult(requestCode, resultCode, data);
+    }
+
+    private void updateAction(String action, String description, String icon,
+                int which, boolean longpress) {
+
+        if (!longpress && checkForDuplicateMainNavActions(action)) {
+            return;
+        }
+
+        ActionConfig actionConfig = mActionConfigsAdapter.getItem(which);
+        mActionConfigsAdapter.remove(actionConfig);
+
+        if (!longpress) {
+            deleteIconFileIfPresent(actionConfig, false);
+        }
+
+        if (icon != null) {
+            actionConfig.setIcon(icon);
+        } else {
+            if (longpress) {
+                actionConfig.setLongpressAction(action);
+                actionConfig.setLongpressActionDescription(description);
+            } else {
+                deleteIconFileIfPresent(actionConfig, true);
+                actionConfig.setClickAction(action);
+                actionConfig.setClickActionDescription(description);
+                actionConfig.setIcon(ActionConstants.ICON_EMPTY);
+            }
+        }
+
+        mActionConfigsAdapter.insert(actionConfig, which);
+        showDisableMessage(false);
+        setConfig(mActionConfigs, false);
+    }
+
+    private boolean checkForDuplicateMainNavActions(String action) {
+        ActionConfig actionConfig;
+        for (int i = 0; i < mActionConfigs.size(); i++) {
+            actionConfig = mActionConfigsAdapter.getItem(i);
+            if (actionConfig.getClickAction().equals(action)) {
+                Toast.makeText(mActivity,
+                        getResources().getString(R.string.shortcut_duplicate_entry),
+                        Toast.LENGTH_LONG).show();
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private void deleteIconFileIfPresent(ActionConfig action, boolean deleteShortCutIcon) {
+        File oldImage = new File(action.getIcon());
+        if (oldImage.exists()) {
+            oldImage.delete();
+        }
+        oldImage = new File(action.getClickAction().replaceAll(".*?hasExtraIcon=", ""));
+        if (oldImage.exists() && deleteShortCutIcon) {
+            oldImage.delete();
+        }
+    }
+
+    private void showDisableMessage(boolean show) {
+        if (mDisableMessage == null || mDisableDeleteLastEntry) {
+            return;
+        }
+        if (show) {
+            mDisableMessage.setVisibility(View.VISIBLE);
+        } else {
+            mDisableMessage.setVisibility(View.GONE);
+        }
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case MENU_ADD:
+                if (mActionConfigs.size() == mMaxAllowedActions) {
+                    Toast.makeText(mActivity,
+                            getResources().getString(R.string.shortcut_action_max),
+                            Toast.LENGTH_LONG).show();
+                    break;
+                }
+                if (mUseFullAppsOnly) {
+                    if (mPicker != null) {
+                        mPendingIndex = 0;
+                        mPendingLongpress = false;
+                        mPendingNewAction = true;
+                        mPicker.pickShortcut(getId(), true);
+                    }
+                } else if (!mUseAppPickerOnly) {
+                    showDialogInner(DLG_SHOW_ACTION_DIALOG, 0, false, true);
+                } else {
+                    if (mPicker != null) {
+                        mPendingIndex = 0;
+                        mPendingLongpress = false;
+                        mPendingNewAction = true;
+                        mPicker.pickShortcut(getId());
+                    }
+                }
+                break;
+            case MENU_RESET:
+                    showDialogInner(DLG_RESET_TO_DEFAULT, 0, false, true);
+                break;
+            case MENU_HELP:
+                    showDialogInner(DLG_SHOW_HELP_SCREEN, 0, false, true);
+                break;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+        menu.add(0, MENU_HELP, 0, R.string.help)
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
+        menu.add(0, MENU_RESET, 0, R.string.shortcut_action_reset)
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
+        menu.add(0, MENU_ADD, 0, R.string.shortcut_action_add)
+                .setIcon(R.drawable.ic_menu_add_white)
+                .setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
+
+    }
+
+    private void addNewAction(String action, String description) {
+        if (checkForDuplicateMainNavActions(action)) {
+            return;
+        }
+        ActionConfig actionConfig = new ActionConfig(
+            action, description,
+            ActionConstants.ACTION_NULL, getResources().getString(R.string.shortcut_action_none),
+            ActionConstants.ICON_EMPTY);
+
+            mActionConfigsAdapter.add(actionConfig);
+            showDisableMessage(false);
+            setConfig(mActionConfigs, false);
+    }
+
+    private ArrayList<ActionConfig> getConfig() {
+        switch (mActionMode) {
+            case NAV_BAR:
+                return ActionHelper.getNavBarConfigWithDescription(
+                    mActivity, mActionValuesKey, mActionEntriesKey);
+/* Disabled for now till all features are back. Enable it step per step!!!!!!
+            case LOCKSCREEN_SHORTCUT:
+                return ActionHelper.getLockscreenShortcutConfig(mActivity);
+            case NAV_RING:
+                return ActionHelper.getNavRingConfigWithDescription(
+                    mActivity, mActionValuesKey, mActionEntriesKey);
+            case PIE:
+                return ActionHelper.getPieConfigWithDescription(
+                    mActivity, mActionValuesKey, mActionEntriesKey);
+            case PIE_SECOND:
+                return ActionHelper.getPieSecondLayerConfigWithDescription(
+                    mActivity, mActionValuesKey, mActionEntriesKey);
+            case POWER_MENU_SHORTCUT:
+                return PolicyHelper.getPowerMenuConfigWithDescription(
+                    mActivity, mActionValuesKey, mActionEntriesKey);
+            case SHAKE_EVENTS_DISABLED:
+                return ActionHelper.getDisabledShakeApps(mActivity);
+*/
+        }
+        return null;
+    }
+
+    private void setConfig(ArrayList<ActionConfig> actionConfigs, boolean reset) {
+        switch (mActionMode) {
+            case NAV_BAR:
+                ActionHelper.setNavBarConfig(mActivity, actionConfigs, reset);
+                break;
+/* Disabled for now till all features are back. Enable it step per step!!!!!!
+            case LOCKSCREEN_SHORTCUT:
+                ActionHelper.setLockscreenShortcutConfig(mActivity, actionConfigs, reset);
+                break;
+            case NAV_RING:
+                ActionHelper.setNavRingConfig(mActivity, actionConfigs, reset);
+                break;
+            case PIE:
+                ActionHelper.setPieConfig(mActivity, actionConfigs, reset);
+                break;
+            case PIE_SECOND:
+                ActionHelper.setPieSecondLayerConfig(mActivity, actionConfigs, reset);
+                break;
+            case POWER_MENU_SHORTCUT:
+                PolicyHelper.setPowerMenuConfig(mActivity, actionConfigs, reset);
+                break;
+            case SHAKE_EVENTS_DISABLED:
+                ActionHelper.setDisabledShakeApps(mActivity, actionConfigs, reset);
+                break;
+*/
+        }
+    }
+
+    private class ViewHolder {
+        public TextView longpressActionDescriptionView;
+        public ImageView iconView;
+    }
+
+    private class ActionConfigsAdapter extends ArrayAdapter<ActionConfig> {
+
+        public ActionConfigsAdapter(Context context, List<ActionConfig> clickActionDescriptions) {
+            super(context, R.layout.action_list_view_item,
+                    R.id.click_action_description, clickActionDescriptions);
+        }
+
+        public View getView(final int position, View convertView, ViewGroup parent) {
+            View v = super.getView(position, convertView, parent);
+
+            if (v != convertView && v != null) {
+                ViewHolder holder = new ViewHolder();
+
+                TextView longpressActionDecription =
+                    (TextView) v.findViewById(R.id.longpress_action_description);
+                ImageView icon = (ImageView) v.findViewById(R.id.icon);
+
+                if (mDisableLongpress) {
+                    longpressActionDecription.setVisibility(View.GONE);
+                } else {
+                    holder.longpressActionDescriptionView = longpressActionDecription;
+                }
+
+                holder.iconView = icon;
+
+                v.setTag(holder);
+            }
+
+            ViewHolder holder = (ViewHolder) v.getTag();
+
+            if (!mDisableLongpress) {
+                holder.longpressActionDescriptionView.setText(
+                    getResources().getString(R.string.shortcut_action_longpress)
+                    + " " + getItem(position).getLongpressActionDescription());
+            }
+
+            Drawable d = null;
+            String iconUri = getItem(position).getIcon();
+            if (mActionMode == POWER_MENU_SHORTCUT) {
+/* Disabled for now till slims power menu is back!!!!!!!!!!!!!!
+                d = ImageHelper.resize(
+                        mActivity, PolicyHelper.getPowerMenuIconImage(mActivity,
+                        getItem(position).getClickAction(),
+                        iconUri, false), 36); */
+            } else {
+                d = ImageHelper.resize(
+                        mActivity, ActionHelper.getActionIconImage(mActivity,
+                        getItem(position).getClickAction(),
+                        iconUri), 36);
+            }
+
+            if ((iconUri.equals(ActionConstants.ICON_EMPTY) &&
+                    getItem(position).getClickAction().startsWith("**")) || (iconUri != null
+                    && iconUri.startsWith(ActionConstants.SYSTEM_ICON_IDENTIFIER))) {
+                if (d != null) d.setTint(getResources().getColor(R.color.dslv_icon_dark));
+            }
+            holder.iconView.setImageDrawable(d);
+
+            if (!mDisableIconPicker && holder.iconView.getDrawable() != null) {
+                holder.iconView.setOnClickListener(new OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        mPendingIndex = position;
+                        showDialogInner(DLG_SHOW_ICON_PICKER, 0, false, false);
+                    }
+                });
+            }
+
+            return v;
+        }
+    }
+
+    private void showDialogInner(int id, int which, boolean longpress, boolean newAction) {
+        DialogFragment newFragment =
+            MyAlertDialogFragment.newInstance(id, which, longpress, newAction);
+        newFragment.setTargetFragment(this, 0);
+        newFragment.show(getFragmentManager(), "dialog " + id);
+    }
+
+    public static class MyAlertDialogFragment extends DialogFragment {
+
+        public static MyAlertDialogFragment newInstance(int id,
+                int which, boolean longpress, boolean newAction) {
+            MyAlertDialogFragment frag = new MyAlertDialogFragment();
+            Bundle args = new Bundle();
+            args.putInt("id", id);
+            args.putInt("which", which);
+            args.putBoolean("longpress", longpress);
+            args.putBoolean("newAction", newAction);
+            frag.setArguments(args);
+            return frag;
+        }
+
+        ActionListViewSettings getOwner() {
+            return (ActionListViewSettings) getTargetFragment();
+        }
+
+        @Override
+        public Dialog onCreateDialog(Bundle savedInstanceState) {
+            int id = getArguments().getInt("id");
+            final int which = getArguments().getInt("which");
+            final boolean longpress = getArguments().getBoolean("longpress");
+            final boolean newAction = getArguments().getBoolean("newAction");
+            switch (id) {
+                case DLG_RESET_TO_DEFAULT:
+                    return new AlertDialog.Builder(getActivity())
+                    .setTitle(R.string.shortcut_action_reset)
+                    .setMessage(R.string.reset_message)
+                    .setNegativeButton(R.string.cancel, null)
+                    .setPositiveButton(R.string.dlg_ok,
+                        new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            // first delete custom icons in case they exist
+                            ArrayList<ActionConfig> actionConfigs = getOwner().getConfig();
+                            for (int i = 0; i < actionConfigs.size(); i++) {
+                                getOwner().deleteIconFileIfPresent(actionConfigs.get(i), true);
+                            }
+
+                            // reset provider values and action adapter to default
+                            getOwner().setConfig(null, true);
+                            getOwner().mActionConfigsAdapter.clear();
+
+                            // Add the new default objects fetched from @getConfig()
+                            actionConfigs = getOwner().getConfig();
+                            final int newConfigsSize = actionConfigs.size();
+                            for (int i = 0; i < newConfigsSize; i++) {
+                                getOwner().mActionConfigsAdapter.add(actionConfigs.get(i));
+                            }
+
+                            // dirty helper if actionConfigs list has no entries
+                            // to proper update the content. .notifyDatSetChanged()
+                            // does not work in this case.
+                            if (newConfigsSize == 0) {
+                                ActionConfig emptyAction =
+                                    new ActionConfig(null, null, null, null, null);
+                                getOwner().mActionConfigsAdapter.add(emptyAction);
+                                getOwner().mActionConfigsAdapter.remove(emptyAction);
+                            }
+                            getOwner().showDisableMessage(newConfigsSize == 0);
+                        }
+                    })
+                    .create();
+                case DLG_SHOW_HELP_SCREEN:
+                    Resources res = getResources();
+                    String finalHelpMessage;
+                    String actionMode;
+                    String icon = "";
+                    switch (getOwner().mActionMode) {
+                        case LOCKSCREEN_SHORTCUT:
+                        case POWER_MENU_SHORTCUT:
+                            actionMode = res.getString(R.string.shortcut_action_help_shortcut);
+                            break;
+                        case SHAKE_EVENTS_DISABLED:
+                            actionMode = res.getString(R.string.shortcut_action_help_app);
+                            break;
+                        case NAV_BAR:
+                        case NAV_RING:
+                        case PIE:
+                        case PIE_SECOND:
+                        default:
+                            actionMode = res.getString(R.string.shortcut_action_help_button);
+                            break;
+                    }
+                    if (!getOwner().mDisableIconPicker) {
+                        icon = res.getString(R.string.shortcut_action_help_icon);
+                    }
+                    finalHelpMessage = res.getString(
+                        R.string.shortcut_action_help_main, actionMode, icon);
+                    if (!getOwner().mDisableDeleteLastEntry) {
+                        finalHelpMessage += " " + res.getString(
+                                getOwner().mActionMode == PIE_SECOND
+                                ? R.string.shortcut_action_help_pie_second_layer_delete_last_entry
+                                : R.string.shortcut_action_help_delete_last_entry, actionMode);
+                    }
+                    return new AlertDialog.Builder(getActivity())
+                    .setTitle(R.string.help_label)
+                    .setMessage(finalHelpMessage)
+                    .setNegativeButton(R.string.dlg_ok,
+                        new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            dialog.cancel();
+                        }
+                    })
+                    .create();
+                case DLG_DELETION_NOT_ALLOWED:
+                    int message;
+                    if (getOwner().mActionConfigs.size() > 1) {
+                        message = R.string.shortcut_action_required_warning_message;
+                    } else {
+                        message = R.string.shortcut_action_warning_message;
+                    }
+                    return new AlertDialog.Builder(getActivity())
+                    .setTitle(R.string.shortcut_action_warning)
+                    .setMessage(message)
+                    .setNegativeButton(R.string.dlg_ok,
+                        new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            dialog.cancel();
+                        }
+                    })
+                    .create();
+                case DLG_SHOW_ACTION_DIALOG:
+                    int title;
+                    if (longpress) {
+                        title = R.string.shortcut_action_select_action_longpress;
+                    } else if (newAction) {
+                        title = R.string.shortcut_action_select_action_newaction;
+                    } else {
+                        title = R.string.shortcut_action_select_action;
+                    }
+
+                    // for normal press action we filter out null value
+                    // due it does not make sense to set a null action
+                    // on normal press action
+                    String[] values = null;
+                    String[] entries = null;
+                    if (!longpress) {
+                        List<String> finalEntriesList = new ArrayList<String>();
+                        List<String> finalValuesList = new ArrayList<String>();
+
+                        for (int i = 0; i < getOwner().mActionDialogValues.length; i++) {
+                            if (!getOwner().mActionDialogValues[i]
+                                    .equals(ActionConstants.ACTION_NULL)) {
+                                finalEntriesList.add(getOwner().mActionDialogEntries[i]);
+                                finalValuesList.add(getOwner().mActionDialogValues[i]);
+                            }
+                        }
+
+                        entries = finalEntriesList.toArray(new String[finalEntriesList.size()]);
+                        values = finalValuesList.toArray(new String[finalValuesList.size()]);
+                    }
+
+                    final String[] finalDialogValues =
+                        longpress ? getOwner().mActionDialogValues : values;
+                    final String[] finalDialogEntries =
+                        longpress ? getOwner().mActionDialogEntries : entries;
+
+                    return new AlertDialog.Builder(getActivity())
+                    .setTitle(title)
+                    .setNegativeButton(R.string.cancel, null)
+                    .setItems(finalDialogEntries,
+                        new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int item) {
+                            if (finalDialogValues[item].equals(ActionConstants.ACTION_APP)) {
+                                if (getOwner().mPicker != null) {
+                                    getOwner().mPendingIndex = which;
+                                    getOwner().mPendingLongpress = longpress;
+                                    getOwner().mPendingNewAction = newAction;
+                                    getOwner().mPicker.pickShortcut(getOwner().getId());
+                                }
+                            } else {
+                                if (newAction) {
+                                    getOwner().addNewAction(finalDialogValues[item],
+                                            finalDialogEntries[item]);
+                                } else {
+                                    getOwner().updateAction(finalDialogValues[item],
+                                            finalDialogEntries[item],
+                                            null, which, longpress);
+                                }
+                            }
+                        }
+                    })
+                    .create();
+                case DLG_SHOW_ICON_PICKER:
+                    return new AlertDialog.Builder(getActivity())
+                    .setTitle(R.string.shortcuts_icon_picker_type)
+                    .setNegativeButton(R.string.cancel, null)
+                    .setItems(R.array.icon_types,
+                        new DialogInterface.OnClickListener() {
+                        public void onClick(DialogInterface dialog, int which) {
+                            switch(which) {
+                                case 0: // Default
+                                    getOwner().updateAction(null, null,
+                                        ActionConstants.ICON_EMPTY,
+                                        getOwner().mPendingIndex, false);
+                                    getOwner().mPendingIndex = -1;
+                                    break;
+                                case 1: // System defaults
+                                    ListView list = new ListView(getActivity());
+                                    list.setAdapter(new IconAdapter());
+                                    final Dialog holoDialog = new Dialog(getActivity());
+                                    holoDialog.setTitle(
+                                            R.string.shortcuts_icon_picker_choose_icon_title);
+                                    holoDialog.setContentView(list);
+                                    list.setOnItemClickListener(new OnItemClickListener() {
+                                        @Override
+                                        public void onItemClick(AdapterView<?> parent, View view,
+                                                int position, long id) {
+                                            IconAdapter adapter = (IconAdapter) parent.getAdapter();
+                                            getOwner().updateAction(null, null,
+                                                adapter.getItemReference(position),
+                                                getOwner().mPendingIndex, false);
+                                            getOwner().mPendingIndex = -1;
+                                            holoDialog.cancel();
+                                        }
+                                    });
+                                    holoDialog.show();
+                                    break;
+                                case 2: // Custom user icon
+                                    Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null);
+                                    intent.setType("image/*");
+                                    intent.putExtra("crop", "true");
+                                    intent.putExtra("scale", true);
+                                    intent.putExtra("outputFormat",
+                                        Bitmap.CompressFormat.PNG.toString());
+                                    intent.putExtra("aspectX", 100);
+                                    intent.putExtra("aspectY", 100);
+                                    intent.putExtra("outputX", 100);
+                                    intent.putExtra("outputY", 100);
+                                    try {
+                                        getOwner().mImageTmp.createNewFile();
+                                        getOwner().mImageTmp.setWritable(true, false);
+                                        intent.putExtra(MediaStore.EXTRA_OUTPUT,
+                                            Uri.fromFile(getOwner().mImageTmp));
+                                        intent.putExtra("return-data", false);
+                                        getOwner().startActivityForResult(
+                                            intent, REQUEST_PICK_CUSTOM_ICON);
+                                    } catch (IOException e) {
+                                        e.printStackTrace();
+                                    } catch (ActivityNotFoundException e) {
+                                        e.printStackTrace();
+                                    }
+                                    break;
+                            }
+                        }
+                    })
+                    .create();
+            }
+            throw new IllegalArgumentException("unknown id " + id);
+        }
+
+        @Override
+        public void onCancel(DialogInterface dialog) {
+
+        }
+
+        public class IconAdapter extends BaseAdapter {
+
+            TypedArray icons;
+            String[] labels;
+            int color;
+
+            public IconAdapter() {
+                labels = getResources().getStringArray(R.array.shortcut_icon_picker_labels);
+                icons = getResources().obtainTypedArray(R.array.shortcut_icon_picker_icons);
+                color = getResources().getColor(R.color.dslv_icon_dark);
+            }
+
+            @Override
+            public Object getItem(int position) {
+                return icons.getDrawable(position);
+            }
+
+            @Override
+            public long getItemId(int position) {
+                return 0;
+            }
+
+            @Override
+            public int getCount() {
+                return labels.length;
+            }
+
+            public String getItemReference(int position) {
+                String name = icons.getString(position);
+                int separatorIndex = name.lastIndexOf(File.separator);
+                int periodIndex = name.lastIndexOf('.');
+                return ActionConstants.SYSTEM_ICON_IDENTIFIER
+                    + name.substring(separatorIndex + 1, periodIndex);
+            }
+
+            @Override
+            public View getView(int position, View convertView, ViewGroup parent) {
+                View iView = convertView;
+                if (convertView == null) {
+                    iView = View.inflate(getActivity(), android.R.layout.simple_list_item_1, null);
+                }
+                TextView tt = (TextView) iView.findViewById(android.R.id.text1);
+                tt.setText(labels[position]);
+                Drawable ic = ((Drawable) getItem(position)).mutate();
+                ic.setTint(color);
+                tt.setCompoundDrawablePadding(15);
+                tt.setCompoundDrawablesWithIntrinsicBounds(ic, null, null, null);
+                return iView;
+            }
+        }
+
+    }
+
+}
diff --git a/src/com/android/settings/slim/dslv/DragSortController.java b/src/com/android/settings/slim/dslv/DragSortController.java
new file mode 100644
index 0000000..04cabe1
--- /dev/null
+++ b/src/com/android/settings/slim/dslv/DragSortController.java
@@ -0,0 +1,488 @@
+/*
+ * Copyright 2012 Carl Bauer
+ * Copyright (C) 2014 SlimRoms Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim.dslv;
+
+import android.graphics.Point;
+import android.view.GestureDetector;
+import android.view.HapticFeedbackConstants;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.widget.AdapterView;
+
+/**
+ * Class that starts and stops item drags on a {@link DragSortListView}
+ * based on touch gestures. This class also inherits from
+ * {@link SimpleFloatViewManager}, which provides basic float View
+ * creation.
+ *
+ * An instance of this class is meant to be passed to the methods
+ * {@link DragSortListView#setTouchListener()} and
+ * {@link DragSortListView#setFloatViewManager()} of your
+ * {@link DragSortListView} instance.
+ */
+public class DragSortController extends SimpleFloatViewManager
+        implements View.OnTouchListener, GestureDetector.OnGestureListener {
+
+    /**
+     * Drag init mode enum.
+     */
+    public static final int ON_DOWN = 0;
+    public static final int ON_DRAG = 1;
+    public static final int ON_LONG_PRESS = 2;
+
+    private int mDragInitMode = ON_DOWN;
+
+    private boolean mSortEnabled = true;
+
+    /**
+     * Remove mode enum.
+     */
+    public static final int CLICK_REMOVE = 0;
+    public static final int FLING_REMOVE = 1;
+
+    /**
+     * The current remove mode.
+     */
+    private int mRemoveMode;
+
+    private boolean mRemoveEnabled = false;
+    private boolean mIsRemoving = false;
+
+    private GestureDetector mDetector;
+
+    private GestureDetector mFlingRemoveDetector;
+
+    private int mTouchSlop;
+
+    public static final int MISS = -1;
+
+    private int mHitPos = MISS;
+    private int mFlingHitPos = MISS;
+
+    private int mClickRemoveHitPos = MISS;
+
+    private int[] mTempLoc = new int[2];
+
+    private int mItemX;
+    private int mItemY;
+
+    private int mCurrX;
+    private int mCurrY;
+
+    private boolean mDragging = false;
+
+    private float mFlingSpeed = 500f;
+
+    private int mDragHandleId;
+
+    private int mClickRemoveId;
+
+    private int mFlingHandleId;
+    private boolean mCanDrag;
+
+    private DragSortListView mDslv;
+    private int mPositionX;
+
+    /**
+     * Calls {@link #DragSortController(DragSortListView, int)} with a
+     * 0 drag handle id, FLING_RIGHT_REMOVE remove mode,
+     * and ON_DOWN drag init. By default, sorting is enabled, and
+     * removal is disabled.
+     *
+     * @param dslv The DSLV instance
+     */
+    public DragSortController(DragSortListView dslv) {
+        this(dslv, 0, ON_DOWN, FLING_REMOVE);
+    }
+
+    public DragSortController(DragSortListView dslv,
+            int dragHandleId, int dragInitMode, int removeMode) {
+        this(dslv, dragHandleId, dragInitMode, removeMode, 0);
+    }
+
+    public DragSortController(DragSortListView dslv, int dragHandleId,
+            int dragInitMode, int removeMode, int clickRemoveId) {
+        this(dslv, dragHandleId, dragInitMode, removeMode, clickRemoveId, 0);
+    }
+
+    /**
+     * By default, sorting is enabled, and removal is disabled.
+     *
+     * @param dslv The DSLV instance
+     * @param dragHandleId The resource id of the View that represents
+     * the drag handle in a list item.
+     */
+    public DragSortController(DragSortListView dslv, int dragHandleId, int dragInitMode,
+            int removeMode, int clickRemoveId, int flingHandleId) {
+        super(dslv);
+        mDslv = dslv;
+        mDetector = new GestureDetector(dslv.getContext(), this);
+        mFlingRemoveDetector = new GestureDetector(dslv.getContext(), mFlingRemoveListener);
+        mFlingRemoveDetector.setIsLongpressEnabled(false);
+        mTouchSlop = ViewConfiguration.get(dslv.getContext()).getScaledTouchSlop();
+        mDragHandleId = dragHandleId;
+        mClickRemoveId = clickRemoveId;
+        mFlingHandleId = flingHandleId;
+        setRemoveMode(removeMode);
+        setDragInitMode(dragInitMode);
+    }
+
+
+    public int getDragInitMode() {
+        return mDragInitMode;
+    }
+
+    /**
+     * Set how a drag is initiated. Needs to be one of
+     * {@link ON_DOWN}, {@link ON_DRAG}, or {@link ON_LONG_PRESS}.
+     *
+     * @param mode The drag init mode.
+     */
+    public void setDragInitMode(int mode) {
+        mDragInitMode = mode;
+    }
+
+    /**
+     * Enable/Disable list item sorting. Disabling is useful if only item
+     * removal is desired. Prevents drags in the vertical direction.
+     *
+     * @param enabled Set <code>true</code> to enable list
+     * item sorting.
+     */
+    public void setSortEnabled(boolean enabled) {
+        mSortEnabled = enabled;
+    }
+
+    public boolean isSortEnabled() {
+        return mSortEnabled;
+    }
+
+    /**
+     * One of {@link CLICK_REMOVE}, {@link FLING_RIGHT_REMOVE},
+     * {@link FLING_LEFT_REMOVE},
+     * {@link SLIDE_RIGHT_REMOVE}, or {@link SLIDE_LEFT_REMOVE}.
+     */
+    public void setRemoveMode(int mode) {
+        mRemoveMode = mode;
+    }
+
+    public int getRemoveMode() {
+        return mRemoveMode;
+    }
+
+    /**
+     * Enable/Disable item removal without affecting remove mode.
+     */
+    public void setRemoveEnabled(boolean enabled) {
+        mRemoveEnabled = enabled;
+    }
+
+    public boolean isRemoveEnabled() {
+        return mRemoveEnabled;
+    }
+
+    /**
+     * Set the resource id for the View that represents the drag
+     * handle in a list item.
+     *
+     * @param id An android resource id.
+     */
+    public void setDragHandleId(int id) {
+        mDragHandleId = id;
+    }
+
+    /**
+     * Set the resource id for the View that represents the fling
+     * handle in a list item.
+     *
+     * @param id An android resource id.
+     */
+    public void setFlingHandleId(int id) {
+        mFlingHandleId = id;
+    }
+
+    /**
+     * Set the resource id for the View that represents click
+     * removal button.
+     *
+     * @param id An android resource id.
+     */
+    public void setClickRemoveId(int id) {
+        mClickRemoveId = id;
+    }
+
+    /**
+     * Sets flags to restrict certain motions of the floating View
+     * based on DragSortController settings (such as remove mode).
+     * Starts the drag on the DragSortListView.
+     *
+     * @param position The list item position (includes headers).
+     * @param deltaX Touch x-coord minus left edge of floating View.
+     * @param deltaY Touch y-coord minus top edge of floating View.
+     *
+     * @return True if drag started, false otherwise.
+     */
+    public boolean startDrag(int position, int deltaX, int deltaY) {
+
+        int dragFlags = 0;
+        if (mSortEnabled && !mIsRemoving) {
+            dragFlags |= DragSortListView.DRAG_POS_Y | DragSortListView.DRAG_NEG_Y;
+        }
+        if (mRemoveEnabled && mIsRemoving) {
+            dragFlags |= DragSortListView.DRAG_POS_X;
+            dragFlags |= DragSortListView.DRAG_NEG_X;
+        }
+
+        mDragging = mDslv.startDrag(position - mDslv.getHeaderViewsCount(), dragFlags, deltaX,
+                deltaY);
+        return mDragging;
+    }
+
+    @Override
+    public boolean onTouch(View v, MotionEvent ev) {
+        if (!mDslv.isDragEnabled() || mDslv.listViewIntercepted()) {
+            return false;
+        }
+
+        mDetector.onTouchEvent(ev);
+        if (mRemoveEnabled && mDragging && mRemoveMode == FLING_REMOVE) {
+            mFlingRemoveDetector.onTouchEvent(ev);
+        }
+
+        int action = ev.getAction() & MotionEvent.ACTION_MASK;
+        switch (action) {
+            case MotionEvent.ACTION_DOWN:
+                mCurrX = (int) ev.getX();
+                mCurrY = (int) ev.getY();
+                break;
+            case MotionEvent.ACTION_UP:
+                if (mRemoveEnabled && mIsRemoving) {
+                    int x = mPositionX >= 0 ? mPositionX : -mPositionX;
+                    int removePoint = mDslv.getWidth() / 2;
+                    if (x > removePoint) {
+                        mDslv.stopDragWithVelocity(true, 0);
+                    }
+                }
+            case MotionEvent.ACTION_CANCEL:
+                mIsRemoving = false;
+                mDragging = false;
+                break;
+        }
+
+        return false;
+    }
+
+    /**
+     * Overrides to provide fading when slide removal is enabled.
+     */
+    @Override
+    public void onDragFloatView(View floatView, Point position, Point touch) {
+
+        if (mRemoveEnabled && mIsRemoving) {
+            mPositionX = position.x;
+        }
+    }
+
+    /**
+     * Get the position to start dragging based on the ACTION_DOWN
+     * MotionEvent. This function simply calls
+     * {@link #dragHandleHitPosition(MotionEvent)}. Override
+     * to change drag handle behavior;
+     * this function is called internally when an ACTION_DOWN
+     * event is detected.
+     *
+     * @param ev The ACTION_DOWN MotionEvent.
+     *
+     * @return The list position to drag if a drag-init gesture is
+     * detected; MISS if unsuccessful.
+     */
+    public int startDragPosition(MotionEvent ev) {
+        return dragHandleHitPosition(ev);
+    }
+
+    public int startFlingPosition(MotionEvent ev) {
+        return mRemoveMode == FLING_REMOVE ? flingHandleHitPosition(ev) : MISS;
+    }
+
+    /**
+     * Checks for the touch of an item's drag handle (specified by
+     * {@link #setDragHandleId(int)}), and returns that item's position
+     * if a drag handle touch was detected.
+     *
+     * @param ev The ACTION_DOWN MotionEvent.
+
+     * @return The list position of the item whose drag handle was
+     * touched; MISS if unsuccessful.
+     */
+    public int dragHandleHitPosition(MotionEvent ev) {
+        return viewIdHitPosition(ev, mDragHandleId);
+    }
+
+    public int flingHandleHitPosition(MotionEvent ev) {
+        return viewIdHitPosition(ev, mFlingHandleId);
+    }
+
+    public int viewIdHitPosition(MotionEvent ev, int id) {
+        final int x = (int) ev.getX();
+        final int y = (int) ev.getY();
+
+        int touchPos = mDslv.pointToPosition(x, y); // includes headers/footers
+
+        final int numHeaders = mDslv.getHeaderViewsCount();
+        final int numFooters = mDslv.getFooterViewsCount();
+        final int count = mDslv.getCount();
+
+        // Log.d("mobeta", "touch down on position " + itemnum);
+        // We're only interested if the touch was on an
+        // item that's not a header or footer.
+        if (touchPos != AdapterView.INVALID_POSITION && touchPos >= numHeaders
+                && touchPos < (count - numFooters)) {
+            final View item = mDslv.getChildAt(touchPos - mDslv.getFirstVisiblePosition());
+            final int rawX = (int) ev.getRawX();
+            final int rawY = (int) ev.getRawY();
+
+            View dragBox = id == 0 ? item : (View) item.findViewById(id);
+            if (dragBox != null) {
+                dragBox.getLocationOnScreen(mTempLoc);
+
+                if (rawX > mTempLoc[0] && rawY > mTempLoc[1] &&
+                        rawX < mTempLoc[0] + dragBox.getWidth() &&
+                        rawY < mTempLoc[1] + dragBox.getHeight()) {
+
+                    mItemX = item.getLeft();
+                    mItemY = item.getTop();
+
+                    return touchPos;
+                }
+            }
+        }
+
+        return MISS;
+    }
+
+    @Override
+    public boolean onDown(MotionEvent ev) {
+        if (mRemoveEnabled && mRemoveMode == CLICK_REMOVE) {
+            mClickRemoveHitPos = viewIdHitPosition(ev, mClickRemoveId);
+        }
+
+        mHitPos = startDragPosition(ev);
+        if (mHitPos != MISS && mDragInitMode == ON_DOWN) {
+            startDrag(mHitPos, (int) ev.getX() - mItemX, (int) ev.getY() - mItemY);
+        }
+
+        mIsRemoving = false;
+        mCanDrag = true;
+        mPositionX = 0;
+        mFlingHitPos = startFlingPosition(ev);
+
+        return true;
+    }
+
+    @Override
+    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
+
+        final int x1 = (int) e1.getX();
+        final int y1 = (int) e1.getY();
+        final int x2 = (int) e2.getX();
+        final int y2 = (int) e2.getY();
+        final int deltaX = x2 - mItemX;
+        final int deltaY = y2 - mItemY;
+
+        if (mCanDrag && !mDragging && (mHitPos != MISS || mFlingHitPos != MISS)) {
+            if (mHitPos != MISS) {
+                if (mDragInitMode == ON_DRAG && Math.abs(y2 - y1) > mTouchSlop && mSortEnabled) {
+                    startDrag(mHitPos, deltaX, deltaY);
+                } else if (mDragInitMode != ON_DOWN
+                        && Math.abs(x2 - x1) > mTouchSlop && mRemoveEnabled) {
+                    mIsRemoving = true;
+                    startDrag(mFlingHitPos, deltaX, deltaY);
+                }
+            } else if (mFlingHitPos != MISS) {
+                if (Math.abs(x2 - x1) > mTouchSlop && mRemoveEnabled) {
+                    mIsRemoving = true;
+                    startDrag(mFlingHitPos, deltaX, deltaY);
+                } else if (Math.abs(y2 - y1) > mTouchSlop) {
+                    mCanDrag = false; // if started to scroll the list then
+                                      // don't allow sorting nor fling-removing
+                }
+            }
+        }
+        // return whatever
+        return false;
+    }
+
+    @Override
+    public void onLongPress(MotionEvent e) {
+        // Log.d("mobeta", "lift listener long pressed");
+        if (mHitPos != MISS && mDragInitMode == ON_LONG_PRESS) {
+            mDslv.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
+            startDrag(mHitPos, mCurrX - mItemX, mCurrY - mItemY);
+        }
+    }
+
+    // complete the OnGestureListener interface
+    @Override
+    public final boolean onFling(MotionEvent e1,
+            MotionEvent e2, float velocityX, float velocityY) {
+        return false;
+    }
+
+    // complete the OnGestureListener interface
+    @Override
+    public boolean onSingleTapUp(MotionEvent ev) {
+        if (mRemoveEnabled && mRemoveMode == CLICK_REMOVE) {
+            if (mClickRemoveHitPos != MISS) {
+                mDslv.removeItem(mClickRemoveHitPos - mDslv.getHeaderViewsCount());
+            }
+        }
+        return true;
+    }
+
+    // complete the OnGestureListener interface
+    @Override
+    public void onShowPress(MotionEvent ev) {
+        // do nothing
+    }
+
+    private GestureDetector.OnGestureListener mFlingRemoveListener =
+            new GestureDetector.SimpleOnGestureListener() {
+                @Override
+                public final boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
+                        float velocityY) {
+                    // Log.d("mobeta", "on fling remove called");
+                    if (mRemoveEnabled && mIsRemoving) {
+                        int w = mDslv.getWidth();
+                        int minPos = w / 5;
+                        if (velocityX > mFlingSpeed) {
+                            if (mPositionX > -minPos) {
+                                mDslv.stopDragWithVelocity(true, velocityX);
+                            }
+                        } else if (velocityX < -mFlingSpeed) {
+                            if (mPositionX < minPos) {
+                                mDslv.stopDragWithVelocity(true, velocityX);
+                            }
+                        }
+                        mIsRemoving = false;
+                    }
+                    return false;
+                }
+            };
+
+}
diff --git a/src/com/android/settings/slim/dslv/DragSortItemView.java b/src/com/android/settings/slim/dslv/DragSortItemView.java
new file mode 100644
index 0000000..78d8412
--- /dev/null
+++ b/src/com/android/settings/slim/dslv/DragSortItemView.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2012 Carl Bauer
+ * Copyright (C) 2014 SlimRoms Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim.dslv;
+
+import android.content.Context;
+import android.view.Gravity;
+import android.view.View;
+import android.view.View.MeasureSpec;
+import android.view.ViewGroup;
+import android.widget.AbsListView;
+import android.util.Log;
+
+/**
+ * Lightweight ViewGroup that wraps list items obtained from user's
+ * ListAdapter. ItemView expects a single child that has a definite
+ * height (i.e. the child's layout height is not MATCH_PARENT).
+ * The width of
+ * ItemView will always match the width of its child (that is,
+ * the width MeasureSpec given to ItemView is passed directly
+ * to the child, and the ItemView measured width is set to the
+ * child's measured width). The height of ItemView can be anything;
+ * the
+ *
+ *
+ * The purpose of this class is to optimize slide
+ * shuffle animations.
+ */
+public class DragSortItemView extends ViewGroup {
+
+    private int mGravity = Gravity.TOP;
+
+    public DragSortItemView(Context context) {
+        super(context);
+
+        // always init with standard ListView layout params
+        setLayoutParams(new AbsListView.LayoutParams(
+                ViewGroup.LayoutParams.FILL_PARENT,
+                ViewGroup.LayoutParams.WRAP_CONTENT));
+
+        //setClipChildren(true);
+    }
+
+    public void setGravity(int gravity) {
+        mGravity = gravity;
+    }
+
+    public int getGravity() {
+        return mGravity;
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        final View child = getChildAt(0);
+
+        if (child == null) {
+            return;
+        }
+
+        if (mGravity == Gravity.TOP) {
+            child.layout(0, 0, getMeasuredWidth(), child.getMeasuredHeight());
+        } else {
+            child.layout(0, getMeasuredHeight() - child.getMeasuredHeight(),
+                    getMeasuredWidth(), getMeasuredHeight());
+        }
+    }
+
+    /**
+     *
+     */
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+
+        int height = MeasureSpec.getSize(heightMeasureSpec);
+        int width = MeasureSpec.getSize(widthMeasureSpec);
+
+        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+
+        final View child = getChildAt(0);
+        if (child == null) {
+            setMeasuredDimension(0, width);
+            return;
+        }
+
+        if (child.isLayoutRequested()) {
+            // Always let child be as tall as it wants.
+            measureChild(child, widthMeasureSpec,
+                    MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
+        }
+
+        if (heightMode == MeasureSpec.UNSPECIFIED) {
+            ViewGroup.LayoutParams lp = getLayoutParams();
+
+            if (lp.height > 0) {
+                height = lp.height;
+            } else {
+                height = child.getMeasuredHeight();
+            }
+        }
+
+        setMeasuredDimension(width, height);
+    }
+
+}
diff --git a/src/com/android/settings/slim/dslv/DragSortListView.java b/src/com/android/settings/slim/dslv/DragSortListView.java
new file mode 100644
index 0000000..278e28f
--- /dev/null
+++ b/src/com/android/settings/slim/dslv/DragSortListView.java
@@ -0,0 +1,3067 @@
+/*
+ * Copyright 2012 Carl Bauer
+ * Copyright (C) 2014 SlimRoms Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim.dslv;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.database.DataSetObserver;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Point;
+import android.graphics.drawable.Drawable;
+import android.os.Environment;
+import android.os.SystemClock;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.SparseBooleanArray;
+import android.util.SparseIntArray;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AbsListView;
+import android.widget.BaseAdapter;
+import android.widget.Checkable;
+import android.widget.ListAdapter;
+import android.widget.ListView;
+
+import com.android.settings.R;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.ArrayList;
+
+/**
+ * ListView subclass that mediates drag and drop resorting of items.
+ *
+ *
+ * @author heycosmo
+ *
+ */
+public class DragSortListView extends ListView {
+
+    /**
+     * The View that floats above the ListView and represents
+     * the dragged item.
+     */
+    private View mFloatView;
+
+    /**
+     * The float View location. First based on touch location
+     * and given deltaX and deltaY. Then restricted by callback
+     * to FloatViewManager.onDragFloatView(). Finally restricted
+     * by bounds of DSLV.
+     */
+    private Point mFloatLoc = new Point();
+
+    private Point mTouchLoc = new Point();
+
+    /**
+     * The middle (in the y-direction) of the floating View.
+     */
+    private int mFloatViewMid;
+
+    /**
+     * Flag to make sure float View isn't measured twice
+     */
+    private boolean mFloatViewOnMeasured = false;
+
+    /**
+     * Watch the Adapter for data changes. Cancel a drag if
+     * coincident with a change.
+     */
+    private DataSetObserver mObserver;
+
+    /**
+     * Transparency for the floating View (XML attribute).
+     */
+    private float mFloatAlpha = 1.0f;
+    private float mCurrFloatAlpha = 1.0f;
+
+    /**
+     * While drag-sorting, the current position of the floating
+     * View. If dropped, the dragged item will land in this position.
+     */
+    private int mFloatPos;
+
+    /**
+     * The first expanded ListView position that helps represent
+     * the drop slot tracking the floating View.
+     */
+    private int mFirstExpPos;
+
+    /**
+     * The second expanded ListView position that helps represent
+     * the drop slot tracking the floating View. This can equal
+     * mFirstExpPos if there is no slide shuffle occurring; otherwise
+     * it is equal to mFirstExpPos + 1.
+     */
+    private int mSecondExpPos;
+
+    /**
+     * Flag set if slide shuffling is enabled.
+     */
+    private boolean mAnimate = false;
+
+    /**
+     * The user dragged from this position.
+     */
+    private int mSrcPos;
+
+    /**
+     * Offset (in x) within the dragged item at which the user
+     * picked it up (or first touched down with the digitalis).
+     */
+    private int mDragDeltaX;
+
+    /**
+     * Offset (in y) within the dragged item at which the user
+     * picked it up (or first touched down with the digitalis).
+     */
+    private int mDragDeltaY;
+
+
+    /**
+     * The difference (in x) between screen coordinates and coordinates
+     * in this view.
+     */
+    private int mOffsetX;
+
+    /**
+     * The difference (in y) between screen coordinates and coordinates
+     * in this view.
+     */
+    private int mOffsetY;
+
+    /**
+     * A listener that receives callbacks whenever the floating View
+     * hovers over a new position.
+     */
+    private DragListener mDragListener;
+
+    /**
+     * A listener that receives a callback when the floating View
+     * is dropped.
+     */
+    private DropListener mDropListener;
+
+    /**
+     * A listener that receives a callback when the floating View
+     * (or more precisely the originally dragged item) is removed
+     * by one of the provided gestures.
+     */
+    private RemoveListener mRemoveListener;
+
+    /**
+     * Enable/Disable item dragging
+     *
+     * @attr name dslv:drag_enabled
+     */
+    private boolean mDragEnabled = true;
+
+    /**
+     * Drag state enum.
+     */
+    private final static int IDLE = 0;
+    private final static int REMOVING = 1;
+    private final static int DROPPING = 2;
+    private final static int STOPPED = 3;
+    private final static int DRAGGING = 4;
+
+    private int mDragState = IDLE;
+
+    /**
+     * Height in pixels to which the originally dragged item
+     * is collapsed during a drag-sort. Currently, this value
+     * must be greater than zero.
+     */
+    private int mItemHeightCollapsed = 1;
+
+    /**
+     * Height of the floating View. Stored for the purpose of
+     * providing the tracking drop slot.
+     */
+    private int mFloatViewHeight;
+
+    /**
+     * Convenience member. See above.
+     */
+    private int mFloatViewHeightHalf;
+
+    /**
+     * Save the given width spec for use in measuring children
+     */
+    private int mWidthMeasureSpec = 0;
+
+    /**
+     * Sample Views ultimately used for calculating the height
+     * of ListView items that are off-screen.
+     */
+    private View[] mSampleViewTypes = new View[1];
+
+    /**
+     * Drag-scroll encapsulator!
+     */
+    private DragScroller mDragScroller;
+
+    /**
+     * Determines the start of the upward drag-scroll region
+     * at the top of the ListView. Specified by a fraction
+     * of the ListView height, thus screen resolution agnostic.
+     */
+    private float mDragUpScrollStartFrac = 1.0f / 3.0f;
+
+    /**
+     * Determines the start of the downward drag-scroll region
+     * at the bottom of the ListView. Specified by a fraction
+     * of the ListView height, thus screen resolution agnostic.
+     */
+    private float mDragDownScrollStartFrac = 1.0f / 3.0f;
+
+    /**
+     * The following are calculated from the above fracs.
+     */
+    private int mUpScrollStartY;
+    private int mDownScrollStartY;
+    private float mDownScrollStartYF;
+    private float mUpScrollStartYF;
+
+    /**
+     * Calculated from above above and current ListView height.
+     */
+    private float mDragUpScrollHeight;
+
+    /**
+     * Calculated from above above and current ListView height.
+     */
+    private float mDragDownScrollHeight;
+
+    /**
+     * Maximum drag-scroll speed in pixels per ms. Only used with
+     * default linear drag-scroll profile.
+     */
+    private float mMaxScrollSpeed = 0.5f;
+
+    /**
+     * Defines the scroll speed during a drag-scroll. User can
+     * provide their own; this default is a simple linear profile
+     * where scroll speed increases linearly as the floating View
+     * nears the top/bottom of the ListView.
+     */
+    private DragScrollProfile mScrollProfile = new DragScrollProfile() {
+        @Override
+        public float getSpeed(float w, long t) {
+            return mMaxScrollSpeed * w;
+        }
+    };
+
+    /**
+     * Current touch x.
+     */
+    private int mX;
+
+    /**
+     * Current touch y.
+     */
+    private int mY;
+
+    /**
+     * Last touch x.
+     */
+    private int mLastX;
+
+    /**
+     * Last touch y.
+     */
+    private int mLastY;
+
+    /**
+     * The touch y-coord at which drag started
+     */
+    private int mDragStartY;
+
+    /**
+     * Drag flag bit. Floating View can move in the positive
+     * x direction.
+     */
+    public final static int DRAG_POS_X = 0x1;
+
+    /**
+     * Drag flag bit. Floating View can move in the negative
+     * x direction.
+     */
+    public final static int DRAG_NEG_X = 0x2;
+
+    /**
+     * Drag flag bit. Floating View can move in the positive
+     * y direction. This is subtle. What this actually means is
+     * that, if enabled, the floating View can be dragged below its starting
+     * position. Remove in favor of upper-bounding item position?
+     */
+    public final static int DRAG_POS_Y = 0x4;
+
+    /**
+     * Drag flag bit. Floating View can move in the negative
+     * y direction. This is subtle. What this actually means is
+     * that the floating View can be dragged above its starting
+     * position. Remove in favor of lower-bounding item position?
+     */
+    public final static int DRAG_NEG_Y = 0x8;
+
+    /**
+     * Flags that determine limits on the motion of the
+     * floating View. See flags above.
+     */
+    private int mDragFlags = 0;
+
+    /**
+     * Last call to an on*TouchEvent was a call to
+     * onInterceptTouchEvent.
+     */
+    private boolean mLastCallWasIntercept = false;
+
+    /**
+     * A touch event is in progress.
+     */
+    private boolean mInTouchEvent = false;
+
+    /**
+     * Let the user customize the floating View.
+     */
+    private FloatViewManager mFloatViewManager = null;
+
+    /**
+     * Given to ListView to cancel its action when a drag-sort
+     * begins.
+     */
+    private MotionEvent mCancelEvent;
+
+    /**
+     * Enum telling where to cancel the ListView action when a
+     * drag-sort begins
+     */
+    private static final int NO_CANCEL = 0;
+    private static final int ON_TOUCH_EVENT = 1;
+    private static final int ON_INTERCEPT_TOUCH_EVENT = 2;
+
+    /**
+     * Where to cancel the ListView action when a
+     * drag-sort begins
+     */
+    private int mCancelMethod = NO_CANCEL;
+
+    /**
+     * Determines when a slide shuffle animation starts. That is,
+     * defines how close to the edge of the drop slot the floating
+     * View must be to initiate the slide.
+     */
+    private float mSlideRegionFrac = 0.25f;
+
+    /**
+     * Number between 0 and 1 indicating the relative location of
+     * a sliding item (only used if drag-sort animations
+     * are turned on). Nearly 1 means the item is
+     * at the top of the slide region (nearly full blank item
+     * is directly below).
+     */
+    private float mSlideFrac = 0.0f;
+
+    /**
+     * Wraps the user-provided ListAdapter. This is used to wrap each
+     * item View given by the user inside another View (currenly
+     * a RelativeLayout) which
+     * expands and collapses to simulate the item shuffling.
+     */
+    private AdapterWrapper mAdapterWrapper;
+
+    /**
+     * Turn on custom debugger.
+     */
+    private boolean mTrackDragSort = false;
+
+    /**
+     * Debugging class.
+     */
+    private DragSortTracker mDragSortTracker;
+
+    /**
+     * Needed for adjusting item heights from within layoutChildren
+     */
+    private boolean mBlockLayoutRequests = false;
+
+    /**
+     * Set to true when a down event happens during drag sort;
+     * for example, when drag finish animations are
+     * playing.
+     */
+    private boolean mIgnoreTouchEvent = false;
+
+    /**
+     * Caches DragSortItemView child heights. Sometimes DSLV has to
+     * know the height of an offscreen item. Since ListView virtualizes
+     * these, DSLV must get the item from the ListAdapter to obtain
+     * its height. That process can be expensive, but often the same
+     * offscreen item will be requested many times in a row. Once an
+     * offscreen item height is calculated, we cache it in this guy.
+     * Actually, we cache the height of the child of the
+     * DragSortItemView since the item height changes often during a
+     * drag-sort.
+     */
+    private static final int sCacheSize = 3;
+    private HeightCache mChildHeightCache = new HeightCache(sCacheSize);
+
+    private RemoveAnimator mRemoveAnimator;
+
+    private LiftAnimator mLiftAnimator;
+
+    private DropAnimator mDropAnimator;
+
+    private boolean mUseRemoveVelocity;
+    private float mRemoveVelocityX = 0;
+
+    public DragSortListView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        int defaultDuration = 150;
+        int removeAnimDuration = defaultDuration; // ms
+        int dropAnimDuration = defaultDuration; // ms
+
+        if (attrs != null) {
+            TypedArray a = getContext().obtainStyledAttributes(attrs,
+                    R.styleable.DragSortListView, 0, 0);
+
+            mItemHeightCollapsed = Math.max(1, a.getDimensionPixelSize(
+                    R.styleable.DragSortListView_collapsedHeight, 1));
+
+            mTrackDragSort = a.getBoolean(
+                    R.styleable.DragSortListView_trackDragSort, false);
+
+            if (mTrackDragSort) {
+                mDragSortTracker = new DragSortTracker();
+            }
+
+            // alpha between 0 and 255, 0=transparent, 255=opaque
+            mFloatAlpha = a.getFloat(R.styleable.DragSortListView_floatAlpha, mFloatAlpha);
+            mCurrFloatAlpha = mFloatAlpha;
+
+            mDragEnabled = a.getBoolean(R.styleable.DragSortListView_dragEnabled, mDragEnabled);
+
+            mSlideRegionFrac = Math.max(0.0f,
+                    Math.min(1.0f, 1.0f - a.getFloat(
+                            R.styleable.DragSortListView_slideShuffleSpeed,
+                            0.75f)));
+
+            mAnimate = mSlideRegionFrac > 0.0f;
+
+            float frac = a.getFloat(
+                    R.styleable.DragSortListView_dragScrollStart,
+                    mDragUpScrollStartFrac);
+
+            setDragScrollStart(frac);
+
+            mMaxScrollSpeed = a.getFloat(
+                    R.styleable.DragSortListView_maxDragScrollSpeed,
+                    mMaxScrollSpeed);
+
+            removeAnimDuration = a.getInt(
+                    R.styleable.DragSortListView_removeAnimationDuration,
+                    removeAnimDuration);
+
+            dropAnimDuration = a.getInt(
+                    R.styleable.DragSortListView_dropAnimationDuration,
+                    dropAnimDuration);
+
+            boolean useDefault = a.getBoolean(
+                    R.styleable.DragSortListView_useDefaultController,
+                    true);
+
+            if (useDefault) {
+                boolean removeEnabled = a.getBoolean(
+                        R.styleable.DragSortListView_removeEnabled,
+                        false);
+                int removeMode = a.getInt(
+                        R.styleable.DragSortListView_removeMode,
+                        DragSortController.FLING_REMOVE);
+                boolean sortEnabled = a.getBoolean(
+                        R.styleable.DragSortListView_sortEnabled,
+                        true);
+                int dragInitMode = a.getInt(
+                        R.styleable.DragSortListView_dragStartMode,
+                        DragSortController.ON_DOWN);
+                int dragHandleId = a.getResourceId(
+                        R.styleable.DragSortListView_dragHandleId,
+                        0);
+                int flingHandleId = a.getResourceId(
+                        R.styleable.DragSortListView_flingHandleId,
+                        0);
+                int clickRemoveId = a.getResourceId(
+                        R.styleable.DragSortListView_clickRemoveId,
+                        0);
+                int bgColor = a.getColor(
+                        R.styleable.DragSortListView_floatBackgroundColor,
+                        Color.BLACK);
+
+                DragSortController controller = new DragSortController(
+                        this, dragHandleId, dragInitMode, removeMode,
+                        clickRemoveId, flingHandleId);
+                controller.setRemoveEnabled(removeEnabled);
+                controller.setSortEnabled(sortEnabled);
+                controller.setBackgroundColor(bgColor);
+
+                mFloatViewManager = controller;
+                setOnTouchListener(controller);
+            }
+
+            a.recycle();
+        }
+
+        mDragScroller = new DragScroller();
+
+        float smoothness = 0.5f;
+        if (removeAnimDuration > 0) {
+            mRemoveAnimator = new RemoveAnimator(smoothness, removeAnimDuration);
+        }
+        // mLiftAnimator = new LiftAnimator(smoothness, 100);
+        if (dropAnimDuration > 0) {
+            mDropAnimator = new DropAnimator(smoothness, dropAnimDuration);
+        }
+
+        mCancelEvent = MotionEvent.obtain(0, 0, MotionEvent.ACTION_CANCEL, 0f, 0f, 0f, 0f, 0, 0f,
+                0f, 0, 0);
+
+        // construct the dataset observer
+        mObserver = new DataSetObserver() {
+            private void cancel() {
+                if (mDragState == DRAGGING) {
+                    cancelDrag();
+                }
+            }
+
+            @Override
+            public void onChanged() {
+                cancel();
+            }
+
+            @Override
+            public void onInvalidated() {
+                cancel();
+            }
+        };
+    }
+
+    /**
+     * Usually called from a FloatViewManager. The float alpha
+     * will be reset to the xml-defined value every time a drag
+     * is stopped.
+     */
+    public void setFloatAlpha(float alpha) {
+        mCurrFloatAlpha = alpha;
+    }
+
+    public float getFloatAlpha() {
+        return mCurrFloatAlpha;
+    }
+
+    /**
+     * Set maximum drag scroll speed in positions/second. Only applies
+     * if using default ScrollSpeedProfile.
+     *
+     * @param max Maximum scroll speed.
+     */
+    public void setMaxScrollSpeed(float max) {
+        mMaxScrollSpeed = max;
+    }
+
+    /**
+     * For each DragSortListView Listener interface implemented by
+     * <code>adapter</code>, this method calls the appropriate
+     * set*Listener method with <code>adapter</code> as the argument.
+     *
+     * @param adapter The ListAdapter providing data to back
+     * DragSortListView.
+     *
+     * @see android.widget.ListView#setAdapter(android.widget.ListAdapter)
+     */
+    @Override
+    public void setAdapter(ListAdapter adapter) {
+        if (adapter != null) {
+            mAdapterWrapper = new AdapterWrapper(adapter);
+            adapter.registerDataSetObserver(mObserver);
+
+            if (adapter instanceof DropListener) {
+                setDropListener((DropListener) adapter);
+            }
+            if (adapter instanceof DragListener) {
+                setDragListener((DragListener) adapter);
+            }
+            if (adapter instanceof RemoveListener) {
+                setRemoveListener((RemoveListener) adapter);
+            }
+        } else {
+            mAdapterWrapper = null;
+        }
+
+        super.setAdapter(mAdapterWrapper);
+    }
+
+    /**
+     * As opposed to {@link ListView#getAdapter()}, which returns
+     * a heavily wrapped ListAdapter (DragSortListView wraps the
+     * input ListAdapter {\emph and} ListView wraps the wrapped one).
+     *
+     * @return The ListAdapter set as the argument of {@link setAdapter()}
+     */
+    public ListAdapter getInputAdapter() {
+        if (mAdapterWrapper == null) {
+            return null;
+        } else {
+            return mAdapterWrapper.getAdapter();
+        }
+    }
+
+    private class AdapterWrapper extends BaseAdapter {
+        private ListAdapter mAdapter;
+
+        public AdapterWrapper(ListAdapter adapter) {
+            super();
+            mAdapter = adapter;
+
+            mAdapter.registerDataSetObserver(new DataSetObserver() {
+                public void onChanged() {
+                    notifyDataSetChanged();
+                }
+
+                public void onInvalidated() {
+                    notifyDataSetInvalidated();
+                }
+            });
+        }
+
+        public ListAdapter getAdapter() {
+            return mAdapter;
+        }
+
+        @Override
+        public long getItemId(int position) {
+            return mAdapter.getItemId(position);
+        }
+
+        @Override
+        public Object getItem(int position) {
+            return mAdapter.getItem(position);
+        }
+
+        @Override
+        public int getCount() {
+            return mAdapter.getCount();
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return mAdapter.areAllItemsEnabled();
+        }
+
+        @Override
+        public boolean isEnabled(int position) {
+            return mAdapter.isEnabled(position);
+        }
+
+        @Override
+        public int getItemViewType(int position) {
+            return mAdapter.getItemViewType(position);
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return mAdapter.getViewTypeCount();
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return mAdapter.hasStableIds();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return mAdapter.isEmpty();
+        }
+
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+
+            DragSortItemView v;
+            View child;
+            // Log.d("mobeta",
+            // "getView: position="+position+" convertView="+convertView);
+            if (convertView != null) {
+                v = (DragSortItemView) convertView;
+                View oldChild = v.getChildAt(0);
+
+                child = mAdapter.getView(position, oldChild, DragSortListView.this);
+                if (child != oldChild) {
+                    // shouldn't get here if user is reusing convertViews
+                    // properly
+                    if (oldChild != null) {
+                        v.removeViewAt(0);
+                    }
+                    v.addView(child);
+                }
+            } else {
+                child = mAdapter.getView(position, null, DragSortListView.this);
+                v = new DragSortItemView(getContext());
+                v.setLayoutParams(new AbsListView.LayoutParams(
+                        ViewGroup.LayoutParams.FILL_PARENT,
+                        ViewGroup.LayoutParams.WRAP_CONTENT));
+                v.addView(child);
+            }
+
+            // Set the correct item height given drag state; passed
+            // View needs to be measured if measurement is required.
+            adjustItem(position + getHeaderViewsCount(), v, true);
+
+            return v;
+        }
+    }
+
+    private void drawDivider(int expPosition, Canvas canvas) {
+
+        final Drawable divider = getDivider();
+        final int dividerHeight = getDividerHeight();
+        // Log.d("mobeta", "div="+divider+" divH="+dividerHeight);
+
+        if (divider != null && dividerHeight != 0) {
+            final ViewGroup expItem = (ViewGroup) getChildAt(expPosition
+                    - getFirstVisiblePosition());
+            if (expItem != null) {
+                final int l = getPaddingLeft();
+                final int r = getWidth() - getPaddingRight();
+                final int t;
+                final int b;
+
+                final int childHeight = expItem.getChildAt(0).getHeight();
+
+                if (expPosition > mSrcPos) {
+                    t = expItem.getTop() + childHeight;
+                    b = t + dividerHeight;
+                } else {
+                    b = expItem.getBottom() - childHeight;
+                    t = b - dividerHeight;
+                }
+                // Log.d("mobeta", "l="+l+" t="+t+" r="+r+" b="+b);
+
+                // Have to clip to support ColorDrawable on <= Gingerbread
+                canvas.save();
+                canvas.clipRect(l, t, r, b);
+                divider.setBounds(l, t, r, b);
+                divider.draw(canvas);
+                canvas.restore();
+            }
+        }
+    }
+
+    @Override
+    protected void dispatchDraw(Canvas canvas) {
+        super.dispatchDraw(canvas);
+
+        if (mDragState != IDLE) {
+            // draw the divider over the expanded item
+            if (mFirstExpPos != mSrcPos) {
+                drawDivider(mFirstExpPos, canvas);
+            }
+            if (mSecondExpPos != mFirstExpPos && mSecondExpPos != mSrcPos) {
+                drawDivider(mSecondExpPos, canvas);
+            }
+        }
+
+        if (mFloatView != null) {
+            // draw the float view over everything
+            final int w = mFloatView.getWidth();
+            final int h = mFloatView.getHeight();
+
+            int x = mFloatLoc.x;
+
+            int width = getWidth();
+            if (x < 0)
+                x = -x;
+            float alphaMod;
+            if (x < width) {
+                alphaMod = ((float) (width - x)) / ((float) width);
+                alphaMod *= alphaMod;
+            } else {
+                alphaMod = 0;
+            }
+
+            final int alpha = (int) (255f * mCurrFloatAlpha * alphaMod);
+
+            canvas.save();
+            // Log.d("mobeta", "clip rect bounds: " + canvas.getClipBounds());
+            canvas.translate(mFloatLoc.x, mFloatLoc.y);
+            canvas.clipRect(0, 0, w, h);
+
+            // Log.d("mobeta", "clip rect bounds: " + canvas.getClipBounds());
+            canvas.saveLayerAlpha(0, 0, w, h, alpha, Canvas.ALL_SAVE_FLAG);
+            mFloatView.draw(canvas);
+            canvas.restore();
+            canvas.restore();
+        }
+    }
+
+    private int getItemHeight(int position) {
+        View v = getChildAt(position - getFirstVisiblePosition());
+
+        if (v != null) {
+            // item is onscreen, just get the height of the View
+            return v.getHeight();
+        } else {
+            // item is offscreen. get child height and calculate
+            // item height based on current shuffle state
+            return calcItemHeight(position, getChildHeight(position));
+        }
+    }
+
+    private void printPosData() {
+        Log.d("mobeta", "mSrcPos=" + mSrcPos + " mFirstExpPos=" + mFirstExpPos + " mSecondExpPos="
+                + mSecondExpPos);
+    }
+
+    private class HeightCache {
+
+        private SparseIntArray mMap;
+        private ArrayList<Integer> mOrder;
+        private int mMaxSize;
+
+        public HeightCache(int size) {
+            mMap = new SparseIntArray(size);
+            mOrder = new ArrayList<Integer>(size);
+            mMaxSize = size;
+        }
+
+        /**
+         * Add item height at position if doesn't already exist.
+         */
+        public void add(int position, int height) {
+            int currHeight = mMap.get(position, -1);
+            if (currHeight != height) {
+                if (currHeight == -1) {
+                    if (mMap.size() == mMaxSize) {
+                        // remove oldest entry
+                        mMap.delete(mOrder.remove(0));
+                    }
+                } else {
+                    // move position to newest slot
+                    mOrder.remove((Integer) position);
+                }
+                mMap.put(position, height);
+                mOrder.add(position);
+            }
+        }
+
+        public int get(int position) {
+            return mMap.get(position, -1);
+        }
+
+        public void clear() {
+            mMap.clear();
+            mOrder.clear();
+        }
+
+    }
+
+    /**
+     * Get the shuffle edge for item at position when top of
+     * item is at y-coord top. Assumes that current item heights
+     * are consistent with current float view location and
+     * thus expanded positions and slide fraction. i.e. Should not be
+     * called between update of expanded positions/slide fraction
+     * and layoutChildren.
+     *
+     * @param position
+     * @param top
+     * @param height Height of item at position. If -1, this function
+     * calculates this height.
+     *
+     * @return Shuffle line between position-1 and position (for
+     * the given view of the list; that is, for when top of item at
+     * position has y-coord of given `top`). If
+     * floating View (treated as horizontal line) is dropped
+     * immediately above this line, it lands in position-1. If
+     * dropped immediately below this line, it lands in position.
+     */
+    private int getShuffleEdge(int position, int top) {
+
+        final int numHeaders = getHeaderViewsCount();
+        final int numFooters = getFooterViewsCount();
+
+        // shuffle edges are defined between items that can be
+        // dragged; there are N-1 of them if there are N draggable
+        // items.
+
+        if (position <= numHeaders || (position >= getCount() - numFooters)) {
+            return top;
+        }
+
+        int divHeight = getDividerHeight();
+
+        int edge;
+
+        int maxBlankHeight = mFloatViewHeight - mItemHeightCollapsed;
+        int childHeight = getChildHeight(position);
+        int itemHeight = getItemHeight(position);
+
+        // first calculate top of item given that floating View is
+        // centered over src position
+        int otop = top;
+        if (mSecondExpPos <= mSrcPos) {
+            // items are expanded on and/or above the source position
+
+            if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {
+                if (position == mSrcPos) {
+                    otop = top + itemHeight - mFloatViewHeight;
+                } else {
+                    int blankHeight = itemHeight - childHeight;
+                    otop = top + blankHeight - maxBlankHeight;
+                }
+            } else if (position > mSecondExpPos && position <= mSrcPos) {
+                otop = top - maxBlankHeight;
+            }
+
+        } else {
+            // items are expanded on and/or below the source position
+
+            if (position > mSrcPos && position <= mFirstExpPos) {
+                otop = top + maxBlankHeight;
+            } else if (position == mSecondExpPos && mFirstExpPos != mSecondExpPos) {
+                int blankHeight = itemHeight - childHeight;
+                otop = top + blankHeight;
+            }
+        }
+
+        // otop is set
+        if (position <= mSrcPos) {
+            edge = otop + (mFloatViewHeight - divHeight - getChildHeight(position - 1)) / 2;
+        } else {
+            edge = otop + (childHeight - divHeight - mFloatViewHeight) / 2;
+        }
+
+        return edge;
+    }
+
+    private boolean updatePositions() {
+
+        final int first = getFirstVisiblePosition();
+        int startPos = mFirstExpPos;
+        View startView = getChildAt(startPos - first);
+
+        if (startView == null) {
+            startPos = first + getChildCount() / 2;
+            startView = getChildAt(startPos - first);
+        }
+        int startTop = startView.getTop();
+
+        int itemHeight = startView.getHeight();
+
+        int edge = getShuffleEdge(startPos, startTop);
+        int lastEdge = edge;
+
+        int divHeight = getDividerHeight();
+
+        // Log.d("mobeta", "float mid="+mFloatViewMid);
+
+        int itemPos = startPos;
+        int itemTop = startTop;
+        if (mFloatViewMid < edge) {
+            // scanning up for float position
+            // Log.d("mobeta", "    edge="+edge);
+            while (itemPos >= 0) {
+                itemPos--;
+                itemHeight = getItemHeight(itemPos);
+
+                if (itemPos == 0) {
+                    edge = itemTop - divHeight - itemHeight;
+                    break;
+                }
+
+                itemTop -= itemHeight + divHeight;
+                edge = getShuffleEdge(itemPos, itemTop);
+                // Log.d("mobeta", "    edge="+edge);
+
+                if (mFloatViewMid >= edge) {
+                    break;
+                }
+
+                lastEdge = edge;
+            }
+        } else {
+            // scanning down for float position
+            // Log.d("mobeta", "    edge="+edge);
+            final int count = getCount();
+            while (itemPos < count) {
+                if (itemPos == count - 1) {
+                    edge = itemTop + divHeight + itemHeight;
+                    break;
+                }
+
+                itemTop += divHeight + itemHeight;
+                itemHeight = getItemHeight(itemPos + 1);
+                edge = getShuffleEdge(itemPos + 1, itemTop);
+                // Log.d("mobeta", "    edge="+edge);
+
+                // test for hit
+                if (mFloatViewMid < edge) {
+                    break;
+                }
+
+                lastEdge = edge;
+                itemPos++;
+            }
+        }
+
+        final int numHeaders = getHeaderViewsCount();
+        final int numFooters = getFooterViewsCount();
+
+        boolean updated = false;
+
+        int oldFirstExpPos = mFirstExpPos;
+        int oldSecondExpPos = mSecondExpPos;
+        float oldSlideFrac = mSlideFrac;
+
+        if (mAnimate) {
+            int edgeToEdge = Math.abs(edge - lastEdge);
+
+            int edgeTop, edgeBottom;
+            if (mFloatViewMid < edge) {
+                edgeBottom = edge;
+                edgeTop = lastEdge;
+            } else {
+                edgeTop = edge;
+                edgeBottom = lastEdge;
+            }
+            // Log.d("mobeta", "edgeTop="+edgeTop+" edgeBot="+edgeBottom);
+
+            int slideRgnHeight = (int) (0.5f * mSlideRegionFrac * edgeToEdge);
+            float slideRgnHeightF = (float) slideRgnHeight;
+            int slideEdgeTop = edgeTop + slideRgnHeight;
+            int slideEdgeBottom = edgeBottom - slideRgnHeight;
+
+            // Three regions
+            if (mFloatViewMid < slideEdgeTop) {
+                mFirstExpPos = itemPos - 1;
+                mSecondExpPos = itemPos;
+                mSlideFrac = 0.5f * ((float) (slideEdgeTop - mFloatViewMid)) / slideRgnHeightF;
+                // Log.d("mobeta",
+                // "firstExp="+mFirstExpPos+" secExp="+mSecondExpPos+" slideFrac="+mSlideFrac);
+            } else if (mFloatViewMid < slideEdgeBottom) {
+                mFirstExpPos = itemPos;
+                mSecondExpPos = itemPos;
+            } else {
+                mFirstExpPos = itemPos;
+                mSecondExpPos = itemPos + 1;
+                mSlideFrac = 0.5f * (1.0f + ((float) (edgeBottom - mFloatViewMid))
+                        / slideRgnHeightF);
+                // Log.d("mobeta",
+                // "firstExp="+mFirstExpPos+" secExp="+mSecondExpPos+" slideFrac="+mSlideFrac);
+            }
+
+        } else {
+            mFirstExpPos = itemPos;
+            mSecondExpPos = itemPos;
+        }
+
+        // correct for headers and footers
+        if (mFirstExpPos < numHeaders) {
+            itemPos = numHeaders;
+            mFirstExpPos = itemPos;
+            mSecondExpPos = itemPos;
+        } else if (mSecondExpPos >= getCount() - numFooters) {
+            itemPos = getCount() - numFooters - 1;
+            mFirstExpPos = itemPos;
+            mSecondExpPos = itemPos;
+        }
+
+        if (mFirstExpPos != oldFirstExpPos || mSecondExpPos != oldSecondExpPos
+                || mSlideFrac != oldSlideFrac) {
+            updated = true;
+        }
+
+        if (itemPos != mFloatPos) {
+            if (mDragListener != null) {
+                mDragListener.drag(mFloatPos - numHeaders, itemPos - numHeaders);
+            }
+
+            mFloatPos = itemPos;
+            updated = true;
+        }
+
+        return updated;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        if (mTrackDragSort) {
+            mDragSortTracker.appendState();
+        }
+    }
+
+    private class SmoothAnimator implements Runnable {
+        protected long mStartTime;
+
+        private float mDurationF;
+
+        private float mAlpha;
+        private float mA, mB, mC, mD;
+
+        private boolean mCanceled;
+
+        public SmoothAnimator(float smoothness, int duration) {
+            mAlpha = smoothness;
+            mDurationF = (float) duration;
+            mA = mD = 1f / (2f * mAlpha * (1f - mAlpha));
+            mB = mAlpha / (2f * (mAlpha - 1f));
+            mC = 1f / (1f - mAlpha);
+        }
+
+        public float transform(float frac) {
+            if (frac < mAlpha) {
+                return mA * frac * frac;
+            } else if (frac < 1f - mAlpha) {
+                return mB + mC * frac;
+            } else {
+                return 1f - mD * (frac - 1f) * (frac - 1f);
+            }
+        }
+
+        public void start() {
+            mStartTime = SystemClock.uptimeMillis();
+            mCanceled = false;
+            onStart();
+            post(this);
+        }
+
+        public void cancel() {
+            mCanceled = true;
+        }
+
+        public void onStart() {
+            // stub
+        }
+
+        public void onUpdate(float frac, float smoothFrac) {
+            // stub
+        }
+
+        public void onStop() {
+            // stub
+        }
+
+        @Override
+        public void run() {
+            if (mCanceled) {
+                return;
+            }
+
+            float fraction = ((float) (SystemClock.uptimeMillis() - mStartTime)) / mDurationF;
+
+            if (fraction >= 1f) {
+                onUpdate(1f, 1f);
+                onStop();
+            } else {
+                onUpdate(fraction, transform(fraction));
+                post(this);
+            }
+        }
+    }
+
+    /**
+     * Centers floating View under touch point.
+     */
+    private class LiftAnimator extends SmoothAnimator {
+
+        private float mInitDragDeltaY;
+        private float mFinalDragDeltaY;
+
+        public LiftAnimator(float smoothness, int duration) {
+            super(smoothness, duration);
+        }
+
+        @Override
+        public void onStart() {
+            mInitDragDeltaY = mDragDeltaY;
+            mFinalDragDeltaY = mFloatViewHeightHalf;
+        }
+
+        @Override
+        public void onUpdate(float frac, float smoothFrac) {
+            if (mDragState != DRAGGING) {
+                cancel();
+            } else {
+                mDragDeltaY = (int) (smoothFrac * mFinalDragDeltaY + (1f - smoothFrac)
+                        * mInitDragDeltaY);
+                mFloatLoc.y = mY - mDragDeltaY;
+                doDragFloatView(true);
+            }
+        }
+    }
+
+    /**
+     * Centers floating View over drop slot before destroying.
+     */
+    private class DropAnimator extends SmoothAnimator {
+
+        private int mDropPos;
+        private int srcPos;
+        private float mInitDeltaY;
+        private float mInitDeltaX;
+
+        public DropAnimator(float smoothness, int duration) {
+            super(smoothness, duration);
+        }
+
+        @Override
+        public void onStart() {
+            mDropPos = mFloatPos;
+            srcPos = mSrcPos;
+            mDragState = DROPPING;
+            mInitDeltaY = mFloatLoc.y - getTargetY();
+            mInitDeltaX = mFloatLoc.x - getPaddingLeft();
+        }
+
+        private int getTargetY() {
+            final int first = getFirstVisiblePosition();
+            final int otherAdjust = (mItemHeightCollapsed + getDividerHeight()) / 2;
+            View v = getChildAt(mDropPos - first);
+            int targetY = -1;
+            if (v != null) {
+                if (mDropPos == srcPos) {
+                    targetY = v.getTop();
+                } else if (mDropPos < srcPos) {
+                    // expanded down
+                    targetY = v.getTop() - otherAdjust;
+                } else {
+                    // expanded up
+                    targetY = v.getBottom() + otherAdjust - mFloatViewHeight;
+                }
+            } else {
+                // drop position is not on screen?? no animation
+                cancel();
+            }
+
+            return targetY;
+        }
+
+        @Override
+        public void onUpdate(float frac, float smoothFrac) {
+            final int targetY = getTargetY();
+            final int targetX = getPaddingLeft();
+            final float deltaY = mFloatLoc.y - targetY;
+            final float deltaX = mFloatLoc.x - targetX;
+            final float f = 1f - smoothFrac;
+            if (f < Math.abs(deltaY / mInitDeltaY) || f < Math.abs(deltaX / mInitDeltaX)) {
+                mFloatLoc.y = targetY + (int) (mInitDeltaY * f);
+                mFloatLoc.x = getPaddingLeft() + (int) (mInitDeltaX * f);
+                doDragFloatView(true);
+            }
+        }
+
+        @Override
+        public void onStop() {
+            dropFloatView();
+        }
+
+    }
+
+    /**
+     * Collapses expanded items.
+     */
+    private class RemoveAnimator extends SmoothAnimator {
+
+        private float mFloatLocX;
+        private float mFirstStartBlank;
+        private float mSecondStartBlank;
+
+        private int mFirstChildHeight = -1;
+        private int mSecondChildHeight = -1;
+
+        private int mFirstPos;
+        private int mSecondPos;
+        private int srcPos;
+
+        public RemoveAnimator(float smoothness, int duration) {
+            super(smoothness, duration);
+        }
+
+        @Override
+        public void onStart() {
+            mFirstChildHeight = -1;
+            mSecondChildHeight = -1;
+            mFirstPos = mFirstExpPos;
+            mSecondPos = mSecondExpPos;
+            srcPos = mSrcPos;
+            mDragState = REMOVING;
+
+            mFloatLocX = mFloatLoc.x;
+            if (mUseRemoveVelocity) {
+                float minVelocity = 2f * getWidth();
+                if (mRemoveVelocityX == 0) {
+                    mRemoveVelocityX = (mFloatLocX < 0 ? -1 : 1) * minVelocity;
+                } else {
+                    minVelocity *= 2;
+                    if (mRemoveVelocityX < 0 && mRemoveVelocityX > -minVelocity)
+                        mRemoveVelocityX = -minVelocity;
+                    else if (mRemoveVelocityX > 0 && mRemoveVelocityX < minVelocity)
+                        mRemoveVelocityX = minVelocity;
+                }
+            } else {
+                destroyFloatView();
+            }
+        }
+
+        @Override
+        public void onUpdate(float frac, float smoothFrac) {
+            float f = 1f - smoothFrac;
+
+            final int firstVis = getFirstVisiblePosition();
+            View item = getChildAt(mFirstPos - firstVis);
+            ViewGroup.LayoutParams lp;
+            int blank;
+
+            if (mUseRemoveVelocity) {
+                float dt = (float) (SystemClock.uptimeMillis() - mStartTime) / 1000;
+                if (dt == 0)
+                    return;
+                float dx = mRemoveVelocityX * dt;
+                int w = getWidth();
+                mRemoveVelocityX += (mRemoveVelocityX > 0 ? 1 : -1) * dt * w;
+                mFloatLocX += dx;
+                mFloatLoc.x = (int) mFloatLocX;
+                if (mFloatLocX < w && mFloatLocX > -w) {
+                    mStartTime = SystemClock.uptimeMillis();
+                    doDragFloatView(true);
+                    return;
+                }
+            }
+
+            if (item != null) {
+                if (mFirstChildHeight == -1) {
+                    mFirstChildHeight = getChildHeight(mFirstPos, item, false);
+                    mFirstStartBlank = (float) (item.getHeight() - mFirstChildHeight);
+                }
+                blank = Math.max((int) (f * mFirstStartBlank), 1);
+                lp = item.getLayoutParams();
+                lp.height = mFirstChildHeight + blank;
+                item.setLayoutParams(lp);
+            }
+            if (mSecondPos != mFirstPos) {
+                item = getChildAt(mSecondPos - firstVis);
+                if (item != null) {
+                    if (mSecondChildHeight == -1) {
+                        mSecondChildHeight = getChildHeight(mSecondPos, item, false);
+                        mSecondStartBlank = (float) (item.getHeight() - mSecondChildHeight);
+                    }
+                    blank = Math.max((int) (f * mSecondStartBlank), 1);
+                    lp = item.getLayoutParams();
+                    lp.height = mSecondChildHeight + blank;
+                    item.setLayoutParams(lp);
+                }
+            }
+        }
+
+        @Override
+        public void onStop() {
+            doRemoveItem();
+        }
+    }
+
+    public void removeItem(int which) {
+
+        mUseRemoveVelocity = false;
+        removeItem(which, 0);
+    }
+
+    /**
+     * Removes an item from the list and animates the removal.
+     *
+     * @param which Position to remove (NOTE: headers/footers ignored!
+     * this is a position in your input ListAdapter).
+     * @param velocityX
+     */
+    public void removeItem(int which, float velocityX) {
+        if (mDragState == IDLE || mDragState == DRAGGING) {
+
+            if (mDragState == IDLE) {
+                // called from outside drag-sort
+                mSrcPos = getHeaderViewsCount() + which;
+                mFirstExpPos = mSrcPos;
+                mSecondExpPos = mSrcPos;
+                mFloatPos = mSrcPos;
+                View v = getChildAt(mSrcPos - getFirstVisiblePosition());
+                if (v != null) {
+                    v.setVisibility(View.INVISIBLE);
+                }
+            }
+
+            mDragState = REMOVING;
+            mRemoveVelocityX = velocityX;
+
+            if (mInTouchEvent) {
+                switch (mCancelMethod) {
+                    case ON_TOUCH_EVENT:
+                        super.onTouchEvent(mCancelEvent);
+                        break;
+                    case ON_INTERCEPT_TOUCH_EVENT:
+                        super.onInterceptTouchEvent(mCancelEvent);
+                        break;
+                }
+            }
+
+            if (mRemoveAnimator != null) {
+                mRemoveAnimator.start();
+            } else {
+                doRemoveItem(which);
+            }
+        }
+    }
+
+    /**
+     * Move an item, bypassing the drag-sort process. Simply calls
+     * through to {@link DropListener#drop(int, int)}.
+     *
+     * @param from Position to move (NOTE: headers/footers ignored!
+     * this is a position in your input ListAdapter).
+     * @param to Target position (NOTE: headers/footers ignored!
+     * this is a position in your input ListAdapter).
+     */
+    public void moveItem(int from, int to) {
+        if (mDropListener != null) {
+            final int count = getInputAdapter().getCount();
+            if (from >= 0 && from < count && to >= 0 && to < count) {
+                mDropListener.drop(from, to);
+            }
+        }
+    }
+
+    /**
+     * Cancel a drag. Calls {@link #stopDrag(boolean, boolean)} with
+     * <code>true</code> as the first argument.
+     */
+    public void cancelDrag() {
+        if (mDragState == DRAGGING) {
+            mDragScroller.stopScrolling(true);
+            destroyFloatView();
+            clearPositions();
+            adjustAllItems();
+
+            if (mInTouchEvent) {
+                mDragState = STOPPED;
+            } else {
+                mDragState = IDLE;
+            }
+        }
+    }
+
+    private void clearPositions() {
+        mSrcPos = -1;
+        mFirstExpPos = -1;
+        mSecondExpPos = -1;
+        mFloatPos = -1;
+    }
+
+    private void dropFloatView() {
+        // must set to avoid cancelDrag being called from the
+        // DataSetObserver
+        mDragState = DROPPING;
+
+        if (mDropListener != null && mFloatPos >= 0 && mFloatPos < getCount()) {
+            final int numHeaders = getHeaderViewsCount();
+            mDropListener.drop(mSrcPos - numHeaders, mFloatPos - numHeaders);
+        }
+
+        destroyFloatView();
+
+        adjustOnReorder();
+        clearPositions();
+        adjustAllItems();
+
+        // now the drag is done
+        if (mInTouchEvent) {
+            mDragState = STOPPED;
+        } else {
+            mDragState = IDLE;
+        }
+    }
+
+    private void doRemoveItem() {
+        doRemoveItem(mSrcPos - getHeaderViewsCount());
+    }
+
+    /**
+     * Removes dragged item from the list. Calls RemoveListener.
+     */
+    private void doRemoveItem(int which) {
+        // must set to avoid cancelDrag being called from the
+        // DataSetObserver
+        mDragState = REMOVING;
+
+        // end it
+        if (mRemoveListener != null) {
+            mRemoveListener.remove(which);
+        }
+
+        destroyFloatView();
+
+        adjustOnReorder();
+        clearPositions();
+
+        // now the drag is done
+        if (mInTouchEvent) {
+            mDragState = STOPPED;
+        } else {
+            mDragState = IDLE;
+        }
+    }
+
+    private void adjustOnReorder() {
+        final int firstPos = getFirstVisiblePosition();
+        // Log.d("mobeta", "first="+firstPos+" src="+mSrcPos);
+        if (mSrcPos < firstPos) {
+            // collapsed src item is off screen;
+            // adjust the scroll after item heights have been fixed
+            View v = getChildAt(0);
+            int top = 0;
+            if (v != null) {
+                top = v.getTop();
+            }
+            // Log.d("mobeta", "top="+top+" fvh="+mFloatViewHeight);
+            setSelectionFromTop(firstPos - 1, top - getPaddingTop());
+        }
+    }
+
+    /**
+     * Stop a drag in progress. Pass <code>true</code> if you would
+     * like to remove the dragged item from the list.
+     *
+     * @param remove Remove the dragged item from the list. Calls
+     * a registered RemoveListener, if one exists. Otherwise, calls
+     * the DropListener, if one exists.
+     *
+     * @return True if the stop was successful. False if there is
+     * no floating View.
+     */
+    public boolean stopDrag(boolean remove) {
+        mUseRemoveVelocity = false;
+        return stopDrag(remove, 0);
+    }
+
+    public boolean stopDragWithVelocity(boolean remove, float velocityX) {
+
+        mUseRemoveVelocity = true;
+        return stopDrag(remove, velocityX);
+    }
+
+    public boolean stopDrag(boolean remove, float velocityX) {
+        if (mFloatView != null) {
+            mDragScroller.stopScrolling(true);
+
+            if (remove) {
+                removeItem(mSrcPos - getHeaderViewsCount(), velocityX);
+            } else {
+                if (mDropAnimator != null) {
+                    mDropAnimator.start();
+                } else {
+                    dropFloatView();
+                }
+            }
+
+            if (mTrackDragSort) {
+                mDragSortTracker.stopTracking();
+            }
+
+            return true;
+        } else {
+            // stop failed
+            return false;
+        }
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent ev) {
+        if (mIgnoreTouchEvent) {
+            mIgnoreTouchEvent = false;
+            return false;
+        }
+
+        if (!mDragEnabled) {
+            return super.onTouchEvent(ev);
+        }
+
+        boolean more = false;
+
+        boolean lastCallWasIntercept = mLastCallWasIntercept;
+        mLastCallWasIntercept = false;
+
+        if (!lastCallWasIntercept) {
+            saveTouchCoords(ev);
+        }
+
+        // if (mFloatView != null) {
+        if (mDragState == DRAGGING) {
+            onDragTouchEvent(ev);
+            more = true; // give us more!
+        } else {
+            // what if float view is null b/c we dropped in middle
+            // of drag touch event?
+
+            // if (mDragState != STOPPED) {
+            if (mDragState == IDLE) {
+                if (super.onTouchEvent(ev)) {
+                    more = true;
+                }
+            }
+
+            int action = ev.getAction() & MotionEvent.ACTION_MASK;
+
+            switch (action) {
+                case MotionEvent.ACTION_CANCEL:
+                case MotionEvent.ACTION_UP:
+                    doActionUpOrCancel();
+                    break;
+                default:
+                    if (more) {
+                        mCancelMethod = ON_TOUCH_EVENT;
+                    }
+            }
+        }
+
+        return more;
+    }
+
+    private void doActionUpOrCancel() {
+        mCancelMethod = NO_CANCEL;
+        mInTouchEvent = false;
+        if (mDragState == STOPPED) {
+            mDragState = IDLE;
+        }
+        mCurrFloatAlpha = mFloatAlpha;
+        mListViewIntercepted = false;
+        mChildHeightCache.clear();
+    }
+
+    private void saveTouchCoords(MotionEvent ev) {
+        int action = ev.getAction() & MotionEvent.ACTION_MASK;
+        if (action != MotionEvent.ACTION_DOWN) {
+            mLastX = mX;
+            mLastY = mY;
+        }
+        mX = (int) ev.getX();
+        mY = (int) ev.getY();
+        if (action == MotionEvent.ACTION_DOWN) {
+            mLastX = mX;
+            mLastY = mY;
+        }
+        mOffsetX = (int) ev.getRawX() - mX;
+        mOffsetY = (int) ev.getRawY() - mY;
+    }
+
+    public boolean listViewIntercepted() {
+        return mListViewIntercepted;
+    }
+
+    private boolean mListViewIntercepted = false;
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent ev) {
+        if (!mDragEnabled) {
+            return super.onInterceptTouchEvent(ev);
+        }
+
+        saveTouchCoords(ev);
+        mLastCallWasIntercept = true;
+
+        int action = ev.getAction() & MotionEvent.ACTION_MASK;
+
+        if (action == MotionEvent.ACTION_DOWN) {
+            if (mDragState != IDLE) {
+                // intercept and ignore
+                mIgnoreTouchEvent = true;
+                return true;
+            }
+            mInTouchEvent = true;
+        }
+
+        boolean intercept = false;
+
+        // the following deals with calls to super.onInterceptTouchEvent
+        if (mFloatView != null) {
+            // super's touch event canceled in startDrag
+            intercept = true;
+        } else {
+            if (super.onInterceptTouchEvent(ev)) {
+                mListViewIntercepted = true;
+                intercept = true;
+            }
+
+            switch (action) {
+                case MotionEvent.ACTION_CANCEL:
+                case MotionEvent.ACTION_UP:
+                    doActionUpOrCancel();
+                    break;
+                default:
+                    if (intercept) {
+                        mCancelMethod = ON_TOUCH_EVENT;
+                    } else {
+                        mCancelMethod = ON_INTERCEPT_TOUCH_EVENT;
+                    }
+            }
+        }
+
+        if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
+            mInTouchEvent = false;
+        }
+
+        return intercept;
+    }
+
+    /**
+     * Set the width of each drag scroll region by specifying
+     * a fraction of the ListView height.
+     *
+     * @param heightFraction Fraction of ListView height. Capped at
+     * 0.5f.
+     *
+     */
+    public void setDragScrollStart(float heightFraction) {
+        setDragScrollStarts(heightFraction, heightFraction);
+    }
+
+    /**
+     * Set the width of each drag scroll region by specifying
+     * a fraction of the ListView height.
+     *
+     * @param upperFrac Fraction of ListView height for up-scroll bound.
+     * Capped at 0.5f.
+     * @param lowerFrac Fraction of ListView height for down-scroll bound.
+     * Capped at 0.5f.
+     *
+     */
+    public void setDragScrollStarts(float upperFrac, float lowerFrac) {
+        if (lowerFrac > 0.5f) {
+            mDragDownScrollStartFrac = 0.5f;
+        } else {
+            mDragDownScrollStartFrac = lowerFrac;
+        }
+
+        if (upperFrac > 0.5f) {
+            mDragUpScrollStartFrac = 0.5f;
+        } else {
+            mDragUpScrollStartFrac = upperFrac;
+        }
+
+        if (getHeight() != 0) {
+            updateScrollStarts();
+        }
+    }
+
+    private void continueDrag(int x, int y) {
+
+        // proposed position
+        mFloatLoc.x = x - mDragDeltaX;
+        mFloatLoc.y = y - mDragDeltaY;
+
+        doDragFloatView(true);
+
+        int minY = Math.min(y, mFloatViewMid + mFloatViewHeightHalf);
+        int maxY = Math.max(y, mFloatViewMid - mFloatViewHeightHalf);
+
+        // get the current scroll direction
+        int currentScrollDir = mDragScroller.getScrollDir();
+
+        if (minY > mLastY && minY > mDownScrollStartY && currentScrollDir != DragScroller.DOWN) {
+            // dragged down, it is below the down scroll start and it is not
+            // scrolling up
+
+            if (currentScrollDir != DragScroller.STOP) {
+                // moved directly from up scroll to down scroll
+                mDragScroller.stopScrolling(true);
+            }
+
+            // start scrolling down
+            mDragScroller.startScrolling(DragScroller.DOWN);
+        } else if (maxY < mLastY && maxY < mUpScrollStartY && currentScrollDir != DragScroller.UP) {
+            // dragged up, it is above the up scroll start and it is not
+            // scrolling up
+
+            if (currentScrollDir != DragScroller.STOP) {
+                // moved directly from down scroll to up scroll
+                mDragScroller.stopScrolling(true);
+            }
+
+            // start scrolling up
+            mDragScroller.startScrolling(DragScroller.UP);
+        }
+        else if (maxY >= mUpScrollStartY && minY <= mDownScrollStartY
+                && mDragScroller.isScrolling()) {
+            // not in the upper nor in the lower drag-scroll regions but it is
+            // still scrolling
+
+            mDragScroller.stopScrolling(true);
+        }
+    }
+
+    private void updateScrollStarts() {
+        final int padTop = getPaddingTop();
+        final int listHeight = getHeight() - padTop - getPaddingBottom();
+        float heightF = (float) listHeight;
+
+        mUpScrollStartYF = padTop + mDragUpScrollStartFrac * heightF;
+        mDownScrollStartYF = padTop + (1.0f - mDragDownScrollStartFrac) * heightF;
+
+        mUpScrollStartY = (int) mUpScrollStartYF;
+        mDownScrollStartY = (int) mDownScrollStartYF;
+
+        mDragUpScrollHeight = mUpScrollStartYF - padTop;
+        mDragDownScrollHeight = padTop + listHeight - mDownScrollStartYF;
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+        updateScrollStarts();
+    }
+
+    private void adjustAllItems() {
+        final int first = getFirstVisiblePosition();
+        final int last = getLastVisiblePosition();
+
+        int begin = Math.max(0, getHeaderViewsCount() - first);
+        int end = Math.min(last - first, getCount() - 1 - getFooterViewsCount() - first);
+
+        for (int i = begin; i <= end; ++i) {
+            View v = getChildAt(i);
+            if (v != null) {
+                adjustItem(first + i, v, false);
+            }
+        }
+    }
+
+    private void adjustItem(int position) {
+        View v = getChildAt(position - getFirstVisiblePosition());
+
+        if (v != null) {
+            adjustItem(position, v, false);
+        }
+    }
+
+    /**
+     * Sets layout param height, gravity, and visibility  on
+     * wrapped item.
+     */
+    private void adjustItem(int position, View v, boolean invalidChildHeight) {
+
+        // Adjust item height
+        ViewGroup.LayoutParams lp = v.getLayoutParams();
+        int height;
+        if (position != mSrcPos && position != mFirstExpPos && position != mSecondExpPos) {
+            height = ViewGroup.LayoutParams.WRAP_CONTENT;
+        } else {
+            height = calcItemHeight(position, v, invalidChildHeight);
+        }
+
+        if (height != lp.height) {
+            lp.height = height;
+            v.setLayoutParams(lp);
+        }
+
+        // Adjust item gravity
+        if (position == mFirstExpPos || position == mSecondExpPos) {
+            if (position < mSrcPos) {
+                ((DragSortItemView) v).setGravity(Gravity.BOTTOM);
+            } else if (position > mSrcPos) {
+                ((DragSortItemView) v).setGravity(Gravity.TOP);
+            }
+        }
+
+        // Finally adjust item visibility
+
+        int oldVis = v.getVisibility();
+        int vis = View.VISIBLE;
+
+        if (position == mSrcPos && mFloatView != null) {
+            vis = View.INVISIBLE;
+        }
+
+        if (vis != oldVis) {
+            v.setVisibility(vis);
+        }
+    }
+
+    private int getChildHeight(int position) {
+        if (position == mSrcPos) {
+            return 0;
+        }
+
+        View v = getChildAt(position - getFirstVisiblePosition());
+
+        if (v != null) {
+            // item is onscreen, therefore child height is valid,
+            // hence the "true"
+            return getChildHeight(position, v, false);
+        } else {
+            // item is offscreen
+            // first check cache for child height at this position
+            int childHeight = mChildHeightCache.get(position);
+            if (childHeight != -1) {
+                // Log.d("mobeta", "found child height in cache!");
+                return childHeight;
+            }
+
+            final ListAdapter adapter = getAdapter();
+            int type = adapter.getItemViewType(position);
+
+            // There might be a better place for checking for the following
+            final int typeCount = adapter.getViewTypeCount();
+            if (typeCount != mSampleViewTypes.length) {
+                mSampleViewTypes = new View[typeCount];
+            }
+
+            if (type >= 0) {
+                if (mSampleViewTypes[type] == null) {
+                    v = adapter.getView(position, null, this);
+                    mSampleViewTypes[type] = v;
+                } else {
+                    v = adapter.getView(position, mSampleViewTypes[type], this);
+                }
+            } else {
+                // type is HEADER_OR_FOOTER or IGNORE
+                v = adapter.getView(position, null, this);
+            }
+
+            // current child height is invalid, hence "true" below
+            childHeight = getChildHeight(position, v, true);
+
+            // cache it because this could have been expensive
+            mChildHeightCache.add(position, childHeight);
+
+            return childHeight;
+        }
+    }
+
+    private int getChildHeight(int position, View item, boolean invalidChildHeight) {
+        if (position == mSrcPos) {
+            return 0;
+        }
+
+        View child;
+        if (position < getHeaderViewsCount() || position >= getCount() - getFooterViewsCount()) {
+            child = item;
+        } else {
+            child = ((ViewGroup) item).getChildAt(0);
+        }
+
+        ViewGroup.LayoutParams lp = child.getLayoutParams();
+
+        if (lp != null) {
+            if (lp.height > 0) {
+                return lp.height;
+            }
+        }
+
+        int childHeight = child.getHeight();
+
+        if (childHeight == 0 || invalidChildHeight) {
+            measureItem(child);
+            childHeight = child.getMeasuredHeight();
+        }
+
+        return childHeight;
+    }
+
+    private int calcItemHeight(int position, View item, boolean invalidChildHeight) {
+        return calcItemHeight(position, getChildHeight(position, item, invalidChildHeight));
+    }
+
+    private int calcItemHeight(int position, int childHeight) {
+
+        int divHeight = getDividerHeight();
+
+        boolean isSliding = mAnimate && mFirstExpPos != mSecondExpPos;
+        int maxNonSrcBlankHeight = mFloatViewHeight - mItemHeightCollapsed;
+        int slideHeight = (int) (mSlideFrac * maxNonSrcBlankHeight);
+
+        int height;
+
+        if (position == mSrcPos) {
+            if (mSrcPos == mFirstExpPos) {
+                if (isSliding) {
+                    height = slideHeight + mItemHeightCollapsed;
+                } else {
+                    height = mFloatViewHeight;
+                }
+            } else if (mSrcPos == mSecondExpPos) {
+                // if gets here, we know an item is sliding
+                height = mFloatViewHeight - slideHeight;
+            } else {
+                height = mItemHeightCollapsed;
+            }
+        } else if (position == mFirstExpPos) {
+            if (isSliding) {
+                height = childHeight + slideHeight;
+            } else {
+                height = childHeight + maxNonSrcBlankHeight;
+            }
+        } else if (position == mSecondExpPos) {
+            // we know an item is sliding (b/c 2ndPos != 1stPos)
+            height = childHeight + maxNonSrcBlankHeight - slideHeight;
+        } else {
+            height = childHeight;
+        }
+
+        return height;
+    }
+
+    @Override
+    public void requestLayout() {
+        if (!mBlockLayoutRequests) {
+            super.requestLayout();
+        }
+    }
+
+    private int adjustScroll(int movePos, View moveItem, int oldFirstExpPos, int oldSecondExpPos) {
+        int adjust = 0;
+
+        final int childHeight = getChildHeight(movePos);
+
+        int moveHeightBefore = moveItem.getHeight();
+        int moveHeightAfter = calcItemHeight(movePos, childHeight);
+
+        int moveBlankBefore = moveHeightBefore;
+        int moveBlankAfter = moveHeightAfter;
+        if (movePos != mSrcPos) {
+            moveBlankBefore -= childHeight;
+            moveBlankAfter -= childHeight;
+        }
+
+        int maxBlank = mFloatViewHeight;
+        if (mSrcPos != mFirstExpPos && mSrcPos != mSecondExpPos) {
+            maxBlank -= mItemHeightCollapsed;
+        }
+
+        if (movePos <= oldFirstExpPos) {
+            if (movePos > mFirstExpPos) {
+                adjust += maxBlank - moveBlankAfter;
+            }
+        } else if (movePos == oldSecondExpPos) {
+            if (movePos <= mFirstExpPos) {
+                adjust += moveBlankBefore - maxBlank;
+            } else if (movePos == mSecondExpPos) {
+                adjust += moveHeightBefore - moveHeightAfter;
+            } else {
+                adjust += moveBlankBefore;
+            }
+        } else {
+            if (movePos <= mFirstExpPos) {
+                adjust -= maxBlank;
+            } else if (movePos == mSecondExpPos) {
+                adjust -= moveBlankAfter;
+            }
+        }
+
+        return adjust;
+    }
+
+    private void measureItem(View item) {
+        ViewGroup.LayoutParams lp = item.getLayoutParams();
+        if (lp == null) {
+            lp = new AbsListView.LayoutParams(
+                    ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
+            item.setLayoutParams(lp);
+        }
+        int wspec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, getListPaddingLeft()
+                + getListPaddingRight(), lp.width);
+        int hspec;
+        if (lp.height > 0) {
+            hspec = MeasureSpec.makeMeasureSpec(lp.height, MeasureSpec.EXACTLY);
+        } else {
+            hspec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+        }
+        item.measure(wspec, hspec);
+    }
+
+    private void measureFloatView() {
+        if (mFloatView != null) {
+            measureItem(mFloatView);
+            mFloatViewHeight = mFloatView.getMeasuredHeight();
+            mFloatViewHeightHalf = mFloatViewHeight / 2;
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        // Log.d("mobeta", "onMeasure called");
+        if (mFloatView != null) {
+            if (mFloatView.isLayoutRequested()) {
+                measureFloatView();
+            }
+            mFloatViewOnMeasured = true; // set to false after layout
+        }
+        mWidthMeasureSpec = widthMeasureSpec;
+    }
+
+    @Override
+    protected void layoutChildren() {
+        super.layoutChildren();
+
+        if (mFloatView != null) {
+            if (mFloatView.isLayoutRequested() && !mFloatViewOnMeasured) {
+                // Have to measure here when usual android measure
+                // pass is skipped. This happens during a drag-sort
+                // when layoutChildren is called directly.
+                measureFloatView();
+            }
+            mFloatView.layout(0, 0, mFloatView.getMeasuredWidth(), mFloatView.getMeasuredHeight());
+            mFloatViewOnMeasured = false;
+        }
+    }
+
+    protected boolean onDragTouchEvent(MotionEvent ev) {
+        // we are in a drag
+        int action = ev.getAction() & MotionEvent.ACTION_MASK;
+
+        switch (ev.getAction() & MotionEvent.ACTION_MASK) {
+            case MotionEvent.ACTION_CANCEL:
+                if (mDragState == DRAGGING) {
+                    cancelDrag();
+                }
+                doActionUpOrCancel();
+                break;
+            case MotionEvent.ACTION_UP:
+                // Log.d("mobeta", "calling stopDrag from onDragTouchEvent");
+                if (mDragState == DRAGGING) {
+                    stopDrag(false);
+                }
+                doActionUpOrCancel();
+                break;
+            case MotionEvent.ACTION_MOVE:
+                continueDrag((int) ev.getX(), (int) ev.getY());
+                break;
+        }
+
+        return true;
+    }
+
+    private boolean mFloatViewInvalidated = false;
+
+    private void invalidateFloatView() {
+        mFloatViewInvalidated = true;
+    }
+
+    /**
+     * Start a drag of item at <code>position</code> using the
+     * registered FloatViewManager. Calls through
+     * to {@link #startDrag(int,View,int,int,int)} after obtaining
+     * the floating View from the FloatViewManager.
+     *
+     * @param position Item to drag.
+     * @param dragFlags Flags that restrict some movements of the
+     * floating View. For example, set <code>dragFlags |=
+     * ~{@link #DRAG_NEG_X}</code> to allow dragging the floating
+     * View in all directions except off the screen to the left.
+     * @param deltaX Offset in x of the touch coordinate from the
+     * left edge of the floating View (i.e. touch-x minus float View
+     * left).
+     * @param deltaY Offset in y of the touch coordinate from the
+     * top edge of the floating View (i.e. touch-y minus float View
+     * top).
+     *
+     * @return True if the drag was started, false otherwise. This
+     * <code>startDrag</code> will fail if we are not currently in
+     * a touch event, there is no registered FloatViewManager,
+     * or the FloatViewManager returns a null View.
+     */
+    public boolean startDrag(int position, int dragFlags, int deltaX, int deltaY) {
+        if (!mInTouchEvent || mFloatViewManager == null) {
+            return false;
+        }
+
+        View v = mFloatViewManager.onCreateFloatView(position);
+
+        if (v == null) {
+            return false;
+        } else {
+            return startDrag(position, v, dragFlags, deltaX, deltaY);
+        }
+
+    }
+
+    /**
+     * Start a drag of item at <code>position</code> without using
+     * a FloatViewManager.
+     *
+     * @param position Item to drag.
+     * @param floatView Floating View.
+     * @param dragFlags Flags that restrict some movements of the
+     * floating View. For example, set <code>dragFlags |=
+     * ~{@link #DRAG_NEG_X}</code> to allow dragging the floating
+     * View in all directions except off the screen to the left.
+     * @param deltaX Offset in x of the touch coordinate from the
+     * left edge of the floating View (i.e. touch-x minus float View
+     * left).
+     * @param deltaY Offset in y of the touch coordinate from the
+     * top edge of the floating View (i.e. touch-y minus float View
+     * top).
+     *
+     * @return True if the drag was started, false otherwise. This
+     * <code>startDrag</code> will fail if we are not currently in
+     * a touch event, <code>floatView</code> is null, or there is
+     * a drag in progress.
+     */
+    public boolean startDrag(int position, View floatView, int dragFlags, int deltaX, int deltaY) {
+        if (mDragState != IDLE || !mInTouchEvent || mFloatView != null || floatView == null
+                || !mDragEnabled) {
+            return false;
+        }
+
+        if (getParent() != null) {
+            getParent().requestDisallowInterceptTouchEvent(true);
+        }
+
+        int pos = position + getHeaderViewsCount();
+        mFirstExpPos = pos;
+        mSecondExpPos = pos;
+        mSrcPos = pos;
+        mFloatPos = pos;
+
+        // mDragState = dragType;
+        mDragState = DRAGGING;
+        mDragFlags = 0;
+        mDragFlags |= dragFlags;
+
+        mFloatView = floatView;
+        measureFloatView(); // sets mFloatViewHeight
+
+        mDragDeltaX = deltaX;
+        mDragDeltaY = deltaY;
+        mDragStartY = mY;
+
+        // updateFloatView(mX - mDragDeltaX, mY - mDragDeltaY);
+        mFloatLoc.x = mX - mDragDeltaX;
+        mFloatLoc.y = mY - mDragDeltaY;
+
+        // set src item invisible
+        final View srcItem = getChildAt(mSrcPos - getFirstVisiblePosition());
+
+        if (srcItem != null) {
+            srcItem.setVisibility(View.INVISIBLE);
+        }
+
+        if (mTrackDragSort) {
+            mDragSortTracker.startTracking();
+        }
+
+        // once float view is created, events are no longer passed
+        // to ListView
+        switch (mCancelMethod) {
+            case ON_TOUCH_EVENT:
+                super.onTouchEvent(mCancelEvent);
+                break;
+            case ON_INTERCEPT_TOUCH_EVENT:
+                super.onInterceptTouchEvent(mCancelEvent);
+                break;
+        }
+
+        requestLayout();
+
+        if (mLiftAnimator != null) {
+            mLiftAnimator.start();
+        }
+
+        return true;
+    }
+
+    private void doDragFloatView(boolean forceInvalidate) {
+        int movePos = getFirstVisiblePosition() + getChildCount() / 2;
+        View moveItem = getChildAt(getChildCount() / 2);
+
+        if (moveItem == null) {
+            return;
+        }
+
+        doDragFloatView(movePos, moveItem, forceInvalidate);
+    }
+
+    private void doDragFloatView(int movePos, View moveItem, boolean forceInvalidate) {
+        mBlockLayoutRequests = true;
+
+        updateFloatView();
+
+        int oldFirstExpPos = mFirstExpPos;
+        int oldSecondExpPos = mSecondExpPos;
+
+        boolean updated = updatePositions();
+
+        if (updated) {
+            adjustAllItems();
+            int scroll = adjustScroll(movePos, moveItem, oldFirstExpPos, oldSecondExpPos);
+            // Log.d("mobeta", "  adjust scroll="+scroll);
+
+            setSelectionFromTop(movePos, moveItem.getTop() + scroll - getPaddingTop());
+            layoutChildren();
+        }
+
+        if (updated || forceInvalidate) {
+            invalidate();
+        }
+
+        mBlockLayoutRequests = false;
+    }
+
+    /**
+     * Sets float View location based on suggested values and
+     * constraints set in mDragFlags.
+     */
+    private void updateFloatView() {
+
+        if (mFloatViewManager != null) {
+            mTouchLoc.set(mX, mY);
+            mFloatViewManager.onDragFloatView(mFloatView, mFloatLoc, mTouchLoc);
+        }
+
+        final int floatX = mFloatLoc.x;
+        final int floatY = mFloatLoc.y;
+
+        // restrict x motion
+        int padLeft = getPaddingLeft();
+        if ((mDragFlags & DRAG_POS_X) == 0 && floatX > padLeft) {
+            mFloatLoc.x = padLeft;
+        } else if ((mDragFlags & DRAG_NEG_X) == 0 && floatX < padLeft) {
+            mFloatLoc.x = padLeft;
+        }
+
+        // keep floating view from going past bottom of last header view
+        final int numHeaders = getHeaderViewsCount();
+        final int numFooters = getFooterViewsCount();
+        final int firstPos = getFirstVisiblePosition();
+        final int lastPos = getLastVisiblePosition();
+
+        // Log.d("mobeta",
+        // "nHead="+numHeaders+" nFoot="+numFooters+" first="+firstPos+" last="+lastPos);
+        int topLimit = getPaddingTop();
+        if (firstPos < numHeaders) {
+            topLimit = getChildAt(numHeaders - firstPos - 1).getBottom();
+        }
+        if ((mDragFlags & DRAG_NEG_Y) == 0) {
+            if (firstPos <= mSrcPos) {
+                topLimit = Math.max(getChildAt(mSrcPos - firstPos).getTop(), topLimit);
+            }
+        }
+        // bottom limit is top of first footer View or
+        // bottom of last item in list
+        int bottomLimit = getHeight() - getPaddingBottom();
+        if (lastPos >= getCount() - numFooters - 1) {
+            bottomLimit = getChildAt(getCount() - numFooters - 1 - firstPos).getBottom();
+        }
+        if ((mDragFlags & DRAG_POS_Y) == 0) {
+            if (lastPos >= mSrcPos) {
+                bottomLimit = Math.min(getChildAt(mSrcPos - firstPos).getBottom(), bottomLimit);
+            }
+        }
+
+        // Log.d("mobeta", "dragView top=" + (y - mDragDeltaY));
+        // Log.d("mobeta", "limit=" + limit);
+        // Log.d("mobeta", "mDragDeltaY=" + mDragDeltaY);
+
+        if (floatY < topLimit) {
+            mFloatLoc.y = topLimit;
+        } else if (floatY + mFloatViewHeight > bottomLimit) {
+            mFloatLoc.y = bottomLimit - mFloatViewHeight;
+        }
+
+        // get y-midpoint of floating view (constrained to ListView bounds)
+        mFloatViewMid = mFloatLoc.y + mFloatViewHeightHalf;
+    }
+
+    private void destroyFloatView() {
+        if (mFloatView != null) {
+            mFloatView.setVisibility(GONE);
+            if (mFloatViewManager != null) {
+                mFloatViewManager.onDestroyFloatView(mFloatView);
+            }
+            mFloatView = null;
+            invalidate();
+        }
+    }
+
+    /**
+     * Interface for customization of the floating View appearance
+     * and dragging behavior. Implement
+     * your own and pass it to {@link #setFloatViewManager}. If
+     * your own is not passed, the default {@link SimpleFloatViewManager}
+     * implementation is used.
+     */
+    public interface FloatViewManager {
+        /**
+         * Return the floating View for item at <code>position</code>.
+         * DragSortListView will measure and layout this View for you,
+         * so feel free to just inflate it. You can help DSLV by
+         * setting some {@link ViewGroup.LayoutParams} on this View;
+         * otherwise it will set some for you (with a width of FILL_PARENT
+         * and a height of WRAP_CONTENT).
+         *
+         * @param position Position of item to drag (NOTE:
+         * <code>position</code> excludes header Views; thus, if you
+         * want to call {@link ListView#getChildAt(int)}, you will need
+         * to add {@link ListView#getHeaderViewsCount()} to the index).
+         *
+         * @return The View you wish to display as the floating View.
+         */
+        public View onCreateFloatView(int position);
+
+        /**
+         * Called whenever the floating View is dragged. Float View
+         * properties can be changed here. Also, the upcoming location
+         * of the float View can be altered by setting
+         * <code>location.x</code> and <code>location.y</code>.
+         *
+         * @param floatView The floating View.
+         * @param location The location (top-left; relative to DSLV
+         * top-left) at which the float
+         * View would like to appear, given the current touch location
+         * and the offset provided in {@link DragSortListView#startDrag}.
+         * @param touch The current touch location (relative to DSLV
+         * top-left).
+         * @param pendingScroll
+         */
+        public void onDragFloatView(View floatView, Point location, Point touch);
+
+        /**
+         * Called when the float View is dropped; lets you perform
+         * any necessary cleanup. The internal DSLV floating View
+         * reference is set to null immediately after this is called.
+         *
+         * @param floatView The floating View passed to
+         * {@link #onCreateFloatView(int)}.
+         */
+        public void onDestroyFloatView(View floatView);
+    }
+
+    public void setFloatViewManager(FloatViewManager manager) {
+        mFloatViewManager = manager;
+    }
+
+    public void setDragListener(DragListener l) {
+        mDragListener = l;
+    }
+
+    /**
+     * Allows for easy toggling between a DragSortListView
+     * and a regular old ListView. If enabled, items are
+     * draggable, where the drag init mode determines how
+     * items are lifted (see {@link setDragInitMode(int)}).
+     * If disabled, items cannot be dragged.
+     *
+     * @param enabled Set <code>true</code> to enable list
+     * item dragging
+     */
+    public void setDragEnabled(boolean enabled) {
+        mDragEnabled = enabled;
+    }
+
+    public boolean isDragEnabled() {
+        return mDragEnabled;
+    }
+
+    /**
+     * This better reorder your ListAdapter! DragSortListView does not do this
+     * for you; doesn't make sense to. Make sure
+     * {@link BaseAdapter#notifyDataSetChanged()} or something like it is called
+     * in your implementation. Furthermore, if you have a choiceMode other than
+     * none and the ListAdapter does not return true for
+     * {@link ListAdapter#hasStableIds()}, you will need to call
+     * {@link #moveCheckState(int, int)} to move the check boxes along with the
+     * list items.
+     *
+     * @param l
+     */
+    public void setDropListener(DropListener l) {
+        mDropListener = l;
+    }
+
+    /**
+     * Probably a no-brainer, but make sure that your remove listener
+     * calls {@link BaseAdapter#notifyDataSetChanged()} or something like it.
+     * When an item removal occurs, DragSortListView
+     * relies on a redraw of all the items to recover invisible views
+     * and such. Strictly speaking, if you remove something, your dataset
+     * has changed...
+     *
+     * @param l
+     */
+    public void setRemoveListener(RemoveListener l) {
+        mRemoveListener = l;
+    }
+
+    public interface DragListener {
+        public void drag(int from, int to);
+    }
+
+    /**
+     * Your implementation of this has to reorder your ListAdapter!
+     * Make sure to call
+     * {@link BaseAdapter#notifyDataSetChanged()} or something like it
+     * in your implementation.
+     *
+     * @author heycosmo
+     *
+     */
+    public interface DropListener {
+        public void drop(int from, int to);
+    }
+
+    /**
+     * Make sure to call
+     * {@link BaseAdapter#notifyDataSetChanged()} or something like it
+     * in your implementation.
+     *
+     * @author heycosmo
+     *
+     */
+    public interface RemoveListener {
+        public void remove(int which);
+    }
+
+    public interface DragSortListener extends DropListener, DragListener, RemoveListener {
+    }
+
+    public void setDragSortListener(DragSortListener l) {
+        setDropListener(l);
+        setDragListener(l);
+        setRemoveListener(l);
+    }
+
+    /**
+     * Completely custom scroll speed profile. Default increases linearly
+     * with position and is constant in time. Create your own by implementing
+     * {@link DragSortListView.DragScrollProfile}.
+     *
+     * @param ssp
+     */
+    public void setDragScrollProfile(DragScrollProfile ssp) {
+        if (ssp != null) {
+            mScrollProfile = ssp;
+        }
+    }
+
+    /**
+     * Use this to move the check state of an item from one position to another
+     * in a drop operation. If you have a choiceMode which is not none, this
+     * method must be called when the order of items changes in an underlying
+     * adapter which does not have stable IDs (see
+     * {@link ListAdapter#hasStableIds()}). This is because without IDs, the
+     * ListView has no way of knowing which items have moved where, and cannot
+     * update the check state accordingly.
+     * <p>
+     * A word of warning about a "feature" in Android that you may run into when
+     * dealing with movable list items: for an adapter that <em>does</em> have
+     * stable IDs, ListView will attempt to locate each item based on its ID and
+     * move the check state from the item's old position to the new position —
+     * which is all fine and good (and removes the need for calling this
+     * function), except for the half-baked approach. Apparently to save time in
+     * the naive algorithm used, ListView will only search for an ID in the
+     * close neighborhood of the old position. If the user moves an item too far
+     * (specifically, more than 20 rows away), ListView will give up and just
+     * force the item to be unchecked. So if there is a reasonable chance that
+     * the user will move items more than 20 rows away from the original
+     * position, you may wish to use an adapter with unstable IDs and call this
+     * method manually instead.
+     *
+     * @param from
+     * @param to
+     */
+    public void moveCheckState(int from, int to) {
+        // This method runs in O(n log n) time (n being the number of list
+        // items). The bottleneck is the call to AbsListView.setItemChecked,
+        // which is O(log n) because of the binary search involved in calling
+        // SparseBooleanArray.put().
+        //
+        // To improve on the average time, we minimize the number of calls to
+        // setItemChecked by only calling it for items that actually have a
+        // changed state. This is achieved by building a list containing the
+        // start and end of the "runs" of checked items, and then moving the
+        // runs. Note that moving an item from A to B is essentially a rotation
+        // of the range of items in [A, B]. Let's say we have
+        // . . U V X Y Z . .
+        // and move U after Z. This is equivalent to a rotation one step to the
+        // left within the range you are moving across:
+        // . . V X Y Z U . .
+        //
+        // So, to perform the move we enumerate all the runs within the move
+        // range, then rotate each run one step to the left or right (depending
+        // on move direction). For example, in the list:
+        // X X . X X X . X
+        // we have two runs. One begins at the last item of the list and wraps
+        // around to the beginning, ending at position 1. The second begins at
+        // position 3 and ends at position 5. To rotate a run, regardless of
+        // length, we only need to set a check mark at one end of the run, and
+        // clear a check mark at the other end:
+        // X . X X X . X X
+        SparseBooleanArray cip = getCheckedItemPositions();
+        int rangeStart = from;
+        int rangeEnd = to;
+        if (to < from) {
+            rangeStart = to;
+            rangeEnd = from;
+        }
+        rangeEnd += 1;
+
+        int[] runStart = new int[cip.size()];
+        int[] runEnd = new int[cip.size()];
+        int runCount = buildRunList(cip, rangeStart, rangeEnd, runStart, runEnd);
+        if (runCount == 1 && (runStart[0] == runEnd[0])) {
+            // Special case where all items are checked, we can never set any
+            // item to false like we do below.
+            return;
+        }
+
+        if (from < to) {
+            for (int i = 0; i != runCount; i++) {
+                setItemChecked(rotate(runStart[i], -1, rangeStart, rangeEnd), true);
+                setItemChecked(rotate(runEnd[i], -1, rangeStart, rangeEnd), false);
+            }
+
+        } else {
+            for (int i = 0; i != runCount; i++) {
+                setItemChecked(runStart[i], false);
+                setItemChecked(runEnd[i], true);
+            }
+        }
+    }
+
+    /**
+     * Use this when an item has been deleted, to move the check state of all
+     * following items up one step. If you have a choiceMode which is not none,
+     * this method must be called when the order of items changes in an
+     * underlying adapter which does not have stable IDs (see
+     * {@link ListAdapter#hasStableIds()}). This is because without IDs, the
+     * ListView has no way of knowing which items have moved where, and cannot
+     * update the check state accordingly.
+     *
+     * See also further comments on {@link #moveCheckState(int, int)}.
+     *
+     * @param position
+     */
+    public void removeCheckState(int position) {
+        SparseBooleanArray cip = getCheckedItemPositions();
+
+        if (cip.size() == 0)
+            return;
+        int[] runStart = new int[cip.size()];
+        int[] runEnd = new int[cip.size()];
+        int rangeStart = position;
+        int rangeEnd = cip.keyAt(cip.size() - 1) + 1;
+        int runCount = buildRunList(cip, rangeStart, rangeEnd, runStart, runEnd);
+        for (int i = 0; i != runCount; i++) {
+            if (!(runStart[i] == position || (runEnd[i] < runStart[i] && runEnd[i] > position))) {
+                // Only set a new check mark in front of this run if it does
+                // not contain the deleted position. If it does, we only need
+                // to make it one check mark shorter at the end.
+                setItemChecked(rotate(runStart[i], -1, rangeStart, rangeEnd), true);
+            }
+            setItemChecked(rotate(runEnd[i], -1, rangeStart, rangeEnd), false);
+        }
+    }
+
+    private static int buildRunList(SparseBooleanArray cip, int rangeStart,
+            int rangeEnd, int[] runStart, int[] runEnd) {
+        int runCount = 0;
+
+        int i = findFirstSetIndex(cip, rangeStart, rangeEnd);
+        if (i == -1)
+            return 0;
+
+        int position = cip.keyAt(i);
+        int currentRunStart = position;
+        int currentRunEnd = currentRunStart + 1;
+        for (i++; i < cip.size() && (position = cip.keyAt(i)) < rangeEnd; i++) {
+            if (!cip.valueAt(i)) // not checked => not interesting
+                continue;
+            if (position == currentRunEnd) {
+                currentRunEnd++;
+            } else {
+                runStart[runCount] = currentRunStart;
+                runEnd[runCount] = currentRunEnd;
+                runCount++;
+                currentRunStart = position;
+                currentRunEnd = position + 1;
+            }
+        }
+
+        if (currentRunEnd == rangeEnd) {
+            // rangeStart and rangeEnd are equivalent positions so to be
+            // consistent we translate them to the same integer value. That way
+            // we can check whether a run covers the entire range by just
+            // checking if the start equals the end position.
+            currentRunEnd = rangeStart;
+        }
+        runStart[runCount] = currentRunStart;
+        runEnd[runCount] = currentRunEnd;
+        runCount++;
+
+        if (runCount > 1) {
+            if (runStart[0] == rangeStart && runEnd[runCount - 1] == rangeStart) {
+                // The last run ends at the end of the range, and the first run
+                // starts at the beginning of the range. So they are actually
+                // part of the same run, except they wrap around the end of the
+                // range. To avoid adjacent runs, we need to merge them.
+                runStart[0] = runStart[runCount - 1];
+                runCount--;
+            }
+        }
+        return runCount;
+    }
+
+    private static int rotate(int value, int offset, int lowerBound, int upperBound) {
+        int windowSize = upperBound - lowerBound;
+
+        value += offset;
+        if (value < lowerBound) {
+            value += windowSize;
+        } else if (value >= upperBound) {
+            value -= windowSize;
+        }
+        return value;
+    }
+
+    private static int findFirstSetIndex(SparseBooleanArray sba, int rangeStart, int rangeEnd) {
+        int size = sba.size();
+        int i = insertionIndexForKey(sba, rangeStart);
+        while (i < size && sba.keyAt(i) < rangeEnd && !sba.valueAt(i))
+            i++;
+        if (i == size || sba.keyAt(i) >= rangeEnd)
+            return -1;
+        return i;
+    }
+
+    private static int insertionIndexForKey(SparseBooleanArray sba, int key) {
+        int low = 0;
+        int high = sba.size();
+        while (high - low > 0) {
+            int middle = (low + high) >> 1;
+            if (sba.keyAt(middle) < key)
+                low = middle + 1;
+            else
+                high = middle;
+        }
+        return low;
+    }
+
+    /**
+     * Interface for controlling
+     * scroll speed as a function of touch position and time. Use
+     * {@link DragSortListView#setDragScrollProfile(DragScrollProfile)} to
+     * set custom profile.
+     *
+     * @author heycosmo
+     *
+     */
+    public interface DragScrollProfile {
+        /**
+         * Return a scroll speed in pixels/millisecond. Always return a
+         * positive number.
+         *
+         * @param w Normalized position in scroll region (i.e. w \in [0,1]).
+         * Small w typically means slow scrolling.
+         * @param t Time (in milliseconds) since start of scroll (handy if you
+         * want scroll acceleration).
+         * @return Scroll speed at position w and time t in pixels/ms.
+         */
+        float getSpeed(float w, long t);
+    }
+
+    private class DragScroller implements Runnable {
+
+        private boolean mAbort;
+
+        private long mPrevTime;
+        private long mCurrTime;
+
+        private int dy;
+        private float dt;
+        private long tStart;
+        private int scrollDir;
+
+        public final static int STOP = -1;
+        public final static int UP = 0;
+        public final static int DOWN = 1;
+
+        private float mScrollSpeed; // pixels per ms
+
+        private boolean mScrolling = false;
+
+        private int mLastHeader;
+        private int mFirstFooter;
+
+        public boolean isScrolling() {
+            return mScrolling;
+        }
+
+        public int getScrollDir() {
+            return mScrolling ? scrollDir : STOP;
+        }
+
+        public DragScroller() {
+        }
+
+        public void startScrolling(int dir) {
+            if (!mScrolling) {
+                // Debug.startMethodTracing("dslv-scroll");
+                mAbort = false;
+                mScrolling = true;
+                tStart = SystemClock.uptimeMillis();
+                mPrevTime = tStart;
+                scrollDir = dir;
+                post(this);
+            }
+        }
+
+        public void stopScrolling(boolean now) {
+            if (now) {
+                DragSortListView.this.removeCallbacks(this);
+                mScrolling = false;
+            } else {
+                mAbort = true;
+            }
+
+            // Debug.stopMethodTracing();
+        }
+
+        @Override
+        public void run() {
+            if (mAbort) {
+                mScrolling = false;
+                return;
+            }
+
+            // Log.d("mobeta", "scroll");
+
+            final int first = getFirstVisiblePosition();
+            final int last = getLastVisiblePosition();
+            final int count = getCount();
+            final int padTop = getPaddingTop();
+            final int listHeight = getHeight() - padTop - getPaddingBottom();
+
+            int minY = Math.min(mY, mFloatViewMid + mFloatViewHeightHalf);
+            int maxY = Math.max(mY, mFloatViewMid - mFloatViewHeightHalf);
+
+            if (scrollDir == UP) {
+                View v = getChildAt(0);
+                // Log.d("mobeta", "vtop="+v.getTop()+" padtop="+padTop);
+                if (v == null) {
+                    mScrolling = false;
+                    return;
+                } else {
+                    if (first == 0 && v.getTop() == padTop) {
+                        mScrolling = false;
+                        return;
+                    }
+                }
+                mScrollSpeed = mScrollProfile.getSpeed((mUpScrollStartYF - maxY)
+                        / mDragUpScrollHeight, mPrevTime);
+            } else {
+                View v = getChildAt(last - first);
+                if (v == null) {
+                    mScrolling = false;
+                    return;
+                } else {
+                    if (last == count - 1 && v.getBottom() <= listHeight + padTop) {
+                        mScrolling = false;
+                        return;
+                    }
+                }
+                mScrollSpeed = -mScrollProfile.getSpeed((minY - mDownScrollStartYF)
+                        / mDragDownScrollHeight, mPrevTime);
+            }
+
+            mCurrTime = SystemClock.uptimeMillis();
+            dt = (float) (mCurrTime - mPrevTime);
+
+            // dy is change in View position of a list item; i.e. positive dy
+            // means user is scrolling up (list item moves down the screen,
+            // remember
+            // y=0 is at top of View).
+            dy = (int) Math.round(mScrollSpeed * dt);
+
+            int movePos;
+            if (dy >= 0) {
+                dy = Math.min(listHeight, dy);
+                movePos = first;
+            } else {
+                dy = Math.max(-listHeight, dy);
+                movePos = last;
+            }
+
+            final View moveItem = getChildAt(movePos - first);
+            int top = moveItem.getTop() + dy;
+
+            if (movePos == 0 && top > padTop) {
+                top = padTop;
+            }
+
+            // always do scroll
+            mBlockLayoutRequests = true;
+
+            setSelectionFromTop(movePos, top - padTop);
+            DragSortListView.this.layoutChildren();
+            invalidate();
+
+            mBlockLayoutRequests = false;
+
+            // scroll means relative float View movement
+            doDragFloatView(movePos, moveItem, false);
+
+            mPrevTime = mCurrTime;
+            // Log.d("mobeta", "  updated prevTime="+mPrevTime);
+
+            post(this);
+        }
+    }
+
+    private class DragSortTracker {
+        StringBuilder mBuilder = new StringBuilder();
+
+        File mFile;
+
+        private int mNumInBuffer = 0;
+        private int mNumFlushes = 0;
+
+        private boolean mTracking = false;
+
+        public DragSortTracker() {
+            File root = Environment.getExternalStorageDirectory();
+            mFile = new File(root, "dslv_state.txt");
+
+            if (!mFile.exists()) {
+                try {
+                    mFile.createNewFile();
+                    Log.d("mobeta", "file created");
+                } catch (IOException e) {
+                    Log.w("mobeta", "Could not create dslv_state.txt");
+                    Log.d("mobeta", e.getMessage());
+                }
+            }
+
+        }
+
+        public void startTracking() {
+            mBuilder.append("<DSLVStates>\n");
+            mNumFlushes = 0;
+            mTracking = true;
+        }
+
+        public void appendState() {
+            if (!mTracking) {
+                return;
+            }
+
+            mBuilder.append("<DSLVState>\n");
+            final int children = getChildCount();
+            final int first = getFirstVisiblePosition();
+            mBuilder.append("    <Positions>");
+            for (int i = 0; i < children; ++i) {
+                mBuilder.append(first + i).append(",");
+            }
+            mBuilder.append("</Positions>\n");
+
+            mBuilder.append("    <Tops>");
+            for (int i = 0; i < children; ++i) {
+                mBuilder.append(getChildAt(i).getTop()).append(",");
+            }
+            mBuilder.append("</Tops>\n");
+            mBuilder.append("    <Bottoms>");
+            for (int i = 0; i < children; ++i) {
+                mBuilder.append(getChildAt(i).getBottom()).append(",");
+            }
+            mBuilder.append("</Bottoms>\n");
+
+            mBuilder.append("    <FirstExpPos>").append(mFirstExpPos).append("</FirstExpPos>\n");
+            mBuilder.append("    <FirstExpBlankHeight>")
+                    .append(getItemHeight(mFirstExpPos) - getChildHeight(mFirstExpPos))
+                    .append("</FirstExpBlankHeight>\n");
+            mBuilder.append("    <SecondExpPos>").append(mSecondExpPos).append("</SecondExpPos>\n");
+            mBuilder.append("    <SecondExpBlankHeight>")
+                    .append(getItemHeight(mSecondExpPos) - getChildHeight(mSecondExpPos))
+                    .append("</SecondExpBlankHeight>\n");
+            mBuilder.append("    <SrcPos>").append(mSrcPos).append("</SrcPos>\n");
+            mBuilder.append("    <SrcHeight>").append(mFloatViewHeight + getDividerHeight())
+                    .append("</SrcHeight>\n");
+            mBuilder.append("    <ViewHeight>").append(getHeight()).append("</ViewHeight>\n");
+            mBuilder.append("    <LastY>").append(mLastY).append("</LastY>\n");
+            mBuilder.append("    <FloatY>").append(mFloatViewMid).append("</FloatY>\n");
+            mBuilder.append("    <ShuffleEdges>");
+            for (int i = 0; i < children; ++i) {
+                mBuilder.append(getShuffleEdge(first + i, getChildAt(i).getTop())).append(",");
+            }
+            mBuilder.append("</ShuffleEdges>\n");
+
+            mBuilder.append("</DSLVState>\n");
+            mNumInBuffer++;
+
+            if (mNumInBuffer > 1000) {
+                flush();
+                mNumInBuffer = 0;
+            }
+        }
+
+        public void flush() {
+            if (!mTracking) {
+                return;
+            }
+
+            // save to file on sdcard
+            try {
+                boolean append = true;
+                if (mNumFlushes == 0) {
+                    append = false;
+                }
+                FileWriter writer = new FileWriter(mFile, append);
+
+                writer.write(mBuilder.toString());
+                mBuilder.delete(0, mBuilder.length());
+
+                writer.flush();
+                writer.close();
+
+                mNumFlushes++;
+            } catch (IOException e) {
+                // do nothing
+            }
+        }
+
+        public void stopTracking() {
+            if (mTracking) {
+                mBuilder.append("</DSLVStates>\n");
+                flush();
+                mTracking = false;
+            }
+        }
+
+    }
+
+}
diff --git a/src/com/android/settings/slim/dslv/SimpleFloatViewManager.java b/src/com/android/settings/slim/dslv/SimpleFloatViewManager.java
new file mode 100644
index 0000000..0091abc
--- /dev/null
+++ b/src/com/android/settings/slim/dslv/SimpleFloatViewManager.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2012 Carl Bauer
+ * Copyright (C) 2014 SlimRoms Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim.dslv;
+
+import android.graphics.Bitmap;
+import android.graphics.Point;
+import android.graphics.Color;
+import android.widget.ListView;
+import android.widget.ImageView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.util.Log;
+
+/**
+ * Simple implementation of the FloatViewManager class. Uses list
+ * items as they appear in the ListView to create the floating View.
+ */
+public class SimpleFloatViewManager implements DragSortListView.FloatViewManager {
+
+    private Bitmap mFloatBitmap;
+
+    private ImageView mImageView;
+
+    private int mFloatBGColor = Color.BLACK;
+
+    private ListView mListView;
+
+    public SimpleFloatViewManager(ListView lv) {
+        mListView = lv;
+    }
+
+    public void setBackgroundColor(int color) {
+        mFloatBGColor = color;
+    }
+
+    /**
+     * This simple implementation creates a Bitmap copy of the
+     * list item currently shown at ListView <code>position</code>.
+     */
+    @Override
+    public View onCreateFloatView(int position) {
+        // Guaranteed that this will not be null? I think so. Nope, got
+        // a NullPointerException once...
+        View v = mListView.getChildAt(
+                position + mListView.getHeaderViewsCount() - mListView.getFirstVisiblePosition());
+
+        if (v == null) {
+            return null;
+        }
+
+        v.setPressed(false);
+
+        // Create a copy of the drawing cache so that it does not get
+        // recycled by the framework when the list tries to clean up memory
+        //v.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);
+        v.setDrawingCacheEnabled(true);
+        mFloatBitmap = Bitmap.createBitmap(v.getDrawingCache());
+        v.setDrawingCacheEnabled(false);
+
+        if (mImageView == null) {
+            mImageView = new ImageView(mListView.getContext());
+        }
+        mImageView.setBackgroundColor(mFloatBGColor);
+        mImageView.setPadding(0, 0, 0, 0);
+        mImageView.setImageBitmap(mFloatBitmap);
+        mImageView.setLayoutParams(new ViewGroup.LayoutParams(v.getWidth(), v.getHeight()));
+
+        return mImageView;
+    }
+
+    /**
+     * This does nothing
+     */
+    @Override
+    public void onDragFloatView(View floatView, Point position, Point touch) {
+        // do nothing
+    }
+
+    /**
+     * Removes the Bitmap from the ImageView created in
+     * onCreateFloatView() and tells the system to recycle it.
+     */
+    @Override
+    public void onDestroyFloatView(View floatView) {
+        ((ImageView) floatView).setImageDrawable(null);
+
+        mFloatBitmap.recycle();
+        mFloatBitmap = null;
+    }
+
+}
diff --git a/src/com/android/settings/slim/fragments/NavbarButtonFragment.java b/src/com/android/settings/slim/fragments/NavbarButtonFragment.java
new file mode 100644
index 0000000..a085512
--- /dev/null
+++ b/src/com/android/settings/slim/fragments/NavbarButtonFragment.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2013-2015 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim.fragments;
+
+import android.os.Bundle;
+import android.preference.Preference;
+import android.preference.Preference.OnPreferenceChangeListener;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ListView;
+
+import com.android.settings.R;
+import com.android.settings.SettingsPreferenceFragment;
+
+public class NavbarButtonFragment extends SettingsPreferenceFragment implements
+        OnPreferenceChangeListener {
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        addPreferencesFromResource(R.xml.navbar_button_fragment);
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater,
+            ViewGroup container, Bundle savedInstanceState) {
+        final View view = super.onCreateView(inflater, container, savedInstanceState);
+        final ListView list = (ListView) view.findViewById(android.R.id.list);
+        // our container already takes care of the padding
+        if (list != null) {
+            int paddingTop = list.getPaddingTop();
+            int paddingBottom = list.getPaddingBottom();
+            list.setPadding(0, paddingTop, 0, paddingBottom);
+        }
+        return view;
+    }
+
+    @Override
+    protected int getMetricsCategory() {
+        return -1;
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        return false;
+    }
+}
diff --git a/src/com/android/settings/slim/util/ShortcutPickerHelper.java b/src/com/android/settings/slim/util/ShortcutPickerHelper.java
new file mode 100644
index 0000000..124b537
--- /dev/null
+++ b/src/com/android/settings/slim/util/ShortcutPickerHelper.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2014 SlimRoms Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.slim.util;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.content.Intent;
+import android.content.Intent.ShortcutIconResource;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.util.Log;
+
+import com.android.settings.R;
+
+import com.android.internal.util.slim.AppHelper;
+
+import java.util.ArrayList;
+
+public class ShortcutPickerHelper {
+
+    public static final int REQUEST_PICK_SHORTCUT = 100;
+    public static final int REQUEST_PICK_APPLICATION = 101;
+    public static final int REQUEST_CREATE_SHORTCUT = 102;
+
+    private Activity mParent;
+    private OnPickListener mListener;
+    private PackageManager mPackageManager;
+    private int lastFragmentId;
+
+    public interface OnPickListener {
+        void shortcutPicked(String uri, String friendlyName, Bitmap bmp, boolean isApplication);
+    }
+
+    public ShortcutPickerHelper(Activity parent, OnPickListener listener) {
+        mParent = parent;
+        mPackageManager = mParent.getPackageManager();
+        mListener = listener;
+    }
+
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (resultCode == Activity.RESULT_OK) {
+            switch (requestCode) {
+                case REQUEST_PICK_APPLICATION:
+                    completeSetCustomApp(data);
+                    break;
+                case REQUEST_CREATE_SHORTCUT:
+                    completeSetCustomShortcut(data);
+                    break;
+                case REQUEST_PICK_SHORTCUT:
+                    processShortcut(data, REQUEST_PICK_APPLICATION, REQUEST_CREATE_SHORTCUT);
+                    break;
+            }
+        }
+    }
+
+    public void pickShortcut(int fragmentId) {
+        pickShortcut(fragmentId, false);
+    }
+
+    public void pickShortcut(int fragmentId, boolean fullAppsOnly) {
+        lastFragmentId = fragmentId;
+
+        if (fullAppsOnly) {
+            Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
+            mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+
+            Intent pickIntent = new Intent(Intent.ACTION_PICK_ACTIVITY);
+            pickIntent.putExtra(Intent.EXTRA_INTENT, mainIntent);
+            startFragmentOrActivity(pickIntent, REQUEST_PICK_APPLICATION);
+        } else {
+            Bundle bundle = new Bundle();
+
+            ArrayList<String> shortcutNames = new ArrayList<String>();
+            shortcutNames.add(mParent.getString(R.string.shortcuts_applications));
+            bundle.putStringArrayList(Intent.EXTRA_SHORTCUT_NAME, shortcutNames);
+
+            ArrayList<ShortcutIconResource> shortcutIcons = new ArrayList<ShortcutIconResource>();
+            shortcutIcons.add(ShortcutIconResource.fromContext(mParent,
+                    android.R.drawable.sym_def_app_icon));
+            bundle.putParcelableArrayList(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, shortcutIcons);
+
+            Intent pickIntent = new Intent(Intent.ACTION_PICK_ACTIVITY);
+            pickIntent.putExtra(Intent.EXTRA_INTENT, new Intent(Intent.ACTION_CREATE_SHORTCUT));
+            pickIntent.putExtra(Intent.EXTRA_TITLE, mParent.getText(
+                    R.string.shortcuts_select_custom_app_title));
+            pickIntent.putExtras(bundle);
+            startFragmentOrActivity(pickIntent, REQUEST_PICK_SHORTCUT);
+        }
+    }
+
+    private void startFragmentOrActivity(Intent pickIntent, int requestCode) {
+        if (lastFragmentId == 0) {
+            mParent.startActivityForResult(pickIntent, requestCode);
+        } else {
+            Fragment cFrag = mParent.getFragmentManager().findFragmentById(lastFragmentId);
+            if (cFrag != null) {
+                mParent.startActivityFromFragment(cFrag, pickIntent, requestCode);
+            }
+        }
+    }
+
+    private void processShortcut(Intent intent,
+        int requestCodeApplication, int requestCodeShortcut) {
+        // Handle case where user selected "Applications"
+        String applicationName = mParent.getResources().getString(R.string.shortcuts_applications);
+        String shortcutName = intent.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
+
+        if (applicationName != null && applicationName.equals(shortcutName)) {
+            Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
+            mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
+
+            Intent pickIntent = new Intent(Intent.ACTION_PICK_ACTIVITY);
+            pickIntent.putExtra(Intent.EXTRA_INTENT, mainIntent);
+            startFragmentOrActivity(pickIntent, requestCodeApplication);
+        } else {
+            startFragmentOrActivity(intent, requestCodeShortcut);
+        }
+    }
+
+    private void completeSetCustomApp(Intent data) {
+        mListener.shortcutPicked(data.toUri(0),
+            AppHelper.getFriendlyActivityName(mParent, mPackageManager, data, false), null, true);
+    }
+
+    private void completeSetCustomShortcut(Intent data) {
+        Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
+        /* preserve shortcut name, we want to restore it later */
+        intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, data.getStringExtra(
+                Intent.EXTRA_SHORTCUT_NAME));
+        String appUri = intent.toUri(0);
+        appUri = appUri.replaceAll("com.android.contacts.action.QUICK_CONTACT",
+                "android.intent.action.VIEW");
+
+        // Check if icon is present
+        Bitmap bmp = null;
+        Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
+        if (extra != null && extra instanceof Bitmap) {
+            bmp = (Bitmap) extra;
+        }
+        // No icon till now check if icon resource is present
+        if (bmp == null) {
+            extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
+            if (extra != null && extra instanceof Intent.ShortcutIconResource) {
+                try {
+                    Intent.ShortcutIconResource iconResource = (ShortcutIconResource) extra;
+                    Resources resources =
+                            mPackageManager.getResourcesForApplication(iconResource.packageName);
+                    final int id = resources.getIdentifier(iconResource.resourceName, null, null);
+                    bmp = BitmapFactory.decodeResource(resources, id);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        mListener.shortcutPicked(appUri,
+                AppHelper.getFriendlyShortcutName(mParent, mPackageManager, intent), bmp, false);
+    }
+
+}
diff --git a/src/net/margaritov/preference/colorpicker/AlphaPatternDrawable.java b/src/net/margaritov/preference/colorpicker/AlphaPatternDrawable.java
new file mode 100644
index 0000000..07736be
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/AlphaPatternDrawable.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2010 Daniel Nilsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+
+/**
+ * This drawable that draws a simple white and gray chessboard pattern.
+ * It's pattern you will often see as a background behind a
+ * partly transparent image in many applications.
+ * @author Daniel Nilsson
+ */
+public class AlphaPatternDrawable extends Drawable {
+
+    private int mRectangleSize = 10;
+
+    private Paint mPaint = new Paint();
+    private Paint mPaintWhite = new Paint();
+    private Paint mPaintGray = new Paint();
+
+    private int numRectanglesHorizontal;
+    private int numRectanglesVertical;
+
+    /**
+     * Bitmap in which the pattern will be cahched.
+     */
+    private Bitmap        mBitmap;
+
+    public AlphaPatternDrawable(int rectangleSize) {
+        mRectangleSize = rectangleSize;
+        mPaintWhite.setColor(0xffffffff);
+        mPaintGray.setColor(0xffcbcbcb);
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        canvas.drawBitmap(mBitmap, null, getBounds(), mPaint);
+    }
+
+    @Override
+    public int getOpacity() {
+        return 0;
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        throw new UnsupportedOperationException("Alpha is not supported by this drawwable.");
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        throw new UnsupportedOperationException("ColorFilter is not supported by this drawwable.");
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+
+        int height = bounds.height();
+        int width = bounds.width();
+
+        numRectanglesHorizontal = (int) Math.ceil((width / mRectangleSize));
+        numRectanglesVertical = (int) Math.ceil(height / mRectangleSize);
+
+        generatePatternBitmap();
+
+    }
+
+    /**
+     * This will generate a bitmap with the pattern
+     * as big as the rectangle we were allow to draw on.
+     * We do this to chache the bitmap so we don't need to
+     * recreate it each time draw() is called since it
+     * takes a few milliseconds.
+     */
+    private void generatePatternBitmap(){
+
+        if(getBounds().width() <= 0 || getBounds().height() <= 0){
+            return;
+        }
+
+        mBitmap = Bitmap.createBitmap(getBounds().width(), getBounds().height(), Config.ARGB_8888);
+        Canvas canvas = new Canvas(mBitmap);
+
+        Rect r = new Rect();
+        boolean verticalStartWhite = true;
+        for (int i = 0; i <= numRectanglesVertical; i++) {
+
+            boolean isWhite = verticalStartWhite;
+            for (int j = 0; j <= numRectanglesHorizontal; j++) {
+
+                r.top = i * mRectangleSize;
+                r.left = j * mRectangleSize;
+                r.bottom = r.top + mRectangleSize;
+                r.right = r.left + mRectangleSize;
+
+                canvas.drawRect(r, isWhite ? mPaintWhite : mPaintGray);
+
+                isWhite = !isWhite;
+            }
+
+            verticalStartWhite = !verticalStartWhite;
+
+        }
+
+    }
+
+}
diff --git a/src/net/margaritov/preference/colorpicker/ColorPickerDialog.java b/src/net/margaritov/preference/colorpicker/ColorPickerDialog.java
new file mode 100644
index 0000000..d456398
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/ColorPickerDialog.java
@@ -0,0 +1,214 @@
+/*
+ * Copyright (C) 2010 Daniel Nilsson
+ * Copyright (C) 2013 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.app.Dialog;
+import android.content.Context;
+import android.graphics.Color;
+import android.graphics.PixelFormat;
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.Window;
+import android.widget.EditText;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+
+import com.android.settings.R;
+
+public class ColorPickerDialog
+        extends
+        Dialog
+        implements
+        ColorPickerView.OnColorChangedListener,
+        View.OnClickListener {
+
+    private ColorPickerView mColorPicker;
+
+    private ColorPickerPanelView mOldColor;
+    private ColorPickerPanelView mNewColor;
+
+    private ColorPickerPanelView mWhite;
+    private ColorPickerPanelView mBlack;
+    private ColorPickerPanelView mCyan;
+    private ColorPickerPanelView mRed;
+    private ColorPickerPanelView mGreen;
+    private ColorPickerPanelView mYellow;
+
+    private EditText mHex;
+    private ImageButton mSetButton;
+
+    private OnColorChangedListener mListener;
+
+    public interface OnColorChangedListener {
+        public void onColorChanged(int color);
+    }
+
+    public ColorPickerDialog(Context context, int initialColor) {
+        super(context);
+
+        init(initialColor);
+    }
+
+    private void init(int color) {
+        // To fight color branding.
+        getWindow().setFormat(PixelFormat.RGBA_8888);
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+        setUp(color);
+
+    }
+
+    private void setUp(int color) {
+
+        LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+
+        View layout = inflater.inflate(R.layout.dialog_color_picker, null);
+
+        setContentView(layout);
+
+        setTitle(R.string.dialog_color_picker);
+
+        mColorPicker = (ColorPickerView) layout.findViewById(R.id.color_picker_view);
+        mOldColor = (ColorPickerPanelView) layout.findViewById(R.id.old_color_panel);
+        mNewColor = (ColorPickerPanelView) layout.findViewById(R.id.new_color_panel);
+
+        mWhite = (ColorPickerPanelView) layout.findViewById(R.id.white_panel);
+        mBlack = (ColorPickerPanelView) layout.findViewById(R.id.black_panel);
+        mCyan = (ColorPickerPanelView) layout.findViewById(R.id.cyan_panel);
+        mRed = (ColorPickerPanelView) layout.findViewById(R.id.red_panel);
+        mGreen = (ColorPickerPanelView) layout.findViewById(R.id.green_panel);
+        mYellow = (ColorPickerPanelView) layout.findViewById(R.id.yellow_panel);
+
+        mHex = (EditText) layout.findViewById(R.id.hex);
+        mSetButton = (ImageButton) layout.findViewById(R.id.enter);
+
+        ((LinearLayout) mOldColor.getParent()).setPadding(
+                Math.round(mColorPicker.getDrawingOffset()),
+                0,
+                Math.round(mColorPicker.getDrawingOffset()),
+                0
+                );
+
+        mOldColor.setOnClickListener(this);
+        mNewColor.setOnClickListener(this);
+        mColorPicker.setOnColorChangedListener(this);
+        mOldColor.setColor(color);
+        mColorPicker.setColor(color, true);
+
+        setColorAndClickAction(mWhite, Color.WHITE);
+        setColorAndClickAction(mBlack, Color.BLACK);
+        setColorAndClickAction(mCyan, 0xff33b5e5);
+        setColorAndClickAction(mRed, Color.RED);
+        setColorAndClickAction(mGreen, Color.GREEN);
+        setColorAndClickAction(mYellow, Color.YELLOW);
+
+        if (mHex != null) {
+            mHex.setText(ColorPickerPreference.convertToARGB(color));
+        }
+        if (mSetButton != null) {
+           mSetButton.setOnClickListener(new View.OnClickListener() {
+
+                @Override
+                public void onClick(View v) {
+                    String text = mHex.getText().toString();
+                    try {
+                        int newColor = ColorPickerPreference.convertToColorInt(text);
+                        mColorPicker.setColor(newColor, true);
+                    } catch (Exception e) {
+                    }
+                }
+            });
+        }
+    }
+
+    @Override
+    public void onColorChanged(int color) {
+
+        mNewColor.setColor(color);
+        try {
+            if (mHex != null) {
+                mHex.setText(ColorPickerPreference.convertToARGB(color));
+            }
+        } catch (Exception e) {
+
+        }
+        /*
+         * if (mListener != null) { mListener.onColorChanged(color); }
+         */
+
+    }
+
+    public void setAlphaSliderVisible(boolean visible) {
+        mColorPicker.setAlphaSliderVisible(visible);
+    }
+
+    public void setColorAndClickAction(ColorPickerPanelView previewRect, final int color) {
+        if (previewRect != null) {
+            previewRect.setColor(color);
+            previewRect.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    try {
+                        mColorPicker.setColor(color, true);
+                    } catch (Exception e) {
+                    }
+                }
+            });
+        }
+    }
+
+    /**
+     * Set a OnColorChangedListener to get notified when the color selected by the user has changed.
+     *
+     * @param listener
+     */
+    public void setOnColorChangedListener(OnColorChangedListener listener) {
+        mListener = listener;
+    }
+
+    public int getColor() {
+        return mColorPicker.getColor();
+    }
+
+    @Override
+    public void onClick(View v) {
+        if (v.getId() == R.id.new_color_panel) {
+            if (mListener != null) {
+                mListener.onColorChanged(mNewColor.getColor());
+            }
+        }
+        dismiss();
+    }
+
+    @Override
+    public Bundle onSaveInstanceState() {
+        Bundle state = super.onSaveInstanceState();
+        state.putInt("old_color", mOldColor.getColor());
+        state.putInt("new_color", mNewColor.getColor());
+        return state;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Bundle savedInstanceState) {
+        super.onRestoreInstanceState(savedInstanceState);
+        mOldColor.setColor(savedInstanceState.getInt("old_color"));
+        mColorPicker.setColor(savedInstanceState.getInt("new_color"), true);
+    }
+
+}
diff --git a/src/net/margaritov/preference/colorpicker/ColorPickerPanelView.java b/src/net/margaritov/preference/colorpicker/ColorPickerPanelView.java
new file mode 100644
index 0000000..91a6d2f
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/ColorPickerPanelView.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2010 Daniel Nilsson
+ * Copyright (C) 2013 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.util.AttributeSet;
+import android.view.View;
+
+/**
+ * This class draws a panel which which will be filled with a color which can be set.
+ * It can be used to show the currently selected color which you will get from
+ * the {@link ColorPickerView}.
+ * @author Daniel Nilsson
+ *
+ */
+public class ColorPickerPanelView extends View {
+
+    /**
+     * The width in pixels of the border
+     * surrounding the color panel.
+     */
+    private final static float    BORDER_WIDTH_PX = 1;
+
+    private float mDensity = 1f;
+
+    private int         mBorderColor = 0xff6E6E6E;
+    private int         mColor = 0xff000000;
+
+    private Paint        mBorderPaint;
+    private Paint        mColorPaint;
+
+    private RectF        mDrawingRect;
+    private RectF        mColorRect;
+
+    private AlphaPatternDrawable mAlphaPattern;
+
+
+    public ColorPickerPanelView(Context context){
+        this(context, null);
+    }
+
+    public ColorPickerPanelView(Context context, AttributeSet attrs){
+        this(context, attrs, 0);
+    }
+
+    public ColorPickerPanelView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init();
+    }
+
+    private void init(){
+        mBorderPaint = new Paint();
+        mColorPaint = new Paint();
+        mDensity = getContext().getResources().getDisplayMetrics().density;
+    }
+
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+
+        final RectF    rect = mColorRect;
+
+        if(BORDER_WIDTH_PX > 0){
+            mBorderPaint.setColor(mBorderColor);
+            canvas.drawRect(mDrawingRect, mBorderPaint);
+        }
+
+        if(mAlphaPattern != null){
+            mAlphaPattern.draw(canvas);
+        }
+
+        mColorPaint.setColor(mColor);
+
+        canvas.drawRect(rect, mColorPaint);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+
+        int width = MeasureSpec.getSize(widthMeasureSpec);
+        int height = MeasureSpec.getSize(heightMeasureSpec);
+
+        setMeasuredDimension(width, height);
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+
+        mDrawingRect = new RectF();
+        mDrawingRect.left =  getPaddingLeft();
+        mDrawingRect.right  = w - getPaddingRight();
+        mDrawingRect.top = getPaddingTop();
+        mDrawingRect.bottom = h - getPaddingBottom();
+
+        setUpColorRect();
+
+    }
+
+    private void setUpColorRect(){
+        final RectF    dRect = mDrawingRect;
+
+        float left = dRect.left + BORDER_WIDTH_PX;
+        float top = dRect.top + BORDER_WIDTH_PX;
+        float bottom = dRect.bottom - BORDER_WIDTH_PX;
+        float right = dRect.right - BORDER_WIDTH_PX;
+
+        mColorRect = new RectF(left,top, right, bottom);
+
+        mAlphaPattern = new AlphaPatternDrawable((int)(5 * mDensity));
+
+        mAlphaPattern.setBounds(
+            Math.round(mColorRect.left),
+            Math.round(mColorRect.top),
+            Math.round(mColorRect.right),
+            Math.round(mColorRect.bottom)
+        );
+
+    }
+
+    /**
+     * Set the color that should be shown by this view.
+     * @param color
+     */
+    public void setColor(int color){
+        mColor = color;
+        invalidate();
+    }
+
+    /**
+     * Get the color currently show by this view.
+     * @return
+     */
+    public int getColor(){
+        return mColor;
+    }
+
+    /**
+     * Set the color of the border surrounding the panel.
+     * @param color
+     */
+    public void setBorderColor(int color){
+        mBorderColor = color;
+        invalidate();
+    }
+
+    /**
+     * Get the color of the border surrounding the panel.
+     */
+    public int getBorderColor(){
+        return mBorderColor;
+    }
+
+}
diff --git a/src/net/margaritov/preference/colorpicker/ColorPickerPreference.java b/src/net/margaritov/preference/colorpicker/ColorPickerPreference.java
new file mode 100644
index 0000000..615bc01
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/ColorPickerPreference.java
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2011 Sergey Margaritov
+ * Copyright (C) 2013 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.preference.Preference;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+
+import com.android.settings.R;
+
+/**
+ * A preference type that allows a user to choose a time
+ *
+ * @author Sergey Margaritov
+ */
+public class ColorPickerPreference extends Preference implements
+        Preference.OnPreferenceClickListener, ColorPickerDialog.OnColorChangedListener {
+
+    View mView;
+    ColorPickerDialog mDialog;
+    LinearLayout widgetFrameView;
+    private int mValue = Color.BLACK;
+    private float mDensity = 0;
+    private boolean mAlphaSliderEnabled = false;
+
+    private EditText mEditText;
+
+    public ColorPickerPreference(Context context) {
+        super(context);
+        init(context, null);
+    }
+
+    public ColorPickerPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context, attrs);
+    }
+
+    public ColorPickerPreference(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(context, attrs);
+    }
+
+    @Override
+    protected Object onGetDefaultValue(TypedArray a, int index) {
+        return a.getInt(index, Color.BLACK);
+    }
+
+    @Override
+    protected void onSetInitialValue(boolean restoreValue, Object defaultValue) {
+        onColorChanged(restoreValue ? getPersistedInt(mValue) : (Integer) defaultValue);
+    }
+
+    private void init(Context context, AttributeSet attrs) {
+        mDensity = getContext().getResources().getDisplayMetrics().density;
+        setOnPreferenceClickListener(this);
+        if (attrs != null) {
+            mAlphaSliderEnabled = attrs.getAttributeBooleanValue(null, "alphaSlider", false);
+        }
+    }
+
+    @Override
+    protected void onBindView(View view) {
+        mView = view;
+        super.onBindView(view);
+
+        widgetFrameView = ((LinearLayout) view
+                .findViewById(android.R.id.widget_frame));
+
+        setPreviewColor();
+    }
+
+    private void setPreviewColor() {
+        if (mView == null)
+            return;
+
+        ImageView iView = new ImageView(getContext());
+        LinearLayout widgetFrameView = ((LinearLayout) mView
+                .findViewById(android.R.id.widget_frame));
+        if (widgetFrameView == null)
+            return;
+
+        widgetFrameView.setVisibility(View.VISIBLE);
+        widgetFrameView.setPadding(
+                widgetFrameView.getPaddingLeft(),
+                widgetFrameView.getPaddingTop(),
+                (int) (mDensity * 8),
+                widgetFrameView.getPaddingBottom()
+                );
+        // remove already create preview image
+        int count = widgetFrameView.getChildCount();
+        if (count > 0) {
+            widgetFrameView.removeViews(0, count);
+        }
+        widgetFrameView.addView(iView);
+        widgetFrameView.setMinimumWidth(0);
+        iView.setBackgroundDrawable(new AlphaPatternDrawable((int) (5 * mDensity)));
+        iView.setImageBitmap(getPreviewBitmap());
+    }
+
+    private Bitmap getPreviewBitmap() {
+        int d = (int) (mDensity * 31); // 30dip
+        int color = mValue;
+        Bitmap bm = Bitmap.createBitmap(d, d, Config.ARGB_8888);
+        int w = bm.getWidth();
+        int h = bm.getHeight();
+        int c = color;
+        for (int i = 0; i < w; i++) {
+            for (int j = i; j < h; j++) {
+                c = (i <= 1 || j <= 1 || i >= w - 2 || j >= h - 2) ? Color.GRAY : color;
+                bm.setPixel(i, j, c);
+                if (i != j) {
+                    bm.setPixel(j, i, c);
+                }
+            }
+        }
+
+        return bm;
+    }
+
+    @Override
+    public void onColorChanged(int color) {
+        if (isPersistent()) {
+            persistInt(color);
+        }
+        mValue = color;
+        setPreviewColor();
+        try {
+            getOnPreferenceChangeListener().onPreferenceChange(this, color);
+        } catch (NullPointerException e) {
+        }
+        try {
+            mEditText.setText(Integer.toString(color, 16));
+        } catch (NullPointerException e) {
+        }
+    }
+
+    public boolean onPreferenceClick(Preference preference) {
+        showDialog(null);
+        return false;
+    }
+
+    protected void showDialog(Bundle state) {
+        mDialog = new ColorPickerDialog(getContext(), mValue);
+        mDialog.setOnColorChangedListener(this);
+        if (mAlphaSliderEnabled) {
+            mDialog.setAlphaSliderVisible(true);
+        }
+        if (state != null) {
+            mDialog.onRestoreInstanceState(state);
+        }
+        mDialog.show();
+    }
+
+
+    /**
+     * Toggle Alpha Slider visibility (by default it's disabled)
+     *
+     * @param enable
+     */
+    public void setAlphaSliderEnabled(boolean enable) {
+        mAlphaSliderEnabled = enable;
+    }
+
+    /**
+     * For custom purposes. Not used by ColorPickerPreferrence
+     *
+     * set color preview value from outside
+     * @author kufikugel
+     */
+    public void setNewPreviewColor(int color) {
+        onColorChanged(color);
+    }
+
+    /**
+     * For custom purposes. Not used by ColorPickerPreferrence
+     *
+     * @param color
+     * @author Unknown
+     */
+    public static String convertToARGB(int color) {
+        String alpha = Integer.toHexString(Color.alpha(color));
+        String red = Integer.toHexString(Color.red(color));
+        String green = Integer.toHexString(Color.green(color));
+        String blue = Integer.toHexString(Color.blue(color));
+
+        if (alpha.length() == 1) {
+            alpha = "0" + alpha;
+        }
+
+        if (red.length() == 1) {
+            red = "0" + red;
+        }
+
+        if (green.length() == 1) {
+            green = "0" + green;
+        }
+
+        if (blue.length() == 1) {
+            blue = "0" + blue;
+        }
+
+        return "#" + alpha + red + green + blue;
+    }
+
+    /**
+     * For custom purposes. Not used by ColorPickerPreferrence
+     *
+     * @param argb
+     * @throws NumberFormatException
+     * @author Unknown
+     */
+    public static int convertToColorInt(String argb) throws NumberFormatException {
+
+        if (argb.startsWith("#")) {
+            argb = argb.replace("#", "");
+        }
+
+        int alpha = -1, red = -1, green = -1, blue = -1;
+
+        if (argb.length() == 8) {
+            alpha = Integer.parseInt(argb.substring(0, 2), 16);
+            red = Integer.parseInt(argb.substring(2, 4), 16);
+            green = Integer.parseInt(argb.substring(4, 6), 16);
+            blue = Integer.parseInt(argb.substring(6, 8), 16);
+        }
+        else if (argb.length() == 6) {
+            alpha = 255;
+            red = Integer.parseInt(argb.substring(0, 2), 16);
+            green = Integer.parseInt(argb.substring(2, 4), 16);
+            blue = Integer.parseInt(argb.substring(4, 6), 16);
+        }
+
+        return Color.argb(alpha, red, green, blue);
+    }
+
+    @Override
+    protected Parcelable onSaveInstanceState() {
+        final Parcelable superState = super.onSaveInstanceState();
+        if (mDialog == null || !mDialog.isShowing()) {
+            return superState;
+        }
+
+        final SavedState myState = new SavedState(superState);
+        myState.dialogBundle = mDialog.onSaveInstanceState();
+        return myState;
+    }
+
+    @Override
+    protected void onRestoreInstanceState(Parcelable state) {
+        if (state == null || !(state instanceof SavedState)) {
+            // Didn't save state for us in onSaveInstanceState
+            super.onRestoreInstanceState(state);
+            return;
+        }
+
+        SavedState myState = (SavedState) state;
+        super.onRestoreInstanceState(myState.getSuperState());
+        showDialog(myState.dialogBundle);
+    }
+
+    private static class SavedState extends BaseSavedState {
+        Bundle dialogBundle;
+
+        public SavedState(Parcel source) {
+            super(source);
+            dialogBundle = source.readBundle();
+        }
+
+        @Override
+        public void writeToParcel(Parcel dest, int flags) {
+            super.writeToParcel(dest, flags);
+            dest.writeBundle(dialogBundle);
+        }
+
+        public SavedState(Parcelable superState) {
+            super(superState);
+        }
+
+        @SuppressWarnings("unused")
+        public static final Parcelable.Creator<SavedState> CREATOR =
+                new Parcelable.Creator<SavedState>() {
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+}
diff --git a/src/net/margaritov/preference/colorpicker/ColorPickerView.java b/src/net/margaritov/preference/colorpicker/ColorPickerView.java
new file mode 100644
index 0000000..98adb12
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/ColorPickerView.java
@@ -0,0 +1,962 @@
+/*
+ * Copyright (C) 2010 Daniel Nilsson
+ * Copyright (C) 2013 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ComposeShader;
+import android.graphics.LinearGradient;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+import android.graphics.Paint.Style;
+import android.graphics.Point;
+import android.graphics.PorterDuff;
+import android.graphics.RectF;
+import android.graphics.Shader;
+import android.graphics.Shader.TileMode;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+import android.view.View;
+
+/**
+ * Displays a color picker to the user and allow them
+ * to select a color. A slider for the alpha channel is
+ * also available. Enable it by setting
+ * setAlphaSliderVisible(boolean) to true.
+ * @author Daniel Nilsson
+ */
+public class ColorPickerView extends View {
+
+    private final static int    PANEL_SAT_VAL = 0;
+    private final static int    PANEL_HUE = 1;
+    private final static int    PANEL_ALPHA = 2;
+
+    /**
+     * The width in pixels of the border
+     * surrounding all color panels.
+     */
+    private final static float    BORDER_WIDTH_PX = 1;
+
+    /**
+     * The width in dp of the hue panel.
+     */
+    private float         HUE_PANEL_WIDTH = 30f;
+    /**
+     * The height in dp of the alpha panel
+     */
+    private float        ALPHA_PANEL_HEIGHT = 20f;
+    /**
+     * The distance in dp between the different
+     * color panels.
+     */
+    private float         PANEL_SPACING = 10f;
+    /**
+     * The radius in dp of the color palette tracker circle.
+     */
+    private float         PALETTE_CIRCLE_TRACKER_RADIUS = 5f;
+    /**
+     * The dp which the tracker of the hue or alpha panel
+     * will extend outside of its bounds.
+     */
+    private float        RECTANGLE_TRACKER_OFFSET = 2f;
+
+
+    private float         mDensity = 1f;
+
+    private OnColorChangedListener    mListener;
+
+    private Paint         mSatValPaint;
+    private Paint        mSatValTrackerPaint;
+
+    private Paint        mHuePaint;
+    private Paint        mHueTrackerPaint;
+
+    private Paint        mAlphaPaint;
+    private Paint        mAlphaTextPaint;
+
+    private Paint        mBorderPaint;
+
+    private Shader        mValShader;
+    private Shader        mSatShader;
+    private Shader        mHueShader;
+    private Shader        mAlphaShader;
+
+    private int            mAlpha = 0xff;
+    private float        mHue = 360f;
+    private float         mSat = 0f;
+    private float         mVal = 0f;
+
+    private String        mAlphaSliderText = "";
+    private int         mSliderTrackerColor = 0xff1c1c1c;
+    private int         mBorderColor = 0xff6E6E6E;
+    private boolean        mShowAlphaPanel = false;
+
+    /*
+     * To remember which panel that has the "focus" when
+     * processing hardware button data.
+     */
+    private int            mLastTouchedPanel = PANEL_SAT_VAL;
+
+    /**
+     * Offset from the edge we must have or else
+     * the finger tracker will get clipped when
+     * it is drawn outside of the view.
+     */
+    private float         mDrawingOffset;
+
+
+    /*
+     * Distance form the edges of the view
+     * of where we are allowed to draw.
+     */
+    private RectF    mDrawingRect;
+
+    private RectF    mSatValRect;
+    private RectF     mHueRect;
+    private RectF    mAlphaRect;
+
+    private AlphaPatternDrawable    mAlphaPattern;
+
+    private Point    mStartTouchPoint = null;
+
+    public interface OnColorChangedListener {
+        public void onColorChanged(int color);
+    }
+
+    public ColorPickerView(Context context){
+        this(context, null);
+    }
+
+    public ColorPickerView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public ColorPickerView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init();
+    }
+
+    private void init(){
+        setLayerType(View.LAYER_TYPE_SOFTWARE, null);
+        mDensity = getContext().getResources().getDisplayMetrics().density;
+        PALETTE_CIRCLE_TRACKER_RADIUS *= mDensity;
+        RECTANGLE_TRACKER_OFFSET *= mDensity;
+        HUE_PANEL_WIDTH *= mDensity;
+        ALPHA_PANEL_HEIGHT *= mDensity;
+        PANEL_SPACING = PANEL_SPACING * mDensity;
+
+        mDrawingOffset = calculateRequiredOffset();
+
+        initPaintTools();
+
+        //Needed for receiving trackball motion events.
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+    }
+
+    private void initPaintTools(){
+
+        mSatValPaint = new Paint();
+        mSatValTrackerPaint = new Paint();
+        mHuePaint = new Paint();
+        mHueTrackerPaint = new Paint();
+        mAlphaPaint = new Paint();
+        mAlphaTextPaint = new Paint();
+        mBorderPaint = new Paint();
+
+
+        mSatValTrackerPaint.setStyle(Style.STROKE);
+        mSatValTrackerPaint.setStrokeWidth(2f * mDensity);
+        mSatValTrackerPaint.setAntiAlias(true);
+
+        mHueTrackerPaint.setColor(mSliderTrackerColor);
+        mHueTrackerPaint.setStyle(Style.STROKE);
+        mHueTrackerPaint.setStrokeWidth(2f * mDensity);
+        mHueTrackerPaint.setAntiAlias(true);
+
+        mAlphaTextPaint.setColor(0xff1c1c1c);
+        mAlphaTextPaint.setTextSize(14f * mDensity);
+        mAlphaTextPaint.setAntiAlias(true);
+        mAlphaTextPaint.setTextAlign(Align.CENTER);
+        mAlphaTextPaint.setFakeBoldText(true);
+
+
+    }
+
+    private float calculateRequiredOffset(){
+        float offset = Math.max(PALETTE_CIRCLE_TRACKER_RADIUS, RECTANGLE_TRACKER_OFFSET);
+        offset = Math.max(offset, BORDER_WIDTH_PX * mDensity);
+
+        return offset * 1.5f;
+    }
+
+    private int[] buildHueColorArray(){
+
+        int[] hue = new int[361];
+
+        int count = 0;
+        for(int i = hue.length -1; i >= 0; i--, count++){
+            hue[count] = Color.HSVToColor(new float[]{i, 1f, 1f});
+        }
+
+        return hue;
+    }
+
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+
+        if(mDrawingRect.width() <= 0 || mDrawingRect.height() <= 0) return;
+
+        drawSatValPanel(canvas);
+        drawHuePanel(canvas);
+        drawAlphaPanel(canvas);
+
+    }
+
+    private void drawSatValPanel(Canvas canvas){
+
+        final RectF    rect = mSatValRect;
+
+        if(BORDER_WIDTH_PX > 0){
+            mBorderPaint.setColor(mBorderColor);
+            canvas.drawRect(mDrawingRect.left,
+                mDrawingRect.top, rect.right + BORDER_WIDTH_PX,
+                rect.bottom + BORDER_WIDTH_PX, mBorderPaint);
+        }
+
+        if (mValShader == null) {
+            mValShader = new LinearGradient(rect.left, rect.top, rect.left, rect.bottom,
+                    0xffffffff, 0xff000000, TileMode.CLAMP);
+        }
+
+        int rgb = Color.HSVToColor(new float[]{mHue,1f,1f});
+
+        mSatShader = new LinearGradient(rect.left, rect.top, rect.right, rect.top,
+                0xffffffff, rgb, TileMode.CLAMP);
+        ComposeShader mShader = new ComposeShader(
+            mValShader, mSatShader, PorterDuff.Mode.MULTIPLY);
+        mSatValPaint.setShader(mShader);
+
+        canvas.drawRect(rect, mSatValPaint);
+
+        Point p = satValToPoint(mSat, mVal);
+
+        mSatValTrackerPaint.setColor(0xff000000);
+        canvas.drawCircle(
+            p.x, p.y, PALETTE_CIRCLE_TRACKER_RADIUS - 1f * mDensity, mSatValTrackerPaint);
+
+        mSatValTrackerPaint.setColor(0xffdddddd);
+        canvas.drawCircle(p.x, p.y, PALETTE_CIRCLE_TRACKER_RADIUS, mSatValTrackerPaint);
+
+    }
+
+    private void drawHuePanel(Canvas canvas){
+
+        final RectF rect = mHueRect;
+
+        if(BORDER_WIDTH_PX > 0){
+            mBorderPaint.setColor(mBorderColor);
+            canvas.drawRect(rect.left - BORDER_WIDTH_PX,
+                    rect.top - BORDER_WIDTH_PX,
+                    rect.right + BORDER_WIDTH_PX,
+                    rect.bottom + BORDER_WIDTH_PX,
+                    mBorderPaint);
+        }
+
+        if (mHueShader == null) {
+            mHueShader = new LinearGradient(
+                rect.left, rect.top, rect.left, rect.bottom,
+                buildHueColorArray(), null, TileMode.CLAMP);
+            mHuePaint.setShader(mHueShader);
+        }
+
+        canvas.drawRect(rect, mHuePaint);
+
+        float rectHeight = 4 * mDensity / 2;
+
+        Point p = hueToPoint(mHue);
+
+        RectF r = new RectF();
+        r.left = rect.left - RECTANGLE_TRACKER_OFFSET;
+        r.right = rect.right + RECTANGLE_TRACKER_OFFSET;
+        r.top = p.y - rectHeight;
+        r.bottom = p.y + rectHeight;
+
+
+        canvas.drawRoundRect(r, 2, 2, mHueTrackerPaint);
+
+    }
+
+    private void drawAlphaPanel(Canvas canvas){
+
+        if(!mShowAlphaPanel || mAlphaRect == null || mAlphaPattern == null) return;
+
+        final RectF rect = mAlphaRect;
+
+        if(BORDER_WIDTH_PX > 0){
+            mBorderPaint.setColor(mBorderColor);
+            canvas.drawRect(rect.left - BORDER_WIDTH_PX,
+                    rect.top - BORDER_WIDTH_PX,
+                    rect.right + BORDER_WIDTH_PX,
+                    rect.bottom + BORDER_WIDTH_PX,
+                    mBorderPaint);
+        }
+
+
+        mAlphaPattern.draw(canvas);
+
+        float[] hsv = new float[]{mHue,mSat,mVal};
+        int color = Color.HSVToColor(hsv);
+        int acolor = Color.HSVToColor(0, hsv);
+
+        mAlphaShader = new LinearGradient(rect.left, rect.top, rect.right, rect.top,
+                color, acolor, TileMode.CLAMP);
+
+
+        mAlphaPaint.setShader(mAlphaShader);
+
+        canvas.drawRect(rect, mAlphaPaint);
+
+        if(mAlphaSliderText != null && mAlphaSliderText!= ""){
+            canvas.drawText(mAlphaSliderText, rect.centerX(),
+                rect.centerY() + 4 * mDensity, mAlphaTextPaint);
+        }
+
+        float rectWidth = 4 * mDensity / 2;
+
+        Point p = alphaToPoint(mAlpha);
+
+        RectF r = new RectF();
+        r.left = p.x - rectWidth;
+        r.right = p.x + rectWidth;
+        r.top = rect.top - RECTANGLE_TRACKER_OFFSET;
+        r.bottom = rect.bottom + RECTANGLE_TRACKER_OFFSET;
+
+        canvas.drawRoundRect(r, 2, 2, mHueTrackerPaint);
+
+    }
+
+
+    private Point hueToPoint(float hue){
+
+        final RectF rect = mHueRect;
+        final float height = rect.height();
+
+        Point p = new Point();
+
+        p.y = (int) (height - (hue * height / 360f) + rect.top);
+        p.x = (int) rect.left;
+
+        return p;
+    }
+
+    private Point satValToPoint(float sat, float val){
+
+        final RectF rect = mSatValRect;
+        final float height = rect.height();
+        final float width = rect.width();
+
+        Point p = new Point();
+
+        p.x = (int) (sat * width + rect.left);
+        p.y = (int) ((1f - val) * height + rect.top);
+
+        return p;
+    }
+
+    private Point alphaToPoint(int alpha){
+
+        final RectF rect = mAlphaRect;
+        final float width = rect.width();
+
+        Point p = new Point();
+
+        p.x = (int) (width - (alpha * width / 0xff) + rect.left);
+        p.y = (int) rect.top;
+
+        return p;
+
+    }
+
+    private float[] pointToSatVal(float x, float y){
+
+        final RectF rect = mSatValRect;
+        float[] result = new float[2];
+
+        float width = rect.width();
+        float height = rect.height();
+
+        if (x < rect.left){
+            x = 0f;
+        }
+        else if(x > rect.right){
+            x = width;
+        }
+        else{
+            x = x - rect.left;
+        }
+
+        if (y < rect.top){
+            y = 0f;
+        }
+        else if(y > rect.bottom){
+            y = height;
+        }
+        else{
+            y = y - rect.top;
+        }
+
+
+        result[0] = 1.f / width * x;
+        result[1] = 1.f - (1.f / height * y);
+
+        return result;
+    }
+
+    private float pointToHue(float y){
+
+        final RectF rect = mHueRect;
+
+        float height = rect.height();
+
+        if (y < rect.top){
+            y = 0f;
+        }
+        else if(y > rect.bottom){
+            y = height;
+        }
+        else{
+            y = y - rect.top;
+        }
+
+        return 360f - (y * 360f / height);
+    }
+
+    private int pointToAlpha(int x){
+
+        final RectF rect = mAlphaRect;
+        final int width = (int) rect.width();
+
+        if(x < rect.left){
+            x = 0;
+        }
+        else if(x > rect.right){
+            x = width;
+        }
+        else{
+            x = x - (int)rect.left;
+        }
+
+        return 0xff - (x * 0xff / width);
+
+    }
+
+
+    @Override
+    public boolean onTrackballEvent(MotionEvent event) {
+
+        float x = event.getX();
+        float y = event.getY();
+
+        boolean update = false;
+
+
+        if(event.getAction() == MotionEvent.ACTION_MOVE){
+
+            switch(mLastTouchedPanel){
+
+            case PANEL_SAT_VAL:
+
+                float sat, val;
+
+                sat = mSat + x/50f;
+                val = mVal - y/50f;
+
+                if(sat < 0f){
+                    sat = 0f;
+                }
+                else if(sat > 1f){
+                    sat = 1f;
+                }
+
+                if(val < 0f){
+                    val = 0f;
+                }
+                else if(val > 1f){
+                    val = 1f;
+                }
+
+                mSat = sat;
+                mVal = val;
+
+                update = true;
+
+                break;
+
+            case PANEL_HUE:
+
+                float hue = mHue - y * 10f;
+
+                if(hue < 0f){
+                    hue = 0f;
+                }
+                else if(hue > 360f){
+                    hue = 360f;
+                }
+
+                mHue = hue;
+
+                update = true;
+
+                break;
+
+            case PANEL_ALPHA:
+
+                if(!mShowAlphaPanel || mAlphaRect == null){
+                    update = false;
+                }
+                else{
+
+                    int alpha = (int) (mAlpha - x*10);
+
+                    if(alpha < 0){
+                        alpha = 0;
+                    }
+                    else if(alpha > 0xff){
+                        alpha = 0xff;
+                    }
+
+                    mAlpha = alpha;
+
+
+                    update = true;
+                }
+
+                break;
+            }
+
+
+        }
+
+
+        if(update){
+
+            if(mListener != null){
+                mListener.onColorChanged(Color.HSVToColor(mAlpha, new float[]{mHue, mSat, mVal}));
+            }
+
+            invalidate();
+            return true;
+        }
+
+
+        return super.onTrackballEvent(event);
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+
+        boolean update = false;
+
+        switch(event.getAction()){
+
+        case MotionEvent.ACTION_DOWN:
+
+            mStartTouchPoint = new Point((int)event.getX(), (int)event.getY());
+
+            update = moveTrackersIfNeeded(event);
+
+            break;
+
+        case MotionEvent.ACTION_MOVE:
+
+            update = moveTrackersIfNeeded(event);
+
+            break;
+
+        case MotionEvent.ACTION_UP:
+
+            mStartTouchPoint = null;
+
+            update = moveTrackersIfNeeded(event);
+
+            break;
+
+        }
+
+        if(update){
+
+            if(mListener != null){
+                mListener.onColorChanged(Color.HSVToColor(mAlpha, new float[]{mHue, mSat, mVal}));
+            }
+
+            invalidate();
+            return true;
+        }
+
+
+        return super.onTouchEvent(event);
+    }
+
+    private boolean moveTrackersIfNeeded(MotionEvent event){
+
+        if(mStartTouchPoint == null) return false;
+
+        boolean update = false;
+
+        int startX = mStartTouchPoint.x;
+        int startY = mStartTouchPoint.y;
+
+
+        if(mHueRect.contains(startX, startY)){
+            mLastTouchedPanel = PANEL_HUE;
+
+            mHue = pointToHue(event.getY());
+
+            update = true;
+        }
+        else if(mSatValRect.contains(startX, startY)){
+
+            mLastTouchedPanel = PANEL_SAT_VAL;
+
+            float[] result = pointToSatVal(event.getX(), event.getY());
+
+            mSat = result[0];
+            mVal = result[1];
+
+            update = true;
+        }
+        else if(mAlphaRect != null && mAlphaRect.contains(startX, startY)){
+
+            mLastTouchedPanel = PANEL_ALPHA;
+
+            mAlpha = pointToAlpha((int)event.getX());
+
+            update = true;
+        }
+
+
+        return update;
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+
+        int width = 0;
+        int height = 0;
+
+        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+
+        int widthAllowed = MeasureSpec.getSize(widthMeasureSpec);
+        int heightAllowed = MeasureSpec.getSize(heightMeasureSpec);
+
+        widthAllowed = chooseWidth(widthMode, widthAllowed);
+        heightAllowed = chooseHeight(heightMode, heightAllowed);
+
+        if(!mShowAlphaPanel){
+
+            height = (int) (widthAllowed - PANEL_SPACING - HUE_PANEL_WIDTH);
+
+            //If calculated height (based on the width) is more than the allowed height.
+            if(height > heightAllowed) {
+                height = heightAllowed;
+                width = (int) (height + PANEL_SPACING + HUE_PANEL_WIDTH);
+            }
+            else{
+                width = widthAllowed;
+            }
+        }
+        else{
+
+            width = (int) (heightAllowed - ALPHA_PANEL_HEIGHT + HUE_PANEL_WIDTH);
+
+            if(width > widthAllowed){
+                width = widthAllowed;
+                height = (int) (widthAllowed - HUE_PANEL_WIDTH + ALPHA_PANEL_HEIGHT);
+            }
+            else{
+                height = heightAllowed;
+            }
+
+        }
+
+        setMeasuredDimension(width, height);
+    }
+
+    private int chooseWidth(int mode, int size){
+        if (mode == MeasureSpec.AT_MOST || mode == MeasureSpec.EXACTLY) {
+            return size;
+        } else { // (mode == MeasureSpec.UNSPECIFIED)
+            return getPrefferedWidth();
+        }
+    }
+
+    private int chooseHeight(int mode, int size){
+        if (mode == MeasureSpec.AT_MOST || mode == MeasureSpec.EXACTLY) {
+            return size;
+        } else { // (mode == MeasureSpec.UNSPECIFIED)
+            return getPrefferedHeight();
+        }
+    }
+
+    private int getPrefferedWidth(){
+
+        int width = getPrefferedHeight();
+
+        if(mShowAlphaPanel){
+            width -= (PANEL_SPACING + ALPHA_PANEL_HEIGHT);
+        }
+
+
+        return (int) (width + HUE_PANEL_WIDTH + PANEL_SPACING);
+
+    }
+
+    private int getPrefferedHeight(){
+
+        int height = (int)(200 * mDensity);
+
+        if(mShowAlphaPanel){
+            height += PANEL_SPACING + ALPHA_PANEL_HEIGHT;
+        }
+
+        return height;
+    }
+
+
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+
+        mDrawingRect = new RectF();
+        mDrawingRect.left = mDrawingOffset + getPaddingLeft();
+        mDrawingRect.right  = w - mDrawingOffset - getPaddingRight();
+        mDrawingRect.top = mDrawingOffset + getPaddingTop();
+        mDrawingRect.bottom = h - mDrawingOffset - getPaddingBottom();
+
+        setUpSatValRect();
+        setUpHueRect();
+        setUpAlphaRect();
+    }
+
+    private void setUpSatValRect(){
+
+        final RectF    dRect = mDrawingRect;
+        float panelSide = dRect.height() - BORDER_WIDTH_PX * 2;
+
+        if(mShowAlphaPanel){
+            panelSide -= PANEL_SPACING + ALPHA_PANEL_HEIGHT;
+        }
+
+        float left = dRect.left + BORDER_WIDTH_PX;
+        float top = dRect.top + BORDER_WIDTH_PX;
+        float bottom = top + panelSide;
+        float right = left + panelSide;
+
+        mSatValRect = new RectF(left,top, right, bottom);
+    }
+
+    private void setUpHueRect(){
+        final RectF    dRect = mDrawingRect;
+
+        float left = dRect.right - HUE_PANEL_WIDTH + BORDER_WIDTH_PX;
+        float top = dRect.top + BORDER_WIDTH_PX;
+        float bottom = dRect.bottom - BORDER_WIDTH_PX - (mShowAlphaPanel
+            ? (PANEL_SPACING + ALPHA_PANEL_HEIGHT) : 0);
+        float right = dRect.right - BORDER_WIDTH_PX;
+
+        mHueRect = new RectF(left, top, right, bottom);
+    }
+
+    private void setUpAlphaRect() {
+
+        if(!mShowAlphaPanel) return;
+
+        final RectF    dRect = mDrawingRect;
+
+        float left = dRect.left + BORDER_WIDTH_PX;
+        float top = dRect.bottom - ALPHA_PANEL_HEIGHT + BORDER_WIDTH_PX;
+        float bottom = dRect.bottom - BORDER_WIDTH_PX;
+        float right = dRect.right - BORDER_WIDTH_PX;
+
+        mAlphaRect = new RectF(left, top, right, bottom);
+
+        mAlphaPattern = new AlphaPatternDrawable((int) (5 * mDensity));
+        mAlphaPattern.setBounds(
+            Math.round(mAlphaRect.left),
+            Math.round(mAlphaRect.top),
+            Math.round(mAlphaRect.right),
+            Math.round(mAlphaRect.bottom)
+        );
+
+    }
+
+
+    /**
+     * Set a OnColorChangedListener to get notified when the color
+     * selected by the user has changed.
+     * @param listener
+     */
+    public void setOnColorChangedListener(OnColorChangedListener listener){
+        mListener = listener;
+    }
+
+    /**
+     * Set the color of the border surrounding all panels.
+     * @param color
+     */
+    public void setBorderColor(int color){
+        mBorderColor = color;
+        invalidate();
+    }
+
+    /**
+     * Get the color of the border surrounding all panels.
+     */
+    public int getBorderColor(){
+        return mBorderColor;
+    }
+
+    /**
+     * Get the current color this view is showing.
+     * @return the current color.
+     */
+    public int getColor(){
+        return Color.HSVToColor(mAlpha, new float[]{mHue,mSat,mVal});
+    }
+
+    /**
+     * Set the color the view should show.
+     * @param color The color that should be selected.
+     */
+    public void setColor(int color){
+        setColor(color, false);
+    }
+
+    /**
+     * Set the color this view should show.
+     * @param color The color that should be selected.
+     * @param callback If you want to get a callback to
+     * your OnColorChangedListener.
+     */
+    public void setColor(int color, boolean callback){
+
+        int alpha = Color.alpha(color);
+        int red = Color.red(color);
+        int blue = Color.blue(color);
+        int green = Color.green(color);
+
+        float[] hsv = new float[3];
+
+        Color.RGBToHSV(red, green, blue, hsv);
+
+        mAlpha = alpha;
+        mHue = hsv[0];
+        mSat = hsv[1];
+        mVal = hsv[2];
+
+        if(callback && mListener != null){
+            mListener.onColorChanged(Color.HSVToColor(mAlpha, new float[]{mHue, mSat, mVal}));
+        }
+
+        invalidate();
+    }
+
+    /**
+     * Get the drawing offset of the color picker view.
+     * The drawing offset is the distance from the side of
+     * a panel to the side of the view minus the padding.
+     * Useful if you want to have your own panel below showing
+     * the currently selected color and want to align it perfectly.
+     * @return The offset in pixels.
+     */
+    public float getDrawingOffset(){
+        return mDrawingOffset;
+    }
+
+    /**
+     * Set if the user is allowed to adjust the alpha panel. Default is false.
+     * If it is set to false no alpha will be set.
+     * @param visible
+     */
+    public void setAlphaSliderVisible(boolean visible){
+
+        if(mShowAlphaPanel != visible){
+            mShowAlphaPanel = visible;
+
+            /*
+             * Reset all shader to force a recreation.
+             * Otherwise they will not look right after
+             * the size of the view has changed.
+             */
+            mValShader = null;
+            mSatShader = null;
+            mHueShader = null;
+            mAlphaShader = null;;
+
+            requestLayout();
+        }
+
+    }
+
+    public void setSliderTrackerColor(int color){
+        mSliderTrackerColor = color;
+
+        mHueTrackerPaint.setColor(mSliderTrackerColor);
+
+        invalidate();
+    }
+
+    public int getSliderTrackerColor(){
+        return mSliderTrackerColor;
+    }
+
+    /**
+     * Set the text that should be shown in the
+     * alpha slider. Set to null to disable text.
+     * @param res string resource id.
+     */
+    public void setAlphaSliderText(int res){
+        String text = getContext().getString(res);
+        setAlphaSliderText(text);
+    }
+
+    /**
+     * Set the text that should be shown in the
+     * alpha slider. Set to null to disable text.
+     * @param text Text that should be shown.
+     */
+    public void setAlphaSliderText(String text){
+        mAlphaSliderText = text;
+        invalidate();
+    }
+
+    /**
+     * Get the current value of the text
+     * that will be shown in the alpha
+     * slider.
+     * @return
+     */
+    public String getAlphaSliderText(){
+        return mAlphaSliderText;
+    }
+}
-- 
1.9.1

